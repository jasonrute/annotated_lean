<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Oliver Nash. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Oliver Nash</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import ring_theory.algebra data.matrix.basic linear_algebra.linear_action</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/algebra.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  # Lie algebras</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  This file defines Lie rings, and Lie algebras over a commutative ring. It shows how these arise from</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  associative rings and algebras via the ring commutator. In particular it defines the Lie algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  of endomorphisms of a module as well as of the algebra of square matrices over a commutative ring.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  It also includes definitions of morphisms of Lie algebras, Lie subalgebras, Lie modules, Lie</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  submodules, and the quotient of a Lie algebra by an ideal.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  ## Notations</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  We introduce the notation ⁅x, y⁆ for the Lie bracket. Note that these are the Unicode &quot;square with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  quill&quot; brackets rather than the usual square brackets.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  We also introduce the notations L →ₗ⁅R⁆ L&#x27; for a morphism of Lie algebras over a commutative ring R,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  and L →ₗ⁅⁆ L&#x27; for the same, when the ring is implicit.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  ## Implementation notes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  Lie algebras are defined as modules with a compatible Lie ring structure, and thus are partially</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  unbundled. Since they extend Lie rings, these are also partially unbundled.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  ## References</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  * [N. Bourbaki, *Lie Groups and Lie Algebras, Chapters 1--3*][bourbaki1975]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  ## Tags</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  lie bracket, ring commutator, jacobi identity, lie ring, lie algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  A binary operation, intended use in Lie algebras and similar structures.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  class has_bracket (L : Type v) := (bracket : L → L → L)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  notation `⁅`x`,` y`⁆` := has_bracket.bracket x y</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  namespace ring_commutator</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  variables {A : Type v} [ring A]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  The ring commutator captures the extent to which a ring is commutative. It is identically zero</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  exactly when the ring is commutative.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  def commutator (x y : A) := x*y - y*x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  local notation `⁅`x`,` y`⁆` := commutator x y</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  @[simp] lemma add_left (x y z : A) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    ⁅x + y, z⁆ = ⁅x, z⁆ + ⁅y, z⁆ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  by simp [commutator, right_distrib, left_distrib]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simp] lemma add_right (x y z : A) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    ⁅z, x + y⁆ = ⁅z, x⁆ + ⁅z, y⁆ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  by simp [commutator, right_distrib, left_distrib]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  @[simp] lemma alternate (x : A) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    ⁅x, x⁆ = 0 :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  by simp [commutator]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  lemma jacobi (x y z : A) :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    ⁅x, ⁅y, z⁆⁆ + ⁅y, ⁅z, x⁆⁆ + ⁅z, ⁅x, y⁆⁆ = 0 :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    unfold commutator,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    repeat { rw mul_sub_left_distrib },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    repeat { rw mul_sub_right_distrib },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    repeat { rw add_sub },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    repeat { rw ←sub_add },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    repeat { rw ←mul_assoc },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : semigroup.{v} α] (a b c : α), @eq.{v+1} α (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) a b) c) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) a (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A
                (@add_semigroup.to_has_add.{v} A
                   (@add_monoid.to_add_semigroup.{v} A
                      (@add_group.to_add_monoid.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                (@has_add.add.{v} A
                   (@add_semigroup.to_has_add.{v} A
                      (@add_monoid.to_add_semigroup.{v} A
                         (@add_group.to_add_monoid.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                   (@has_sub.sub.{v} A
                      (@add_group_has_sub.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_add.add.{v} A
                            (@add_semigroup.to_has_add.{v} A
                               (@add_monoid.to_add_semigroup.{v} A
                                  (@add_group.to_add_monoid.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                            (@has_add.add.{v} A
                               (@add_semigroup.to_has_add.{v} A
                                  (@add_monoid.to_add_semigroup.{v} A
                                     (@add_group.to_add_monoid.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                               (@has_sub.sub.{v} A
                                  (@add_group_has_sub.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                  (@has_sub.sub.{v} A
                                     (@add_group_has_sub.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        x
                                        (@has_mul.mul.{v} A
                                           (@mul_zero_class.to_has_mul.{v} A
                                              (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                           y
                                           z))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        x
                                        (@has_mul.mul.{v} A
                                           (@mul_zero_class.to_has_mul.{v} A
                                              (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                           z
                                           y)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        y
                                        z)
                                     x))
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     z
                                     y)
                                  x))
                            (@has_mul.mul.{v} A
                               (@mul_zero_class.to_has_mul.{v} A
                                  (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                               y
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  z
                                  x)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            y
                            (@has_mul.mul.{v} A
                               (@mul_zero_class.to_has_mul.{v} A
                                  (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                               x
                               z)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            x)
                         y))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         x
                         z)
                      y))
                (@has_mul.mul.{v} A
                   (@mul_zero_class.to_has_mul.{v} A
                      (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                   z
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      x
                      y)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                z
                (@has_mul.mul.{v} A
                   (@mul_zero_class.to_has_mul.{v} A
                      (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                   y
                   x)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A
                (@add_semigroup.to_has_add.{v} A
                   (@add_monoid.to_add_semigroup.{v} A
                      (@add_group.to_add_monoid.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                (@has_add.add.{v} A
                   (@add_semigroup.to_has_add.{v} A
                      (@add_monoid.to_add_semigroup.{v} A
                         (@add_group.to_add_monoid.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                   (@has_sub.sub.{v} A
                      (@add_group_has_sub.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_add.add.{v} A
                            (@add_semigroup.to_has_add.{v} A
                               (@add_monoid.to_add_semigroup.{v} A
                                  (@add_group.to_add_monoid.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                            (@has_add.add.{v} A
                               (@add_semigroup.to_has_add.{v} A
                                  (@add_monoid.to_add_semigroup.{v} A
                                     (@add_group.to_add_monoid.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                               (@has_sub.sub.{v} A
                                  (@add_group_has_sub.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                  (@has_sub.sub.{v} A
                                     (@add_group_has_sub.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           y)
                                        z)
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        x
                                        (@has_mul.mul.{v} A
                                           (@mul_zero_class.to_has_mul.{v} A
                                              (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                           z
                                           y)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        y
                                        z)
                                     x))
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     z
                                     y)
                                  x))
                            (@has_mul.mul.{v} A
                               (@mul_zero_class.to_has_mul.{v} A
                                  (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                               y
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  z
                                  x)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            y
                            (@has_mul.mul.{v} A
                               (@mul_zero_class.to_has_mul.{v} A
                                  (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                               x
                               z)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            x)
                         y))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         x
                         z)
                      y))
                (@has_mul.mul.{v} A
                   (@mul_zero_class.to_has_mul.{v} A
                      (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                   z
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      x
                      y)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                z
                (@has_mul.mul.{v} A
                   (@mul_zero_class.to_has_mul.{v} A
                      (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                   y
                   x)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A
                (@add_semigroup.to_has_add.{v} A
                   (@add_monoid.to_add_semigroup.{v} A
                      (@add_group.to_add_monoid.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                (@has_add.add.{v} A
                   (@add_semigroup.to_has_add.{v} A
                      (@add_monoid.to_add_semigroup.{v} A
                         (@add_group.to_add_monoid.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                   (@has_sub.sub.{v} A
                      (@add_group_has_sub.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_add.add.{v} A
                            (@add_semigroup.to_has_add.{v} A
                               (@add_monoid.to_add_semigroup.{v} A
                                  (@add_group.to_add_monoid.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                            (@has_add.add.{v} A
                               (@add_semigroup.to_has_add.{v} A
                                  (@add_monoid.to_add_semigroup.{v} A
                                     (@add_group.to_add_monoid.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                               (@has_sub.sub.{v} A
                                  (@add_group_has_sub.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                  (@has_sub.sub.{v} A
                                     (@add_group_has_sub.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           y)
                                        z)
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           z)
                                        y))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        y
                                        z)
                                     x))
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     z
                                     y)
                                  x))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               (@has_mul.mul.{v} A
                                  (@semigroup.to_has_mul.{v} A
                                     (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                  y
                                  z)
                               x))
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               y
                               x)
                            z))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            x)
                         y))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         x
                         z)
                      y))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   (@has_mul.mul.{v} A
                      (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                      z
                      x)
                   y))
             (@has_mul.mul.{v} A
                (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   z
                   y)
                x))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    have h : ∀ (x y z : A), x - y + z + y = x+z := by simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A
                (@add_semigroup.to_has_add.{v} A
                   (@add_monoid.to_add_semigroup.{v} A
                      (@add_group.to_add_monoid.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                (@has_add.add.{v} A
                   (@add_semigroup.to_has_add.{v} A
                      (@add_monoid.to_add_semigroup.{v} A
                         (@add_group.to_add_monoid.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                   (@has_sub.sub.{v} A
                      (@add_group_has_sub.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_add.add.{v} A
                            (@add_semigroup.to_has_add.{v} A
                               (@add_monoid.to_add_semigroup.{v} A
                                  (@add_group.to_add_monoid.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                            (@has_add.add.{v} A
                               (@add_semigroup.to_has_add.{v} A
                                  (@add_monoid.to_add_semigroup.{v} A
                                     (@add_group.to_add_monoid.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                               (@has_sub.sub.{v} A
                                  (@add_group_has_sub.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                  (@has_sub.sub.{v} A
                                     (@add_group_has_sub.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           y)
                                        z)
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           z)
                                        y))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        y
                                        z)
                                     x))
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     z
                                     y)
                                  x))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               (@has_mul.mul.{v} A
                                  (@semigroup.to_has_mul.{v} A
                                     (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                  y
                                  z)
                               x))
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               y
                               x)
                            z))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            x)
                         y))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         x
                         z)
                      y))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   (@has_mul.mul.{v} A
                      (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                      z
                      x)
                   y))
             (@has_mul.mul.{v} A
                (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   z
                   y)
                x))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A
⊢ ∀ (x y z : A),
    @eq.{v+1} A
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
         (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
            (@has_sub.sub.{v} A
               (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
               x
               y)
            z)
         y)
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A,
h :
  ∀ (x y z : A),
    @eq.{v+1} A
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
         (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
            (@has_sub.sub.{v} A
               (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
               x
               y)
            z)
         y)
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x z)
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A
                (@add_semigroup.to_has_add.{v} A
                   (@add_monoid.to_add_semigroup.{v} A
                      (@add_group.to_add_monoid.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                (@has_add.add.{v} A
                   (@add_semigroup.to_has_add.{v} A
                      (@add_monoid.to_add_semigroup.{v} A
                         (@add_group.to_add_monoid.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                   (@has_sub.sub.{v} A
                      (@add_group_has_sub.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_add.add.{v} A
                            (@add_semigroup.to_has_add.{v} A
                               (@add_monoid.to_add_semigroup.{v} A
                                  (@add_group.to_add_monoid.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                            (@has_add.add.{v} A
                               (@add_semigroup.to_has_add.{v} A
                                  (@add_monoid.to_add_semigroup.{v} A
                                     (@add_group.to_add_monoid.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                               (@has_sub.sub.{v} A
                                  (@add_group_has_sub.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                  (@has_sub.sub.{v} A
                                     (@add_group_has_sub.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           y)
                                        z)
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           z)
                                        y))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        y
                                        z)
                                     x))
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     z
                                     y)
                                  x))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               (@has_mul.mul.{v} A
                                  (@semigroup.to_has_mul.{v} A
                                     (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                  y
                                  z)
                               x))
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               y
                               x)
                            z))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            x)
                         y))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         x
                         z)
                      y))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   (@has_mul.mul.{v} A
                      (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                      z
                      x)
                   y))
             (@has_mul.mul.{v} A
                (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   z
                   y)
                x))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    repeat { rw h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x y z : A), @eq.{v+1} A (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) (@has_sub.sub.{v} A (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1))) x y) z) y) (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A,
h :
  ∀ (x y z : A),
    @eq.{v+1} A
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
         (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
            (@has_sub.sub.{v} A
               (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
               x
               y)
            z)
         y)
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x z)
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A
                (@add_semigroup.to_has_add.{v} A
                   (@add_monoid.to_add_semigroup.{v} A
                      (@add_group.to_add_monoid.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                (@has_add.add.{v} A
                   (@add_semigroup.to_has_add.{v} A
                      (@add_monoid.to_add_semigroup.{v} A
                         (@add_group.to_add_monoid.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                   (@has_sub.sub.{v} A
                      (@add_group_has_sub.{v} A
                         (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_add.add.{v} A
                            (@add_semigroup.to_has_add.{v} A
                               (@add_monoid.to_add_semigroup.{v} A
                                  (@add_group.to_add_monoid.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                            (@has_add.add.{v} A
                               (@add_semigroup.to_has_add.{v} A
                                  (@add_monoid.to_add_semigroup.{v} A
                                     (@add_group.to_add_monoid.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                               (@has_sub.sub.{v} A
                                  (@add_group_has_sub.{v} A
                                     (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                  (@has_sub.sub.{v} A
                                     (@add_group_has_sub.{v} A
                                        (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           y)
                                        z)
                                     (@has_mul.mul.{v} A
                                        (@semigroup.to_has_mul.{v} A
                                           (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                        (@has_mul.mul.{v} A
                                           (@semigroup.to_has_mul.{v} A
                                              (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                           x
                                           z)
                                        y))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     (@has_mul.mul.{v} A
                                        (@mul_zero_class.to_has_mul.{v} A
                                           (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                        y
                                        z)
                                     x))
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@mul_zero_class.to_has_mul.{v} A
                                        (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                     z
                                     y)
                                  x))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               (@has_mul.mul.{v} A
                                  (@semigroup.to_has_mul.{v} A
                                     (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                  y
                                  z)
                               x))
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               y
                               x)
                            z))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            x)
                         y))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         x
                         z)
                      y))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   (@has_mul.mul.{v} A
                      (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                      z
                      x)
                   y))
             (@has_mul.mul.{v} A
                (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   z
                   y)
                x))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A,
h :
  ∀ (x y z : A),
    @eq.{v+1} A
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
         (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
            (@has_sub.sub.{v} A
               (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
               x
               y)
            z)
         y)
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x z)
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
                (@has_sub.sub.{v} A
                   (@add_group_has_sub.{v} A
                      (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                   (@has_add.add.{v} A
                      (@add_semigroup.to_has_add.{v} A
                         (@add_monoid.to_add_semigroup.{v} A
                            (@add_group.to_add_monoid.{v} A
                               (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                      (@has_add.add.{v} A
                         (@add_semigroup.to_has_add.{v} A
                            (@add_monoid.to_add_semigroup.{v} A
                               (@add_group.to_add_monoid.{v} A
                                  (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
                         (@has_sub.sub.{v} A
                            (@add_group_has_sub.{v} A
                               (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                            (@has_sub.sub.{v} A
                               (@add_group_has_sub.{v} A
                                  (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                               (@has_mul.mul.{v} A
                                  (@semigroup.to_has_mul.{v} A
                                     (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@semigroup.to_has_mul.{v} A
                                        (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                     x
                                     y)
                                  z)
                               (@has_mul.mul.{v} A
                                  (@semigroup.to_has_mul.{v} A
                                     (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                  (@has_mul.mul.{v} A
                                     (@semigroup.to_has_mul.{v} A
                                        (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                                     x
                                     z)
                                  y))
                            (@has_mul.mul.{v} A
                               (@mul_zero_class.to_has_mul.{v} A
                                  (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                               (@has_mul.mul.{v} A
                                  (@mul_zero_class.to_has_mul.{v} A
                                     (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                                  y
                                  z)
                               x))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@mul_zero_class.to_has_mul.{v} A
                                  (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                               z
                               y)
                            x))
                      (@has_mul.mul.{v} A
                         (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            y
                            z)
                         x))
                   (@has_mul.mul.{v} A
                      (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                         y
                         x)
                      z))
                (@has_mul.mul.{v} A
                   (@mul_zero_class.to_has_mul.{v} A
                      (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      x
                      z)
                   y))
             (@has_mul.mul.{v} A
                (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   z
                   y)
                x))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A,
h :
  ∀ (x y z : A),
    @eq.{v+1} A
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
         (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
            (@has_sub.sub.{v} A
               (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
               x
               y)
            z)
         y)
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x z)
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
                (@has_sub.sub.{v} A
                   (@add_group_has_sub.{v} A
                      (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                   (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               x
                               y)
                            z)
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               x
                               z)
                            y))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            y)
                         x))
                   (@has_mul.mul.{v} A
                      (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                         y
                         x)
                      z))
                (@has_mul.mul.{v} A
                   (@mul_zero_class.to_has_mul.{v} A
                      (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      x
                      z)
                   y))
             (@has_mul.mul.{v} A
                (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   z
                   y)
                x))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type v,
_inst_1 : ring.{v} A,
x y z : A,
h :
  ∀ (x y z : A),
    @eq.{v+1} A
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
         (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
            (@has_sub.sub.{v} A
               (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
               x
               y)
            z)
         y)
      (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x z)
⊢ @eq.{v+1} A
    (@has_add.add.{v} A
       (@add_semigroup.to_has_add.{v} A
          (@add_monoid.to_add_semigroup.{v} A
             (@add_group.to_add_monoid.{v} A
                (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))))
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
          (@has_sub.sub.{v} A
             (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
             (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
                (@has_sub.sub.{v} A
                   (@add_group_has_sub.{v} A
                      (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                   (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1))
                      (@has_sub.sub.{v} A
                         (@add_group_has_sub.{v} A
                            (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               x
                               y)
                            z)
                         (@has_mul.mul.{v} A
                            (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                            (@has_mul.mul.{v} A
                               (@semigroup.to_has_mul.{v} A
                                  (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                               x
                               z)
                            y))
                      (@has_mul.mul.{v} A
                         (@mul_zero_class.to_has_mul.{v} A
                            (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                         (@has_mul.mul.{v} A
                            (@mul_zero_class.to_has_mul.{v} A
                               (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                            z
                            y)
                         x))
                   (@has_mul.mul.{v} A
                      (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                      (@has_mul.mul.{v} A
                         (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                         y
                         x)
                      z))
                (@has_mul.mul.{v} A
                   (@mul_zero_class.to_has_mul.{v} A
                      (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                   (@has_mul.mul.{v} A
                      (@mul_zero_class.to_has_mul.{v} A
                         (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                      x
                      z)
                   y))
             (@has_mul.mul.{v} A
                (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                (@has_mul.mul.{v} A
                   (@semigroup.to_has_mul.{v} A (@monoid.to_semigroup.{v} A (@ring.to_monoid.{v} A _inst_1)))
                   z
                   y)
                x))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             (@has_mul.mul.{v} A
                (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
                x
                y)
             z))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1)))
             y
             x)
          z))
    (@has_zero.zero.{v} A
       (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  end ring_commutator</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  section prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  set_option default_priority 100 -- see Note [default priority]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='default priority for attributes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  A Lie ring is an additive group with compatible product, known as the bracket, satisfying the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  Jacobi identity. The bracket is not associative unless it is identically zero.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  class lie_ring (L : Type v) [add_comm_group L] extends has_bracket L :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='A binary operation, intended use in Lie algebras and similar structures.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  (add_lie : ∀ (x y z : L), ⁅x + y, z⁆ = ⁅x, z⁆ + ⁅y, z⁆)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='add_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L to_has_bracket (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y) z) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L to_has_bracket x z) (@has_bracket.bracket.{v} L to_has_bracket y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  (lie_add : ∀ (x y z : L), ⁅z, x + y⁆ = ⁅z, x⁆ + ⁅z, y⁆)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='lie_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L to_has_bracket z (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y)) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L to_has_bracket z x) (@has_bracket.bracket.{v} L to_has_bracket z y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  (lie_self : ∀ (x : L), ⁅x, x⁆ = 0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lie_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ (x : L), @eq.{v+1} L (@has_bracket.bracket.{v} L to_has_bracket x x) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  (jacobi : ∀ (x y z : L), ⁅x, ⁅y, z⁆⁆ + ⁅y, ⁅z, x⁆⁆ + ⁅z, ⁅x, y⁆⁆ = 0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='jacobi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='∀ (x y z : L), @eq.{v+1} L (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L to_has_bracket x (@has_bracket.bracket.{v} L to_has_bracket y z)) (@has_bracket.bracket.{v} L to_has_bracket y (@has_bracket.bracket.{v} L to_has_bracket z x))) (@has_bracket.bracket.{v} L to_has_bracket z (@has_bracket.bracket.{v} L to_has_bracket x y))) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  end prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  section lie_ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  variables {L : Type v} [add_comm_group L] [lie_ring L]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lie_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (L : Type v) [_inst_1 : add_comm_group.{v} L], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A Lie ring is an additive group with compatible product, known as the bracket, satisfying the
Jacobi identity. The bracket is not associative unless it is identically zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  @[simp] lemma add_lie (x y z : L) : ⁅x + y, z⁆ = ⁅x, z⁆ + ⁅y, z⁆ := lie_ring.add_lie x y z</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_ring.add_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [c : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y) z) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x z) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  @[simp] lemma lie_add (x y z : L) : ⁅z, x + y⁆ = ⁅z, x⁆ + ⁅z, y⁆ := lie_ring.lie_add x y z</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_ring.lie_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [c : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y)) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z x) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  @[simp] lemma lie_self (x : L) : ⁅x, x⁆ = 0 := lie_ring.lie_self x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lie_ring.lie_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [c : @lie_ring.{v} L _inst_1] (x : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x x) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  @[simp] lemma lie_skew (x y : L) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    -⁅y, x⁆ = ⁅x, y⁆ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    symmetry,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    rw [←sub_eq_zero_iff_eq, sub_neg_eq_add],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='sub_eq_zero_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_neg_eq_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] {a b : α}, iff (@eq.{v+1} α (@has_sub.sub.{v} α (@add_group_has_sub.{v} α _inst_1) a b) (@has_zero.zero.{v} α (@add_monoid.to_has_zero.{v} α (@add_group.to_add_monoid.{v} α _inst_1)))) (@eq.{v+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] (a b : α), @eq.{v+1} α (@has_sub.sub.{v} α (@add_group_has_sub.{v} α _inst_1) a (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α _inst_1) b)) (@has_add.add.{v} α (@add_semigroup.to_has_add.{v} α (@add_monoid.to_add_semigroup.{v} α (@add_group.to_add_monoid.{v} α _inst_1))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    have H : ⁅x + y, x + y⁆ = 0, from lie_self _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='lie_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 107, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x x) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))

L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
H :
  @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
H :
  @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    rw add_lie at H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y) z) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x z) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
H :
  @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          x
          y))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
H :
  @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
             x
             y))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
             x
             y)))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    simpa using H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} L (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y))) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
H :
  @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
             x
             y))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
             x
             y)))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  @[simp] lemma lie_zero (x : L) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    ⁅x, 0⁆ = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    have H : ⁅x, 0⁆ + ⁅x, 0⁆ = ⁅x, 0⁆ + 0 := by { rw ←lie_add, simp, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='lie_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y)) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z x) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L,
H :
  @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    exact add_left_cancel H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='add_left_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_left_cancel_semigroup.{v} α] {a b c : α}, @eq.{v+1} α (@has_add.add.{v} α (@add_semigroup.to_has_add.{v} α (@add_left_cancel_semigroup.to_add_semigroup.{v} α _inst_1)) a b) (@has_add.add.{v} α (@add_semigroup.to_has_add.{v} α (@add_left_cancel_semigroup.to_add_semigroup.{v} α _inst_1)) a c) → @eq.{v+1} α b c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} L (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L,
H :
  @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  @[simp] lemma zero_lie (x : L) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    ⁅0, x⁆ = 0 := by { rw [←lie_skew, lie_zero], simp, }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 119, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       x)
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
          (@has_zero.zero.{v} L
             (@add_monoid.to_has_zero.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_zero.zero.{v} L
          (@add_monoid.to_has_zero.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  @[simp] lemma neg_lie (x y : L) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    ⁅-x, y⁆ = -⁅x, y⁆ := by { rw [←sub_eq_zero_iff_eq, sub_neg_eq_add, ←add_lie], simp, }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='sub_eq_zero_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_neg_eq_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] {a b : α}, iff (@eq.{v+1} α (@has_sub.sub.{v} α (@add_group_has_sub.{v} α _inst_1) a b) (@has_zero.zero.{v} α (@add_monoid.to_has_zero.{v} α (@add_group.to_add_monoid.{v} α _inst_1)))) (@eq.{v+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] (a b : α), @eq.{v+1} α (@has_sub.sub.{v} α (@add_group_has_sub.{v} α _inst_1) a (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α _inst_1) b)) (@has_add.add.{v} α (@add_semigroup.to_has_add.{v} α (@add_monoid.to_add_semigroup.{v} α (@add_group.to_add_monoid.{v} α _inst_1))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y) z) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x z) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) x)
       y)
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
          (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) x)
          y)
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
          (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) x)
          y)
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
          (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) x)
          x)
       y)
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  @[simp] lemma lie_neg (x y : L) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    ⁅x, -y⁆ = -⁅x, y⁆ := by { rw [←lie_skew, ←lie_skew], simp, }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) y))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
          (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) y)
          x))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
             (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) y))))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  @[simp] lemma gsmul_lie (x y : L) (n : ℤ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    ⁅n • x, y⁆ = n • ⁅x, y⁆ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type v} [c : has_scalar.{0 v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type v} [c : has_scalar.{0 v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          x)
       y)
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    let Ad := λ z, ⁅z, y⁆,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          x)
       y)
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int,
Ad : L → L := λ (z : L), @has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          x)
       y)
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    haveI : is_add_group_hom Ad := { map_add := by simp [Ad], },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Ad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='Ad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v} [_inst_1 : add_group.{v} α] [_inst_2 : add_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int,
Ad : L → L := λ (z : L), @has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          x)
       y)
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int,
Ad : L → L := λ (z : L), @has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y
⊢ ∀ (x y : L),
    @eq.{v+1} L
      (Ad
         (@has_add.add.{v} L
            (@add_semigroup.to_has_add.{v} L
               (@add_monoid.to_add_semigroup.{v} L
                  (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
            x
            y))
      (@has_add.add.{v} L
         (@add_semigroup.to_has_add.{v} L
            (@add_monoid.to_add_semigroup.{v} L
               (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))
         (Ad x)
         (Ad y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int,
Ad : L → L := λ (z : L), @has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          x)
       y)
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int,
Ad : L → L := λ (z : L), @has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y,
_inst :
  @is_add_group_hom.{v v} L L (@add_comm_group.to_add_group.{v} L _inst_1) (@add_comm_group.to_add_group.{v} L _inst_1)
    Ad
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          x)
       y)
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    apply is_add_group_hom.map_gsmul Ad,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_add_group_hom.map_gsmul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Ad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 356, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} [_inst_1 : add_group.{v} α] [_inst_2 : add_group.{v} β] (f : α → β) [_inst_3 : @is_add_group_hom.{v v} α β _inst_1 _inst_2 f] (a : α) (n : int), @eq.{v+1} β (f (@gsmul.{v} α _inst_1 n a)) (@gsmul.{v} β _inst_2 n (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int,
Ad : L → L := λ (z : L), @has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y,
_inst :
  @is_add_group_hom.{v v} L L (@add_comm_group.to_add_group.{v} L _inst_1) (@add_comm_group.to_add_group.{v} L _inst_1)
    Ad
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          x)
       y)
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  @[simp] lemma lie_gsmul (x y : L) (n : ℤ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    ⁅x, n • y⁆ = n • ⁅x, y⁆ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type v} [c : has_scalar.{0 v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type v} [c : has_scalar.{0 v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          y))
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    rw [←lie_skew, ←lie_skew x, gsmul_lie],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gsmul_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L) (n : int), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) (@has_scalar.smul.{0 v} int L (@mul_action.to_has_scalar.{0 v} int L int.monoid (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring (@add_comm_group.to_add_comm_monoid.{v} L _inst_1) (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1))))) n x) y) (@has_scalar.smul.{0 v} int L (@mul_action.to_has_scalar.{0 v} int L int.monoid (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring (@add_comm_group.to_add_comm_monoid.{v} L _inst_1) (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1))))) n (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          y))
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
          (@has_scalar.smul.{0 v} int L
             (@mul_action.to_has_scalar.{0 v} int L int.monoid
                (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                      (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
             n
             y)
          x))
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2)
          (@has_scalar.smul.{0 v} int L
             (@mul_action.to_has_scalar.{0 v} int L int.monoid
                (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                      (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
             n
             y)
          x))
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    unfold has_scalar.smul, rw gsmul_neg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='gsmul_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type v} [_inst_2 : add_group.{v} β] (a : β) (n : int), @eq.{v+1} β (@gsmul.{v} β _inst_2 n (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β _inst_2) a)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β _inst_2) (@gsmul.{v} β _inst_2 n a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@has_scalar.smul.{0 v} int L
          (@mul_action.to_has_scalar.{0 v} int L int.monoid
             (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
                (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                   (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
          n
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))
    (@has_scalar.smul.{0 v} int L
       (@mul_action.to_has_scalar.{0 v} int L int.monoid
          (@distrib_mul_action.to_mul_action.{0 v} int L int.monoid
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
             (@semimodule.to_distrib_mul_action.{0 v} int L int.semiring
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_1)
                (@module.to_semimodule.{0 v} int L int.ring _inst_1 (@add_comm_group.module.{v} L _inst_1)))))
       n
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='L : Type v,
_inst_1 : add_comm_group.{v} L,
_inst_2 : @lie_ring.{v} L _inst_1,
x y : L,
n : int
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
       (@gsmul.{v} L (@add_comm_group.to_add_group.{v} L _inst_1) n
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))
    (@gsmul.{v} L (@add_comm_group.to_add_group.{v} L _inst_1) n
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))
          (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  An associative ring gives rise to a Lie ring by taking the bracket to be the ring commutator.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  def lie_ring.of_associative_ring (A : Type v) [ring A] : lie_ring A :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (L : Type v) [_inst_1 : add_comm_group.{v} L], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='A Lie ring is an additive group with compatible product, known as the bracket, satisfying the
Jacobi identity. The bracket is not associative unless it is identically zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  { bracket  := ring_commutator.commutator,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    add_lie  := ring_commutator.add_left,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ring_commutator.add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {A : Type v} [_inst_1 : ring.{v} A] (x y z : A), @eq.{v+1} A (@ring_commutator.commutator.{v} A _inst_1 (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x y) z) (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) (@ring_commutator.commutator.{v} A _inst_1 x z) (@ring_commutator.commutator.{v} A _inst_1 y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    lie_add  := ring_commutator.add_right,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ring_commutator.add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 64, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {A : Type v} [_inst_1 : ring.{v} A] (x y z : A), @eq.{v+1} A (@ring_commutator.commutator.{v} A _inst_1 z (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) x y)) (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) (@ring_commutator.commutator.{v} A _inst_1 z x) (@ring_commutator.commutator.{v} A _inst_1 z y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    lie_self := ring_commutator.alternate,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ring_commutator.alternate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 68, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {A : Type v} [_inst_1 : ring.{v} A] (x : A), @eq.{v+1} A (@ring_commutator.commutator.{v} A _inst_1 x x) (@has_zero.zero.{v} A (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158    jacobi   := ring_commutator.jacobi }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ring_commutator.jacobi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {A : Type v} [_inst_1 : ring.{v} A] (x y z : A), @eq.{v+1} A (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) (@has_add.add.{v} A (@distrib.to_has_add.{v} A (@ring.to_distrib.{v} A _inst_1)) (@ring_commutator.commutator.{v} A _inst_1 x (@ring_commutator.commutator.{v} A _inst_1 y z)) (@ring_commutator.commutator.{v} A _inst_1 y (@ring_commutator.commutator.{v} A _inst_1 z x))) (@ring_commutator.commutator.{v} A _inst_1 z (@ring_commutator.commutator.{v} A _inst_1 x y))) (@has_zero.zero.{v} A (@mul_zero_class.to_has_zero.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  end lie_ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  section prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  set_option default_priority 100 -- see Note [default priority]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='default priority for attributes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  class lie_algebra (R : Type u) (L : Type v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    [comm_ring R] [add_comm_group L] extends module R L, lie_ring L :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (L : Type v) [_inst_1 : add_comm_group.{v} L], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A Lie ring is an additive group with compatible product, known as the bracket, satisfying the
Jacobi identity. The bracket is not associative unless it is identically zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  (lie_smul : ∀ (t : R) (x y : L), ⁅x, t • y⁆ = t • ⁅x, y⁆)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lie_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ (t : R) (x y : L), @eq.{v+1} L (@has_bracket.bracket.{v} L to_has_bracket x (@has_scalar.smul.{u v} R L to_has_scalar t y)) (@has_scalar.smul.{u v} R L to_has_scalar t (@has_bracket.bracket.{v} L to_has_bracket x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {γ : Type v} [c : has_scalar.{u v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {γ : Type v} [c : has_scalar.{u v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  end prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  @[simp] lemma lie_smul  (R : Type u) (L : Type v) [comm_ring R] [add_comm_group L] [lie_algebra R L]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                              </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    (t : R) (x y : L) : ⁅x, t • y⁆ = t • ⁅x, y⁆ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {γ : Type v} [c : has_scalar.{u v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {γ : Type v} [c : has_scalar.{u v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    lie_algebra.lie_smul t x y</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_algebra.lie_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [c : @lie_algebra.{u v} R L _inst_1 _inst_2] (t : R) (x y : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 c)) x (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@distrib_mul_action.to_mul_action.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@add_comm_monoid.to_add_monoid.{v} L (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 c))))) t y)) (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@distrib_mul_action.to_mul_action.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@add_comm_monoid.to_add_monoid.{v} L (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 c))))) t (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 c)) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  @[simp] lemma smul_lie (R : Type u) (L : Type v) [comm_ring R] [add_comm_group L] [lie_algebra R L]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    (t : R) (x y : L) : ⁅t • x, y⁆ = t • ⁅x, y⁆ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {γ : Type v} [c : has_scalar.{u v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {γ : Type v} [c : has_scalar.{u v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    by { rw [←lie_skew, ←lie_skew x y], simp [-lie_skew], }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
t : R,
x y : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_scalar.smul.{u v} R L
          (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                (@semimodule.to_distrib_mul_action.{u v} R L
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                   (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
          t
          x)
       y)
    (@has_scalar.smul.{u v} R L
       (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
          (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
             (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
       t
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
t : R,
x y : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y
          (@has_scalar.smul.{u v} R L
             (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                   (@semimodule.to_distrib_mul_action.{u v} R L
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                      (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
             t
             x)))
    (@has_scalar.smul.{u v} R L
       (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
          (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
             (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
       t
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
t : R,
x y : L
⊢ @eq.{v+1} L
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y
          (@has_scalar.smul.{u v} R L
             (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                   (@semimodule.to_distrib_mul_action.{u v} R L
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                      (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
             t
             x)))
    (@has_scalar.smul.{u v} R L
       (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
          (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
             (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
       t
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  namespace lie_algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  A morphism of Lie algebras is a linear map respecting the bracket operations.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  structure morphism (R : Type u) (L : Type v) (L&#x27; : Type v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    [comm_ring R] [add_comm_group L] [lie_algebra R L] [add_comm_group L&#x27;] [lie_algebra R L&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    extends linear_map R L L&#x27; :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u) (β γ : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{v} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u v} α γ _inst_1 _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  (map_lie : ∀ {x y : L}, to_fun ⁅x, y⁆ = ⁅to_fun x, to_fun y⁆)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='map_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {x y : L}, @eq.{v+1} L&#x27; (to_fun (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} L&#x27; (@lie_ring.to_has_bracket.{v} L&#x27; _inst_4 (@lie_algebra.to_lie_ring.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (to_fun x) (to_fun y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@(λ {α : Type u} {β γ : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : add_comm_group.{v} γ} {_inst_4 : @module.{u v} α β _inst_1 _inst_2} {_inst_5 : @module.{u v} α γ _inst_1 _inst_3} (c : @linear_map.{u v v} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), β → γ) R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5) to_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@(λ {α : Type u} {β γ : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : add_comm_group.{v} γ} {_inst_4 : @module.{u v} α β _inst_1 _inst_2} {_inst_5 : @module.{u v} α γ _inst_1 _inst_3} (c : @linear_map.{u v v} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), β → γ) R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5) to_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u} {β γ : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : add_comm_group.{v} γ} {_inst_4 : @module.{u v} α β _inst_1 _inst_2} {_inst_5 : @module.{u v} α γ _inst_1 _inst_3} (c : @linear_map.{u v v} α β γ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), β → γ) R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5) to_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  infixr ` →ₗ⁅⁆ `:25 := morphism _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  notation L ` →ₗ⁅`:25 R:25 `⁆ `:0 L&#x27;:0 := morphism R L L&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  instance (R : Type u) (L : Type v) (L&#x27; : Type v)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    [comm_ring R] [add_comm_group L] [lie_algebra R L] [add_comm_group L&#x27;] [lie_algebra R L&#x27;] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    has_coe (L →ₗ⁅R⁆ L&#x27;) (L →ₗ[R] L&#x27;) := ⟨morphism.to_linear_map⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lie_algebra.morphism.to_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u → Sort v → Sort (max 1 (imax u v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) (β γ : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{v} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u v} α γ _inst_1 _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) (β γ : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{v} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u v} α γ _inst_1 _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {R : Type u} {L L&#x27; : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], @lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 → @linear_map.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  @[simp] lemma map_lie {R : Type u} {L : Type v} {L&#x27; : Type v}</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199    [comm_ring R] [add_comm_group L] [lie_algebra R L] [add_comm_group L&#x27;] [lie_algebra R L&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    (f : L →ₗ⁅R⁆ L&#x27;) (x y : L) : f ⁅x, y⁆ = ⁅f x, f y⁆ := morphism.map_lie f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_algebra.morphism.map_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {R : Type u} {L L&#x27; : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4] (c : @lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) {x y : L}, @eq.{v+1} L&#x27; (@linear_map.to_fun.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5) (@lie_algebra.morphism.to_linear_map.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} L&#x27; (@lie_ring.to_has_bracket.{v} L&#x27; _inst_4 (@lie_algebra.to_lie_ring.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@linear_map.to_fun.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5) (@lie_algebra.morphism.to_linear_map.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c) x) (@linear_map.to_fun.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5) (@lie_algebra.morphism.to_linear_map.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  variables {R : Type u} {L : Type v} [comm_ring R] [add_comm_group L] [lie_algebra R L]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  An associative algebra gives rise to a Lie algebra by taking the bracket to be the ring commutator.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  def of_associative_algebra (A : Type v) [ring A] [algebra R A] : lie_algebra R A :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/algebra.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) (A : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : ring.{v} A], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title=' The category of R-algebras where R is a commutative
ring is the under category R ↓ CRing. In the categorical
setting we have a forgetful functor R-Alg ⥤ R-Mod.
However here it extends module in order to preserve
definitional equality in certain cases.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  { bracket  := ring_commutator.commutator,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ring_commutator.commutator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {A : Type v} [_inst_1 : ring.{v} A], A → A → A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The ring commutator captures the extent to which a ring is commutative. It is identically zero
exactly when the ring is commutative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    lie_smul := by { intros, unfold has_bracket.bracket, unfold ring_commutator.commutator,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
_inst_1 : comm_ring.{u} R,
A : Type v,
_inst_4 : ring.{v} A,
_inst_5 : @algebra.{u v} R A _inst_1 _inst_4
⊢ ∀ (t : R) (x y : A),
    @eq.{v+1} A
      (@has_bracket.bracket.{v} A
         (@lie_ring.to_has_bracket.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
            (@lie_ring.mk.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
               (@has_bracket.mk.{v} A (@ring_commutator.commutator.{v} A _inst_4))
               (@lie_ring.add_lie.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                  (@lie_ring.of_associative_ring.{v} A _inst_4))
               (@lie_ring.lie_add.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                  (@lie_ring.of_associative_ring.{v} A _inst_4))
               (@lie_ring.lie_self.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                  (@lie_ring.of_associative_ring.{v} A _inst_4))
               (@lie_ring.jacobi.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                  (@lie_ring.of_associative_ring.{v} A _inst_4))))
         x
         (@has_scalar.smul.{u v} R A
            (@mul_action.to_has_scalar.{u v} R A
               (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
               (@distrib_mul_action.to_mul_action.{u v} R A
                  (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                  (@add_comm_monoid.to_add_monoid.{v} A
                     (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                  (@semimodule.to_distrib_mul_action.{u v} R A
                     (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                     (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                        (@ring.to_add_comm_group.{v} A _inst_4)
                        (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                           (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                              (@ring.to_add_comm_group.{v} A _inst_4)
                              (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
            t
            y))
      (@has_scalar.smul.{u v} R A
         (@mul_action.to_has_scalar.{u v} R A
            (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
            (@distrib_mul_action.to_mul_action.{u v} R A
               (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
               (@add_comm_monoid.to_add_monoid.{v} A
                  (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
               (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                  (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                     (@ring.to_add_comm_group.{v} A _inst_4)
                     (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                        (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                           (@ring.to_add_comm_group.{v} A _inst_4)
                           (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
         t
         (@has_bracket.bracket.{v} A
            (@lie_ring.to_has_bracket.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
               (@lie_ring.mk.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                  (@has_bracket.mk.{v} A (@ring_commutator.commutator.{v} A _inst_4))
                  (@lie_ring.add_lie.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                     (@lie_ring.of_associative_ring.{v} A _inst_4))
                  (@lie_ring.lie_add.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                     (@lie_ring.of_associative_ring.{v} A _inst_4))
                  (@lie_ring.lie_self.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                     (@lie_ring.of_associative_ring.{v} A _inst_4))
                  (@lie_ring.jacobi.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                     (@lie_ring.of_associative_ring.{v} A _inst_4))))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : comm_ring.{u} R,
A : Type v,
_inst_4 : ring.{v} A,
_inst_5 : @algebra.{u v} R A _inst_1 _inst_4,
t : R,
x y : A
⊢ @eq.{v+1} A
    (@has_bracket.bracket.{v} A
       (@lie_ring.to_has_bracket.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
          (@lie_ring.mk.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
             (@has_bracket.mk.{v} A (@ring_commutator.commutator.{v} A _inst_4))
             (@lie_ring.add_lie.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                (@lie_ring.of_associative_ring.{v} A _inst_4))
             (@lie_ring.lie_add.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                (@lie_ring.of_associative_ring.{v} A _inst_4))
             (@lie_ring.lie_self.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                (@lie_ring.of_associative_ring.{v} A _inst_4))
             (@lie_ring.jacobi.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                (@lie_ring.of_associative_ring.{v} A _inst_4))))
       x
       (@has_scalar.smul.{u v} R A
          (@mul_action.to_has_scalar.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R A
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v} A
                   (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                (@semimodule.to_distrib_mul_action.{u v} R A
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                   (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                      (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                         (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                            (@ring.to_add_comm_group.{v} A _inst_4)
                            (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
          t
          y))
    (@has_scalar.smul.{u v} R A
       (@mul_action.to_has_scalar.{u v} R A
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v} A
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
             (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                   (@ring.to_add_comm_group.{v} A _inst_4)
                   (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
       t
       (@has_bracket.bracket.{v} A
          (@lie_ring.to_has_bracket.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
             (@lie_ring.mk.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                (@has_bracket.mk.{v} A (@ring_commutator.commutator.{v} A _inst_4))
                (@lie_ring.add_lie.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                   (@lie_ring.of_associative_ring.{v} A _inst_4))
                (@lie_ring.lie_add.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                   (@lie_ring.of_associative_ring.{v} A _inst_4))
                (@lie_ring.lie_self.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                   (@lie_ring.of_associative_ring.{v} A _inst_4))
                (@lie_ring.jacobi.{v} A (@ring.to_add_comm_group.{v} A _inst_4)
                   (@lie_ring.of_associative_ring.{v} A _inst_4))))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : comm_ring.{u} R,
A : Type v,
_inst_4 : ring.{v} A,
_inst_5 : @algebra.{u v} R A _inst_1 _inst_4,
t : R,
x y : A
⊢ @eq.{v+1} A
    (@ring_commutator.commutator.{v} A _inst_4 x
       (@has_scalar.smul.{u v} R A
          (@mul_action.to_has_scalar.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R A
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v} A
                   (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                (@semimodule.to_distrib_mul_action.{u v} R A
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                   (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                      (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                         (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                            (@ring.to_add_comm_group.{v} A _inst_4)
                            (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
          t
          y))
    (@has_scalar.smul.{u v} R A
       (@mul_action.to_has_scalar.{u v} R A
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v} A
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
             (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                   (@ring.to_add_comm_group.{v} A _inst_4)
                   (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
       t
       (@ring_commutator.commutator.{v} A _inst_4 x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : comm_ring.{u} R,
A : Type v,
_inst_4 : ring.{v} A,
_inst_5 : @algebra.{u v} R A _inst_1 _inst_4,
t : R,
x y : A
⊢ @eq.{v+1} A
    (@has_sub.sub.{v} A
       (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
          x
          (@has_scalar.smul.{u v} R A
             (@mul_action.to_has_scalar.{u v} R A
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@distrib_mul_action.to_mul_action.{u v} R A
                   (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                   (@add_comm_monoid.to_add_monoid.{v} A
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                   (@semimodule.to_distrib_mul_action.{u v} R A
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                            (@ring.to_add_comm_group.{v} A _inst_4)
                            (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                               (@ring.to_add_comm_group.{v} A _inst_4)
                               (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
             t
             y))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
          (@has_scalar.smul.{u v} R A
             (@mul_action.to_has_scalar.{u v} R A
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@distrib_mul_action.to_mul_action.{u v} R A
                   (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                   (@add_comm_monoid.to_add_monoid.{v} A
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                   (@semimodule.to_distrib_mul_action.{u v} R A
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                            (@ring.to_add_comm_group.{v} A _inst_4)
                            (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                               (@ring.to_add_comm_group.{v} A _inst_4)
                               (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
             t
             y)
          x))
    (@has_scalar.smul.{u v} R A
       (@mul_action.to_has_scalar.{u v} R A
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v} A
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
             (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                   (@ring.to_add_comm_group.{v} A _inst_4)
                   (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
       t
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             x
             y)
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             y
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210                     rw [algebra.mul_smul_comm, algebra.smul_mul_assoc, smul_sub], },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='algebra.mul_smul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='algebra.smul_mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/algebra.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/algebra.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {A : Type v} [_inst_1 : comm_ring.{u} R] [_inst_3 : ring.{v} A] [_inst_4 : @algebra.{u v} R A _inst_1 _inst_3] (s : R) (x y : A), @eq.{v+1} A (@has_mul.mul.{v} A (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_3))) x (@has_scalar.smul.{u v} R A (@mul_action.to_has_scalar.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_3))) (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@semiring.to_add_comm_monoid.{v} A (@ring.to_semiring.{v} A _inst_3)) (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_3) (@algebra.to_module.{u v} R A _inst_1 _inst_3 _inst_4))))) s y)) (@has_scalar.smul.{u v} R A (@mul_action.to_has_scalar.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_3))) (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@semiring.to_add_comm_monoid.{v} A (@ring.to_semiring.{v} A _inst_3)) (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_3) (@algebra.to_module.{u v} R A _inst_1 _inst_3 _inst_4))))) s (@has_mul.mul.{v} A (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_3))) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {A : Type v} [_inst_1 : comm_ring.{u} R] [_inst_3 : ring.{v} A] [_inst_4 : @algebra.{u v} R A _inst_1 _inst_3] (r : R) (x y : A), @eq.{v+1} A (@has_mul.mul.{v} A (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_3))) (@has_scalar.smul.{u v} R A (@mul_action.to_has_scalar.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_3))) (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@semiring.to_add_comm_monoid.{v} A (@ring.to_semiring.{v} A _inst_3)) (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_3) (@algebra.to_module.{u v} R A _inst_1 _inst_3 _inst_4))))) r x) y) (@has_scalar.smul.{u v} R A (@mul_action.to_has_scalar.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_3))) (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@semiring.to_add_comm_monoid.{v} A (@ring.to_semiring.{v} A _inst_3)) (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_3) (@algebra.to_module.{u v} R A _inst_1 _inst_3 _inst_4))))) r (@has_mul.mul.{v} A (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_3))) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2] (r : α) (x y : β), @eq.{v+1} β (@has_scalar.smul.{u v} α β (@mul_action.to_has_scalar.{u v} α β (@ring.to_monoid.{u} α _inst_1) (@distrib_mul_action.to_mul_action.{u v} α β (@ring.to_monoid.{u} α _inst_1) (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β _inst_2)) (@semimodule.to_distrib_mul_action.{u v} α β (@ring.to_semiring.{u} α _inst_1) (@add_comm_group.to_add_comm_monoid.{v} β _inst_2) (@module.to_semimodule.{u v} α β _inst_1 _inst_2 _inst_3)))) r (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β _inst_2)) x y)) (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β _inst_2)) (@has_scalar.smul.{u v} α β (@mul_action.to_has_scalar.{u v} α β (@ring.to_monoid.{u} α _inst_1) (@distrib_mul_action.to_mul_action.{u v} α β (@ring.to_monoid.{u} α _inst_1) (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β _inst_2)) (@semimodule.to_distrib_mul_action.{u v} α β (@ring.to_semiring.{u} α _inst_1) (@add_comm_group.to_add_comm_monoid.{v} β _inst_2) (@module.to_semimodule.{u v} α β _inst_1 _inst_2 _inst_3)))) r x) (@has_scalar.smul.{u v} α β (@mul_action.to_has_scalar.{u v} α β (@ring.to_monoid.{u} α _inst_1) (@distrib_mul_action.to_mul_action.{u v} α β (@ring.to_monoid.{u} α _inst_1) (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β _inst_2)) (@semimodule.to_distrib_mul_action.{u v} α β (@ring.to_semiring.{u} α _inst_1) (@add_comm_group.to_add_comm_monoid.{v} β _inst_2) (@module.to_semimodule.{u v} α β _inst_1 _inst_2 _inst_3)))) r y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : comm_ring.{u} R,
A : Type v,
_inst_4 : ring.{v} A,
_inst_5 : @algebra.{u v} R A _inst_1 _inst_4,
t : R,
x y : A
⊢ @eq.{v+1} A
    (@has_sub.sub.{v} A
       (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
          x
          (@has_scalar.smul.{u v} R A
             (@mul_action.to_has_scalar.{u v} R A
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@distrib_mul_action.to_mul_action.{u v} R A
                   (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                   (@add_comm_monoid.to_add_monoid.{v} A
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                   (@semimodule.to_distrib_mul_action.{u v} R A
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                            (@ring.to_add_comm_group.{v} A _inst_4)
                            (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                               (@ring.to_add_comm_group.{v} A _inst_4)
                               (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
             t
             y))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
          (@has_scalar.smul.{u v} R A
             (@mul_action.to_has_scalar.{u v} R A
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@distrib_mul_action.to_mul_action.{u v} R A
                   (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                   (@add_comm_monoid.to_add_monoid.{v} A
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                   (@semimodule.to_distrib_mul_action.{u v} R A
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                            (@ring.to_add_comm_group.{v} A _inst_4)
                            (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                               (@ring.to_add_comm_group.{v} A _inst_4)
                               (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
             t
             y)
          x))
    (@has_scalar.smul.{u v} R A
       (@mul_action.to_has_scalar.{u v} R A
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v} A
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
             (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                   (@ring.to_add_comm_group.{v} A _inst_4)
                   (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
       t
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             x
             y)
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             y
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : comm_ring.{u} R,
A : Type v,
_inst_4 : ring.{v} A,
_inst_5 : @algebra.{u v} R A _inst_1 _inst_4,
t : R,
x y : A
⊢ @eq.{v+1} A
    (@has_sub.sub.{v} A
       (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
       (@has_scalar.smul.{u v} R A
          (@mul_action.to_has_scalar.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} A
                   (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                (@semimodule.to_distrib_mul_action.{u v} R A
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@semiring.to_add_comm_monoid.{v} A (@ring.to_semiring.{v} A _inst_4))
                   (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                      (@ring.to_add_comm_group.{v} A _inst_4)
                      (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))
          t
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             x
             y))
       (@has_mul.mul.{v} A
          (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
          (@has_scalar.smul.{u v} R A
             (@mul_action.to_has_scalar.{u v} R A
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@distrib_mul_action.to_mul_action.{u v} R A
                   (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                   (@add_comm_monoid.to_add_monoid.{v} A
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                   (@semimodule.to_distrib_mul_action.{u v} R A
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                            (@ring.to_add_comm_group.{v} A _inst_4)
                            (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                               (@ring.to_add_comm_group.{v} A _inst_4)
                               (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
             t
             y)
          x))
    (@has_scalar.smul.{u v} R A
       (@mul_action.to_has_scalar.{u v} R A
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v} A
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
             (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                   (@ring.to_add_comm_group.{v} A _inst_4)
                   (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
       t
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             x
             y)
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             y
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : comm_ring.{u} R,
A : Type v,
_inst_4 : ring.{v} A,
_inst_5 : @algebra.{u v} R A _inst_1 _inst_4,
t : R,
x y : A
⊢ @eq.{v+1} A
    (@has_sub.sub.{v} A
       (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
       (@has_scalar.smul.{u v} R A
          (@mul_action.to_has_scalar.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} A
                   (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                (@semimodule.to_distrib_mul_action.{u v} R A
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@semiring.to_add_comm_monoid.{v} A (@ring.to_semiring.{v} A _inst_4))
                   (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                      (@ring.to_add_comm_group.{v} A _inst_4)
                      (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))
          t
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             x
             y))
       (@has_scalar.smul.{u v} R A
          (@mul_action.to_has_scalar.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R A (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} A
                   (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
                (@semimodule.to_distrib_mul_action.{u v} R A
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@semiring.to_add_comm_monoid.{v} A (@ring.to_semiring.{v} A _inst_4))
                   (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                      (@ring.to_add_comm_group.{v} A _inst_4)
                      (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))
          t
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             y
             x)))
    (@has_scalar.smul.{u v} R A
       (@mul_action.to_has_scalar.{u v} R A
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R A
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v} A
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
             (@semimodule.to_distrib_mul_action.{u v} R A (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} A (@ring.to_add_comm_group.{v} A _inst_4))
                (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                   (@ring.to_add_comm_group.{v} A _inst_4)
                   (@module.mk.{u v} R A (@comm_ring.to_ring.{u} R _inst_1) (@ring.to_add_comm_group.{v} A _inst_4)
                      (@module.to_semimodule.{u v} R A (@comm_ring.to_ring.{u} R _inst_1)
                         (@ring.to_add_comm_group.{v} A _inst_4)
                         (@algebra.to_module.{u v} R A _inst_1 _inst_4 _inst_5)))))))
       t
       (@has_sub.sub.{v} A
          (@add_group_has_sub.{v} A (@add_comm_group.to_add_group.{v} A (@ring.to_add_comm_group.{v} A _inst_4)))
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             x
             y)
          (@has_mul.mul.{v} A
             (@mul_zero_class.to_has_mul.{v} A (@semiring.to_mul_zero_class.{v} A (@ring.to_semiring.{v} A _inst_4)))
             y
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    ..lie_ring.of_associative_ring A }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_ring.of_associative_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 153, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (A : Type v) [_inst_3 : ring.{v} A], @lie_ring.{v} A (@ring.to_add_comm_group.{v} A _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An associative ring gives rise to a Lie ring by taking the bracket to be the ring commutator.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  An important class of Lie algebras are those arising from the associative algebra structure on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  module endomorphisms.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  instance of_endomorphism_algebra (M : Type v)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218    [add_comm_group M] [module R M] : lie_algebra R (module.End R M) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.End'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 260, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  of_associative_algebra (module.End R M)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_algebra.of_associative_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='module.End'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 260, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} [_inst_1 : comm_ring.{u} R] (A : Type v) [_inst_4 : ring.{v} A] [_inst_5 : @algebra.{u v} R A _inst_1 _inst_4], @lie_algebra.{u v} R A _inst_1 (@ring.to_add_comm_group.{v} A _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An associative algebra gives rise to a Lie algebra by taking the bracket to be the ring commutator.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  lemma endo_algebra_bracket (M : Type v)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222    [add_comm_group M] [module R M] (f g : module.End R M) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='module.End'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 260, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223    ⁅f, g⁆ = f.comp g - g.comp f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@module.End.{u v} R M _inst_1 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@module.End.{u v} R M _inst_1 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@module.End.{u v} R M _inst_1 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β γ δ : Type v} {rα : ring.{u} α} {gβ : add_comm_group.{v} β} {gγ : add_comm_group.{v} γ} {gδ : add_comm_group.{v} δ} {mβ : @module.{u v} α β rα gβ} {mγ : @module.{u v} α γ rα gγ} {mδ : @module.{u v} α δ rα gδ}, @linear_map.{u v v} α γ δ rα gγ gδ mγ mδ → @linear_map.{u v v} α β γ rα gβ gγ mβ mγ → @linear_map.{u v v} α β δ rα gβ gδ mβ mδ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@module.End.{u v} R M _inst_1 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@module.End.{u v} R M _inst_1 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β γ δ : Type v} {rα : ring.{u} α} {gβ : add_comm_group.{v} β} {gγ : add_comm_group.{v} γ} {gδ : add_comm_group.{v} δ} {mβ : @module.{u v} α β rα gβ} {mγ : @module.{u v} α γ rα gγ} {mδ : @module.{u v} α δ rα gδ}, @linear_map.{u v v} α γ δ rα gγ gδ mγ mδ → @linear_map.{u v v} α β γ rα gβ gγ mβ mγ → @linear_map.{u v v} α β δ rα gβ gδ mβ mδ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@module.End.{u v} R M _inst_1 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  The adjoint action of a Lie algebra on itself.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  def Ad : L →ₗ⁅R⁆ module.End R L := {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='module.End'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 260, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    to_fun  := λ x, {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230      to_fun := has_bracket.bracket x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231      add    := by { intros, apply lie_add, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='lie_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y)) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z x) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x : L
⊢ ∀ (x_1 y : L),
    @eq.{v+1} L
      (@has_bracket.bracket.{v} L
         (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
         x
         (@has_add.add.{v} L
            (@add_semigroup.to_has_add.{v} L
               (@add_monoid.to_add_semigroup.{v} L
                  (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
            x_1
            y))
      (@has_add.add.{v} L
         (@add_semigroup.to_has_add.{v} L
            (@add_monoid.to_add_semigroup.{v} L
               (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            x
            x_1)
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x x_1 y : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          x_1
          y))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          x_1)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232      smul   := by { intros, apply lie_smul, } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='lie_algebra.lie_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [c : @lie_algebra.{u v} R L _inst_1 _inst_2] (t : R) (x y : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 c)) x (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@distrib_mul_action.to_mul_action.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@add_comm_monoid.to_add_monoid.{v} L (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 c))))) t y)) (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@distrib_mul_action.to_mul_action.{u v} R L (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))) (@add_comm_monoid.to_add_monoid.{v} L (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 c))))) t (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 c)) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x : L
⊢ ∀ (c : R) (x_1 : L),
    @eq.{v+1} L
      (@has_bracket.bracket.{v} L
         (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
         x
         (@has_scalar.smul.{u v} R L
            (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
               (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                  (@semimodule.to_distrib_mul_action.{u v} R L
                     (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                     (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
            c
            x_1))
      (@has_scalar.smul.{u v} R L
         (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
            (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
               (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
               (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                  (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
         c
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            x
            x_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x : L,
c : R,
x_1 : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x
       (@has_scalar.smul.{u v} R L
          (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                (@semimodule.to_distrib_mul_action.{u v} R L
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                   (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
          c
          x_1))
    (@has_scalar.smul.{u v} R L
       (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
          (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
             (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
       c
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          x_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233    add     := by { intros, ext, simp, },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2
⊢ ∀ (x y : L),
    @eq.{v+1} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
      (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            (@has_add.add.{v} L
               (@add_semigroup.to_has_add.{v} L
                  (@add_monoid.to_add_semigroup.{v} L
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
               x
               y))
         (λ (x_1 y_1 : L),
            @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y_1
              (@has_add.add.{v} L
                 (@add_semigroup.to_has_add.{v} L
                    (@add_monoid.to_add_semigroup.{v} L
                       (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
                 x
                 y))
         (λ (c : R) (x_1 : L),
            @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c
              (@has_add.add.{v} L
                 (@add_semigroup.to_has_add.{v} L
                    (@add_monoid.to_add_semigroup.{v} L
                       (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
                 x
                 y)
              x_1))
      (@has_add.add.{v}
         (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@add_semigroup.to_has_add.{v}
            (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@add_monoid.to_add_semigroup.{v}
               (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@add_group.to_add_monoid.{v}
                  (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@add_comm_group.to_add_group.{v}
                     (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))))
         (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x)
            (λ (x_1 y : L),
               @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
            (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
         (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               y)
            (λ (x_1 y_1 : L),
               @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y_1 y)
            (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c y x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y : L
⊢ @eq.{v+1} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             x
             y))
       (λ (x_1 y_1 : L),
          @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y_1
            (@has_add.add.{v} L
               (@add_semigroup.to_has_add.{v} L
                  (@add_monoid.to_add_semigroup.{v} L
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
               x
               y))
       (λ (c : R) (x_1 : L),
          @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c
            (@has_add.add.{v} L
               (@add_semigroup.to_has_add.{v} L
                  (@add_monoid.to_add_semigroup.{v} L
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
               x
               y)
            x_1))
    (@has_add.add.{v} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@add_semigroup.to_has_add.{v}
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@add_monoid.to_add_semigroup.{v}
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@add_group.to_add_monoid.{v}
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@add_comm_group.to_add_group.{v}
                   (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))))
       (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x)
          (λ (x_1 y : L), @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
          (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
       (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y)
          (λ (x_1 y_1 : L),
             @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y_1 y)
          (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c y x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y x_1 : L
⊢ @eq.{v+1} L
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             (@has_add.add.{v} L
                (@add_semigroup.to_has_add.{v} L
                   (@add_monoid.to_add_semigroup.{v} L
                      (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
                x
                y))
          (λ (x_1 y_1 : L),
             @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y_1
               (@has_add.add.{v} L
                  (@add_semigroup.to_has_add.{v} L
                     (@add_monoid.to_add_semigroup.{v} L
                        (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
                  x
                  y))
          (λ (c : R) (x_1 : L),
             @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c
               (@has_add.add.{v} L
                  (@add_semigroup.to_has_add.{v} L
                     (@add_monoid.to_add_semigroup.{v} L
                        (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
                  x
                  y)
               x_1))
       x_1)
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_add.add.{v}
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@add_semigroup.to_has_add.{v}
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@add_monoid.to_add_semigroup.{v}
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@add_group.to_add_monoid.{v}
                   (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@add_comm_group.to_add_group.{v}
                      (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))))
          (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
          (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                y)
             (λ (x_1 y_1 : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y_1 y)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c y x_1)))
       x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    smul    := by { intros, ext, simp, },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2
⊢ ∀ (c : R) (x : L),
    @eq.{v+1} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
      (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            (@has_scalar.smul.{u v} R L
               (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@distrib_mul_action.to_mul_action.{u v} R L
                     (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                     (@semimodule.to_distrib_mul_action.{u v} R L
                        (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                        (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
               c
               x))
         (λ (x_1 y : L),
            @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y
              (@has_scalar.smul.{u v} R L
                 (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                    (@distrib_mul_action.to_mul_action.{u v} R L
                       (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                       (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                       (@semimodule.to_distrib_mul_action.{u v} R L
                          (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                          (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                          (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
                 c
                 x))
         (λ (c_1 : R) (x_1 : L),
            @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c_1
              (@has_scalar.smul.{u v} R L
                 (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                    (@distrib_mul_action.to_mul_action.{u v} R L
                       (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                       (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                       (@semimodule.to_distrib_mul_action.{u v} R L
                          (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                          (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                          (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
                 c
                 x)
              x_1))
      (@has_scalar.smul.{u v} R
         (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@mul_action.to_has_scalar.{u v} R
            (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
            (@distrib_mul_action.to_mul_action.{u v} R
               (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
               (@add_group.to_add_monoid.{v}
                  (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@add_comm_group.to_add_group.{v}
                     (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
               (@semimodule.to_distrib_mul_action.{u v} R
                  (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@add_comm_group.to_add_comm_monoid.{v}
                     (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@module.to_semimodule.{u v} R
                     (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@comm_ring.to_ring.{u} R _inst_1)
                     (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_algebra.to_module.{u v} R
                        (@module.End.{u v} R L _inst_1 _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        _inst_1
                        (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))))
         c
         (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x)
            (λ (x_1 y : L),
               @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
            (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
c : R,
x : L
⊢ @eq.{v+1} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_scalar.smul.{u v} R L
             (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                   (@semimodule.to_distrib_mul_action.{u v} R L
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                      (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
             c
             x))
       (λ (x_1 y : L),
          @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y
            (@has_scalar.smul.{u v} R L
               (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@distrib_mul_action.to_mul_action.{u v} R L
                     (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                     (@semimodule.to_distrib_mul_action.{u v} R L
                        (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                        (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
               c
               x))
       (λ (c_1 : R) (x_1 : L),
          @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c_1
            (@has_scalar.smul.{u v} R L
               (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@distrib_mul_action.to_mul_action.{u v} R L
                     (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                     (@semimodule.to_distrib_mul_action.{u v} R L
                        (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                        (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
               c
               x)
            x_1))
    (@has_scalar.smul.{u v} R
       (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@mul_action.to_has_scalar.{u v} R
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@add_group.to_add_monoid.{v}
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@add_comm_group.to_add_group.{v}
                   (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@module.to_semimodule.{u v} R
                   (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_algebra.to_module.{u v} R
                      (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      _inst_1
                      (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))))
       c
       (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x)
          (λ (x_1 y : L), @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
          (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
c : R,
x x_1 : L
⊢ @eq.{v+1} L
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             (@has_scalar.smul.{u v} R L
                (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@distrib_mul_action.to_mul_action.{u v} R L
                      (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                      (@semimodule.to_distrib_mul_action.{u v} R L
                         (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                         (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                         (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
                c
                x))
          (λ (x_1 y : L),
             @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y
               (@has_scalar.smul.{u v} R L
                  (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@distrib_mul_action.to_mul_action.{u v} R L
                        (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                        (@semimodule.to_distrib_mul_action.{u v} R L
                           (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                           (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                           (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
                  c
                  x))
          (λ (c_1 : R) (x_1 : L),
             @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c_1
               (@has_scalar.smul.{u v} R L
                  (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@distrib_mul_action.to_mul_action.{u v} R L
                        (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                        (@semimodule.to_distrib_mul_action.{u v} R L
                           (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                           (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                           (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
                  c
                  x)
               x_1))
       x_1)
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_scalar.smul.{u v} R
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@mul_action.to_has_scalar.{u v} R
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v}
                   (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@add_comm_group.to_add_group.{v}
                      (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@module.to_semimodule.{u v} R
                      (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_algebra.to_module.{u v} R
                         (@module.End.{u v} R L _inst_1 _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         _inst_1
                         (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))))
          c
          (@linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1)))
       x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235    map_lie := by {</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2
⊢ ∀ {x y : L},
    @eq.{v+1} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
      ((λ (x : L),
          @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x)
            (λ (x_1 y : L),
               @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
            (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            x
            y))
      (@has_bracket.bracket.{v}
         (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@lie_ring.to_has_bracket.{v}
            (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@lie_algebra.to_lie_ring.{u v} R
               (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               _inst_1
               (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
         ((λ (x : L),
             @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  x)
               (λ (x_1 y : L),
                  @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
               (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
            x)
         ((λ (x : L),
             @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  x)
               (λ (x_1 y : L),
                  @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
               (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236      intros x y, ext z,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2
⊢ ∀ {x y : L},
    @eq.{v+1} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
      ((λ (x : L),
          @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x)
            (λ (x_1 y : L),
               @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
            (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            x
            y))
      (@has_bracket.bracket.{v}
         (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@lie_ring.to_has_bracket.{v}
            (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@lie_algebra.to_lie_ring.{u v} R
               (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               _inst_1
               (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
         ((λ (x : L),
             @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  x)
               (λ (x_1 y : L),
                  @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
               (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
            x)
         ((λ (x : L),
             @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  x)
               (λ (x_1 y : L),
                  @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
               (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y : L
⊢ @eq.{v+1} (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    ((λ (x : L),
        @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x)
          (λ (x_1 y : L), @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
          (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y))
    (@has_bracket.bracket.{v}
       (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@lie_ring.to_has_bracket.{v}
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_algebra.to_lie_ring.{u v} R
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             _inst_1
             (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
       ((λ (x : L),
           @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
          x)
       ((λ (x : L),
           @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       ((λ (x : L),
           @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y))
       z)
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_bracket.bracket.{v}
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_ring.to_has_bracket.{v}
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_algebra.to_lie_ring.{u v} R
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                _inst_1
                (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
          ((λ (x : L),
              @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   x)
                (λ (x_1 y : L),
                   @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
             x)
          ((λ (x : L),
              @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   x)
                (λ (x_1 y : L),
                   @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
             y))
       z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237      rw endo_algebra_bracket,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lie_algebra.endo_algebra_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 221, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : comm_ring.{u} R] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] (f g : @module.End.{u v} R M _inst_1 _inst_4 _inst_5), @eq.{v+1} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@has_bracket.bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@lie_ring.to_has_bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_lie_ring.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))) f g) (@has_sub.sub.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@add_group_has_sub.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@add_comm_group.to_add_group.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5))) (@linear_map.comp.{u v v v} R M M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_4 _inst_5 _inst_5 _inst_5 f g) (@linear_map.comp.{u v v v} R M M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_4 _inst_5 _inst_5 _inst_5 g f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       ((λ (x : L),
           @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y))
       z)
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_bracket.bracket.{v}
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_ring.to_has_bracket.{v}
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_algebra.to_lie_ring.{u v} R
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                _inst_1
                (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
          ((λ (x : L),
              @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   x)
                (λ (x_1 y : L),
                   @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
             x)
          ((λ (x : L),
              @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   x)
                (λ (x_1 y : L),
                   @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
             y))
       z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       ((λ (x : L),
           @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y))
       z)
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{v}
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@add_group_has_sub.{v}
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@add_comm_group.to_add_group.{v}
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
          (@linear_map.comp.{u v v v} R L L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                x)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                y))
          (@linear_map.comp.{u v v v} R L L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                y)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                x)))
       z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238      suffices : ⁅⁅x, y⁆, z⁆ = ⁅x, ⁅y, z⁆⁆ + ⁅⁅x, z⁆, y⁆, by simpa,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       ((λ (x : L),
           @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x)
             (λ (x_1 y : L),
                @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
             (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y))
       z)
    (@coe_fn.{v+1 v+1}
       (@linear_map.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@linear_map.has_coe_to_fun.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{v}
          (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@add_group_has_sub.{v}
             (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@add_comm_group.to_add_group.{v}
                (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))
          (@linear_map.comp.{u v v v} R L L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                x)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                y))
          (@linear_map.comp.{u v v v} R L L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2 _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                y)
             ((λ (x : L),
                 @linear_map.mk.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_bracket.bracket.{v} L
                      (@lie_ring.to_has_bracket.{v} L _inst_2
                         (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                      x)
                   (λ (x_1 y : L),
                      @lie_add.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3) x_1 y x)
                   (λ (c : R) (x_1 : L), @lie_algebra.lie_smul.{u v} R L _inst_1 _inst_2 _inst_3 c x x_1))
                x)))
       z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y)
       z)
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             z)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239      rw [eq_comm, ←lie_skew ⁅x, y⁆ z, ←lie_skew ⁅x, z⁆ y, ←lie_skew x z, lie_neg, neg_neg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a b : α}, iff (@eq.{v+1} α a b) (@eq.{v+1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) y)) (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] (a : α), @eq.{v+1} α (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α _inst_1) (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α _inst_1) a)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y)
       z)
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             z)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             z)
          y))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y)
       z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             z)
          y))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x
                z))))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   z
                   x)))))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
          (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                y
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   z
                   x)))))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             x)))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240          ←sub_eq_zero_iff_eq, sub_neg_eq_add, lie_ring.jacobi], } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sub_eq_zero_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_neg_eq_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_ring.jacobi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] {a b : α}, iff (@eq.{v+1} α (@has_sub.sub.{v} α (@add_group_has_sub.{v} α _inst_1) a b) (@has_zero.zero.{v} α (@add_monoid.to_has_zero.{v} α (@add_group.to_add_monoid.{v} α _inst_1)))) (@eq.{v+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] (a b : α), @eq.{v+1} α (@has_sub.sub.{v} α (@add_group_has_sub.{v} α _inst_1) a (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α _inst_1) b)) (@has_add.add.{v} α (@add_semigroup.to_has_add.{v} α (@add_monoid.to_add_semigroup.{v} α (@add_group.to_add_monoid.{v} α _inst_1))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [c : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) y z)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) y (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z x))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x y))) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             x)))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                y
                z))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                z
                x)))
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x
                y))))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                y
                z))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                z
                x)))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  end lie_algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  section lie_subalgebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  variables (R : Type u) (L : Type v) [comm_ring R] [add_comm_group L] [lie_algebra R L]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='comm_ring.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='add_comm_group.{v} L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@lie_algebra.{u v} R L _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  This is a sufficient condition for the subset itself to form a Lie algebra.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  structure lie_subalgebra extends submodule R L :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  (lie_mem : ∀ {x y}, x ∈ carrier → y ∈ carrier → ⁅x, y⁆ ∈ carrier)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='lie_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='carrier'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='carrier'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='carrier'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {x y : L}, @has_mem.mem.{v v} L (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) to_submodule) (@set.has_mem.{v} L) x carrier → @has_mem.mem.{v v} L (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) to_submodule) (@set.has_mem.{v} L) y carrier → @has_mem.mem.{v v} L (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) to_submodule) (@set.has_mem.{v} L) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y) carrier'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  instance lie_subalgebra_coe_submodule : has_coe (lie_subalgebra R L) (submodule R L) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='has_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_subalgebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 252, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Sort u → Sort v → Sort (max 1 (imax u v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie algebra.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  ⟨lie_subalgebra.to_submodule⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_subalgebra.to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 252, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3 → @submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  /-- A Lie subalgebra forms a new Lie algebra.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  This cannot be an instance, since being a Lie subalgebra is (currently) not a class. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  def lie_subalgebra_lie_algebra (L&#x27; : lie_subalgebra R L) : lie_algebra R L&#x27; := {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='lie_subalgebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 252, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie algebra.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261    bracket  := λ x y, ⟨⁅x.val, y.val⁆, L&#x27;.lie_mem x.property y.property⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_subalgebra.lie_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 252, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))) (@set.has_coe_to_sort.{v} L))) L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))) (@set.has_coe_to_sort.{v} L))) L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))) (@set.has_coe_to_sort.{v} L))) L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))) (@set.has_coe_to_sort.{v} L))) L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (c : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) {x y : L}, @has_mem.mem.{v v} L (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_subalgebra.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 c)) (@set.has_mem.{v} L) x (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_subalgebra.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 c)) → @has_mem.mem.{v v} L (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_subalgebra.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 c)) (@set.has_mem.{v} L) y (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_subalgebra.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 c)) → @has_mem.mem.{v v} L (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_subalgebra.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 c)) (@set.has_mem.{v} L) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y) (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_subalgebra.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))) (@set.has_coe_to_sort.{v} L))) L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {p : α → Prop} (c : @subtype.{v+1} α p), p (@subtype.val.{v+1} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (set.{v} L) (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))) (@set.has_coe_to_sort.{v} L))) L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {p : α → Prop} (c : @subtype.{v+1} α p), p (@subtype.val.{v+1} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262    lie_add  := by { intros, apply set_coe.ext, apply lie_add, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y)) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z x) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x y z :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (set.{v} L)
            (@coe_base_aux.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
            (@set.has_coe_to_sort.{v} L)))
      L&#x27;),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
               (@set.has_coe_to_sort.{v} L)))
         L&#x27;)
      (@has_bracket.bracket.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@has_bracket.mk.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (λ
             (x y :
               @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@set.has_coe_to_sort.{v} L)))
                 L&#x27;),
               @subtype.mk.{v+1} L
                 (λ (x : L),
                    @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                      (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;)))
                 (@has_bracket.bracket.{v} L
                    (@lie_ring.to_has_bracket.{v} L _inst_2
                       (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))
                 (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))))
         z
         (@has_add.add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@add_semigroup.to_has_add.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@add_monoid.to_add_semigroup.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@add_group.to_add_monoid.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@add_comm_group.to_add_group.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (set.{v} L)
                                    (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                 (@set.has_coe_to_sort.{v} L)))
                           L&#x27;)
                        (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              L&#x27;))))))
            x
            y))
      (@has_add.add.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@add_semigroup.to_has_add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@add_monoid.to_add_semigroup.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@add_group.to_add_monoid.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@add_comm_group.to_add_group.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
         (@has_bracket.bracket.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@has_bracket.mk.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) … L&#x27;)
               …)
            z
            x)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x y z :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@set.has_coe_to_sort.{v} L)))
       L&#x27;)
    (@has_bracket.bracket.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@has_bracket.mk.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (λ
           (x y :
             @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;),
             @subtype.mk.{v+1} L
               (λ (x : L),
                  @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                          L&#x27;)))
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))
               (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))))
       z
       (@has_add.add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_semigroup.to_has_add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_monoid.to_add_semigroup.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_group.to_add_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_comm_group.to_add_group.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;))))))
          x
          y))
    (@has_add.add.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@add_semigroup.to_has_add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_monoid.to_add_semigroup.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_group.to_add_monoid.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_comm_group.to_add_group.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         L&#x27;))))))
       (@has_bracket.bracket.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@has_bracket.mk.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (λ (x y : @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) … L&#x27;),
                …))
          z
          x)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x y z :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1} L
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_bracket.bracket.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@has_bracket.mk.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (λ
              (x y :
                @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;),
                @subtype.mk.{v+1} L
                  (λ (x : L),
                     @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                          (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                             L&#x27;)))
                  (@has_bracket.bracket.{v} L
                     (@lie_ring.to_has_bracket.{v} L _inst_2
                        (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))
                  (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))))
          z
          (@has_add.add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_semigroup.to_has_add.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_monoid.to_add_semigroup.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_group.to_add_monoid.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@add_comm_group.to_add_group.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                  (@set.has_coe_to_sort.{v} L)))
                            L&#x27;)
                         (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               L&#x27;))))))
             x
             y)))
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_add.add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      …
                      …)
                   …))
             L&#x27;)
          …
          …
          …))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    add_lie  := by { intros, apply set_coe.ext, apply add_lie, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='add_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y) z) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x z) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x y z :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (set.{v} L)
            (@coe_base_aux.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
            (@set.has_coe_to_sort.{v} L)))
      L&#x27;),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
               (@set.has_coe_to_sort.{v} L)))
         L&#x27;)
      (@has_bracket.bracket.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@has_bracket.mk.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (λ
             (x y :
               @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@set.has_coe_to_sort.{v} L)))
                 L&#x27;),
               @subtype.mk.{v+1} L
                 (λ (x : L),
                    @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                      (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;)))
                 (@has_bracket.bracket.{v} L
                    (@lie_ring.to_has_bracket.{v} L _inst_2
                       (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))
                 (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))))
         (@has_add.add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@add_semigroup.to_has_add.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@add_monoid.to_add_semigroup.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@add_group.to_add_monoid.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@add_comm_group.to_add_group.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (set.{v} L)
                                    (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                 (@set.has_coe_to_sort.{v} L)))
                           L&#x27;)
                        (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              L&#x27;))))))
            x
            y)
         z)
      (@has_add.add.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@add_semigroup.to_has_add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@add_monoid.to_add_semigroup.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@add_group.to_add_monoid.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@add_comm_group.to_add_group.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
         (@has_bracket.bracket.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@has_bracket.mk.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) … L&#x27;)
               …)
            x
            z)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x y z :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@set.has_coe_to_sort.{v} L)))
       L&#x27;)
    (@has_bracket.bracket.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@has_bracket.mk.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (λ
           (x y :
             @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;),
             @subtype.mk.{v+1} L
               (λ (x : L),
                  @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                          L&#x27;)))
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))
               (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))))
       (@has_add.add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_semigroup.to_has_add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_monoid.to_add_semigroup.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_group.to_add_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_comm_group.to_add_group.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;))))))
          x
          y)
       z)
    (@has_add.add.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@add_semigroup.to_has_add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_monoid.to_add_semigroup.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_group.to_add_monoid.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_comm_group.to_add_group.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         L&#x27;))))))
       (@has_bracket.bracket.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@has_bracket.mk.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (λ (x y : @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) … L&#x27;),
                …))
          x
          z)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x y z :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1} L
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_bracket.bracket.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@has_bracket.mk.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (λ
              (x y :
                @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;),
                @subtype.mk.{v+1} L
                  (λ (x : L),
                     @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                          (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                             L&#x27;)))
                  (@has_bracket.bracket.{v} L
                     (@lie_ring.to_has_bracket.{v} L _inst_2
                        (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))
                  (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))))
          (@has_add.add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_semigroup.to_has_add.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_monoid.to_add_semigroup.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_group.to_add_monoid.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@add_comm_group.to_add_group.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                  (@set.has_coe_to_sort.{v} L)))
                            L&#x27;)
                         (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               L&#x27;))))))
             x
             y)
          z))
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_add.add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      …
                      …)
                   …))
             L&#x27;)
          …
          …
          …))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    lie_self := by { intros, apply set_coe.ext, apply lie_self, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 107, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x x) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (set.{v} L)
            (@coe_base_aux.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
            (@set.has_coe_to_sort.{v} L)))
      L&#x27;),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
               (@set.has_coe_to_sort.{v} L)))
         L&#x27;)
      (@has_bracket.bracket.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@has_bracket.mk.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (λ
             (x y :
               @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@set.has_coe_to_sort.{v} L)))
                 L&#x27;),
               @subtype.mk.{v+1} L
                 (λ (x : L),
                    @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                      (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;)))
                 (@has_bracket.bracket.{v} L
                    (@lie_ring.to_has_bracket.{v} L _inst_2
                       (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))
                 (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))))
         x
         x)
      (@has_zero.zero.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@add_monoid.to_has_zero.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@add_group.to_add_monoid.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@add_comm_group.to_add_group.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        L&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@set.has_coe_to_sort.{v} L)))
       L&#x27;)
    (@has_bracket.bracket.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@has_bracket.mk.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (λ
           (x y :
             @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;),
             @subtype.mk.{v+1} L
               (λ (x : L),
                  @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                          L&#x27;)))
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))
               (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))))
       x
       x)
    (@has_zero.zero.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@add_monoid.to_has_zero.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_group.to_add_monoid.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_comm_group.to_add_group.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1} L
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_bracket.bracket.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@has_bracket.mk.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (λ
              (x y :
                @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;),
                @subtype.mk.{v+1} L
                  (λ (x : L),
                     @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                          (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                             L&#x27;)))
                  (@has_bracket.bracket.{v} L
                     (@lie_ring.to_has_bracket.{v} L _inst_2
                        (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))
                  (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))))
          x
          x))
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_zero.zero.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_monoid.to_has_zero.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_group.to_add_monoid.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_comm_group.to_add_group.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         L&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265    jacobi   := by { intros, apply set_coe.ext, apply lie_ring.jacobi, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_ring.jacobi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [c : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) y z)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) y (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z x))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x y))) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x y z :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (set.{v} L)
            (@coe_base_aux.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
            (@set.has_coe_to_sort.{v} L)))
      L&#x27;),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
               (@set.has_coe_to_sort.{v} L)))
         L&#x27;)
      (@has_add.add.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@add_semigroup.to_has_add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@add_monoid.to_add_semigroup.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@add_group.to_add_monoid.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@add_comm_group.to_add_group.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
         (@has_add.add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@add_semigroup.to_has_add.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@add_monoid.to_add_semigroup.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@add_group.to_add_monoid.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@add_comm_group.to_add_group.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (set.{v} L)
                                    (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                 (@set.has_coe_to_sort.{v} L)))
                           L&#x27;)
                        (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              L&#x27;))))))
            (@has_bracket.bracket.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@has_bracket.mk.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (λ
                   (x y :
                     @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@set.has_coe_to_sort.{v} L)))
                       L&#x27;),
                     @subtype.mk.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       (@has_bracket.bracket.{v} L
                          (@lie_ring.to_has_bracket.{v} L _inst_2
                             (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                          (@subtype.val.{v+1} L
                             (λ (x : L),
                                @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (set.{v} L)
                                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                     (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                        L&#x27;)))
                             x)
                          (@subtype.val.{v+1} L
                             (λ (x : L),
                                @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (set.{v} L)
                                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                     (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                        L&#x27;)))
                             y))
                       (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                          (@subtype.val.{v+1} L
                             (λ (x : L),
                                @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (set.{v} L)
                                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                     (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                        L&#x27;)))
                             x)
                          (@subtype.val.{v+1} L
                             (λ (x : L),
                                @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (set.{v} L)
                                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                     (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                        L&#x27;)))
                             y)
                          (@subtype.property.{v+1} L
                             (λ (x : L),
                                @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (set.{v} L)
                                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                     (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                        L&#x27;)))
                             x)
                          (@subtype.property.{v+1} L
                             (λ (x : L),
                                @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (set.{v} L)
                                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                     (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                        L&#x27;)))
                             y))))
               x
               (@has_bracket.bracket.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@has_bracket.mk.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) … L&#x27;)
                     …)
                  y
                  z))
            …)
         …)
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x y z :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@set.has_coe_to_sort.{v} L)))
       L&#x27;)
    (@has_add.add.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@add_semigroup.to_has_add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_monoid.to_add_semigroup.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_group.to_add_monoid.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_comm_group.to_add_group.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         L&#x27;))))))
       (@has_add.add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_semigroup.to_has_add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_monoid.to_add_semigroup.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_group.to_add_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_comm_group.to_add_group.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;))))))
          (@has_bracket.bracket.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@has_bracket.mk.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (λ
                 (x y :
                   @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;),
                   @subtype.mk.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     (@has_bracket.bracket.{v} L
                        (@lie_ring.to_has_bracket.{v} L _inst_2
                           (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@subtype.val.{v+1} L
                           (λ (x : L),
                              @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                      L&#x27;)))
                           x)
                        (@subtype.val.{v+1} L
                           (λ (x : L),
                              @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                      L&#x27;)))
                           y))
                     (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                        (@subtype.val.{v+1} L
                           (λ (x : L),
                              @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                      L&#x27;)))
                           x)
                        (@subtype.val.{v+1} L
                           (λ (x : L),
                              @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                      L&#x27;)))
                           y)
                        (@subtype.property.{v+1} L
                           (λ (x : L),
                              @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                      L&#x27;)))
                           x)
                        (@subtype.property.{v+1} L
                           (λ (x : L),
                              @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                      L&#x27;)))
                           y))))
             x
             (@has_bracket.bracket.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@has_bracket.mk.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (λ
                    (x y : @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3) … L&#x27;),
                      …))
                y
                z))
          …)
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
x y z :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1} L
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_add.add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@add_semigroup.to_has_add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_monoid.to_add_semigroup.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_group.to_add_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_comm_group.to_add_group.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;))))))
          (@has_add.add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@add_semigroup.to_has_add.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@add_monoid.to_add_semigroup.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_group.to_add_monoid.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@add_comm_group.to_add_group.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                  (@set.has_coe_to_sort.{v} L)))
                            L&#x27;)
                         (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               L&#x27;))))))
             (@has_bracket.bracket.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@has_bracket.mk.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (λ
                    (x y :
                      @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;),
                      @subtype.mk.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        (@has_bracket.bracket.{v} L
                           (@lie_ring.to_has_bracket.{v} L _inst_2
                              (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@subtype.val.{v+1} L
                              (λ (x : L),
                                 @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                   (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (set.{v} L)
                                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                         L&#x27;)))
                              x)
                           (@subtype.val.{v+1} L
                              (λ (x : L),
                                 @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                   (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (set.{v} L)
                                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                         L&#x27;)))
                              y))
                        (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                           (@subtype.val.{v+1} L
                              (λ (x : L),
                                 @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                   (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (set.{v} L)
                                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                         L&#x27;)))
                              x)
                           (@subtype.val.{v+1} L
                              (λ (x : L),
                                 @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                   (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (set.{v} L)
                                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                         L&#x27;)))
                              y)
                           (@subtype.property.{v+1} L
                              (λ (x : L),
                                 @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                   (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (set.{v} L)
                                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (set.{v} L)
                                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                      (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                         L&#x27;)))
                              x)
                           (@subtype.property.{v+1} L
                              (λ (x : L),
                                 @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                                   (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)} (@submodule.{u v} R L … _inst_2 …) …
                                      …
                                      …))
                              y))))
                x
                …)
             …)
          …))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266    lie_smul := by { intros, apply set_coe.ext, apply lie_smul, } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 173, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (t : R) (x y : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))) t y)) (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))) t (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀ (t : R)
  (x y :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (set.{v} L)
            (@coe_base_aux.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
            (@set.has_coe_to_sort.{v} L)))
      L&#x27;),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (set.{v} L)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
               (@set.has_coe_to_sort.{v} L)))
         L&#x27;)
      (@has_bracket.bracket.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (set.{v} L)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                  (@set.has_coe_to_sort.{v} L)))
            L&#x27;)
         (@has_bracket.mk.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (λ
             (x y :
               @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@set.has_coe_to_sort.{v} L)))
                 L&#x27;),
               @subtype.mk.{v+1} L
                 (λ (x : L),
                    @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                      (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;)))
                 (@has_bracket.bracket.{v} L
                    (@lie_ring.to_has_bracket.{v} L _inst_2
                       (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))
                 (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.val.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       x)
                    (@subtype.property.{v+1} L
                       (λ (x : L),
                          @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;)))
                       y))))
         x
         (@has_scalar.smul.{u v} R
            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;)
            (@mul_action.to_has_scalar.{u v} R
               (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;)
               (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
               (@distrib_mul_action.to_mul_action.{u v} R
                  (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                           (@set.has_coe_to_sort.{v} L)))
                     L&#x27;)
                  (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                  (@add_comm_monoid.to_add_monoid.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@add_comm_group.to_add_comm_monoid.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (set.{v} L)
                                    (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                 (@set.has_coe_to_sort.{v} L)))
                           L&#x27;)
                        (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              L&#x27;))))
                  (@semimodule.to_distrib_mul_action.{u v} R
                     (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (set.{v} L)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                              (@set.has_coe_to_sort.{v} L)))
                        L&#x27;)
                     (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_comm_group.to_add_comm_monoid.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (set.{v} L)
                                    (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                 (@set.has_coe_to_sort.{v} L)))
                           L&#x27;)
                        (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              L&#x27;)))
                     (@module.to_semimodule.{u v} R
                        (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (set.{v} L)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (set.{v} L)
                                    (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                 (@set.has_coe_to_sort.{v} L)))
                           L&#x27;)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                              L&#x27;))
                        (@module.mk.{u v} R
                           (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (set.{v} L)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                       (set.{v} L)
                                       (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                    (@set.has_coe_to_sort.{v} L)))
                              L&#x27;)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                 (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                 L&#x27;))
                           (@module.to_semimodule.{u v} R
                              (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                       (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R L … _inst_2 …)
                                       …
                                       …
                                       …))
                                 L&#x27;)
                              …
                              …
                              …))))))
            t
            y))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x y :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@set.has_coe_to_sort.{v} L)))
       L&#x27;)
    (@has_bracket.bracket.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@set.has_coe_to_sort.{v} L)))
          L&#x27;)
       (@has_bracket.mk.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (λ
           (x y :
             @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (set.{v} L)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                     (@set.has_coe_to_sort.{v} L)))
               L&#x27;),
             @subtype.mk.{v+1} L
               (λ (x : L),
                  @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                       (set.{v} L)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                       (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                          L&#x27;)))
               (@has_bracket.bracket.{v} L
                  (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))
               (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.val.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     x)
                  (@subtype.property.{v+1} L
                     (λ (x : L),
                        @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                L&#x27;)))
                     y))))
       x
       (@has_scalar.smul.{u v} R
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@mul_action.to_has_scalar.{u v} R
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;)))
                   (@module.to_semimodule.{u v} R
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            L&#x27;))
                      (@module.mk.{u v} R
                         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                  (@set.has_coe_to_sort.{v} L)))
                            L&#x27;)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               L&#x27;))
                         (@module.to_semimodule.{u v} R
                            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                        (set.{v} L)
                                        (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                     (@set.has_coe_to_sort.{v} L)))
                               L&#x27;)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                  L&#x27;))
                            …))))))
          t
          y))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
L&#x27; : @lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x y :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
          (set.{v} L)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
          (@set.has_coe_to_sort.{v} L)))
    L&#x27;
⊢ @eq.{v+1} L
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
             (set.{v} L)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                L&#x27;)))
       L
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (set.{v} L)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   L&#x27;)))
          L
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} L) (@set.has_coe_to_sort.{v} L)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      L&#x27;)))
             L
             (@coe_subtype.{v+1} L
                (λ (x : L),
                   @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                              (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                           L&#x27;))))))
       (@has_bracket.bracket.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (set.{v} L)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                   (@set.has_coe_to_sort.{v} L)))
             L&#x27;)
          (@has_bracket.mk.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (λ
              (x y :
                @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                        (set.{v} L)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                           (set.{v} L)
                           (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                        (@set.has_coe_to_sort.{v} L)))
                  L&#x27;),
                @subtype.mk.{v+1} L
                  (λ (x : L),
                     @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                          (set.{v} L)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (set.{v} L)
                             (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                          (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                             (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                             (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                             L&#x27;)))
                  (@has_bracket.bracket.{v} L
                     (@lie_ring.to_has_bracket.{v} L _inst_2
                        (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))
                  (@lie_subalgebra.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 L&#x27;
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.val.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        x)
                     (@subtype.property.{v+1} L
                        (λ (x : L),
                           @has_mem.mem.{v v} L (set.{v} L) (@set.has_mem.{v} L) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                (set.{v} L)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (set.{v} L)
                                   (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                                   L&#x27;)))
                        y))))
          x
          (@has_scalar.smul.{u v} R
             (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (set.{v} L)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                      (@set.has_coe_to_sort.{v} L)))
                L&#x27;)
             (@mul_action.to_has_scalar.{u v} R
                (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (set.{v} L)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                         (@set.has_coe_to_sort.{v} L)))
                   L&#x27;)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@distrib_mul_action.to_mul_action.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (set.{v} L)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                            (@set.has_coe_to_sort.{v} L)))
                      L&#x27;)
                   (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                   (@add_comm_monoid.to_add_monoid.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@add_comm_group.to_add_comm_monoid.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                  (@set.has_coe_to_sort.{v} L)))
                            L&#x27;)
                         (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               L&#x27;))))
                   (@semimodule.to_distrib_mul_action.{u v} R
                      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (set.{v} L)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                               (@set.has_coe_to_sort.{v} L)))
                         L&#x27;)
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                  (@set.has_coe_to_sort.{v} L)))
                            L&#x27;)
                         (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               L&#x27;)))
                      (@module.to_semimodule.{u v} R
                         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (set.{v} L)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                     (set.{v} L)
                                     (@submodule.has_coe.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))
                                  (@set.has_coe_to_sort.{v} L)))
                            L&#x27;)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@has_coe_t_aux.coe.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                               (@coe_base_aux.{v+1 v+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  (@lie_subalgebra_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3))
                               L&#x27;))
                         (@module.mk.{u v} R
                            (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_subalgebra.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
                                  …
                                  …)
                               L&#x27;)
                            …
                            …
                            …)))))
             t
             y)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  end lie_subalgebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  section lie_module</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  variables (R : Type u) (L : Type v) [comm_ring R] [add_comm_group L] [lie_algebra R L]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='comm_ring.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='add_comm_group.{v} L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@lie_algebra.{u v} R L _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  variables (M  : Type v) [add_comm_group M] [module R M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='add_comm_group.{v} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  section prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  set_option default_priority 100 -- see Note [default priority]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='default priority for attributes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  on this module, such that the Lie bracket acts as the commutator of endomorphisms.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  class lie_module extends linear_action R L M :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='linear_action'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (R : Type u) (M N : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A binary operation representing one module acting linearly on another.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  (lie_act : ∀ (l l&#x27; : L) (m : M), act ⁅l, l&#x27;⁆ m = act l (act l&#x27; m) - act l&#x27; (act l m))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='lie_act'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ (l l&#x27; : L) (m : M), @eq.{v+1} M (act (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) l l&#x27;) m) (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4)) (act l (act l&#x27; m)) (act l&#x27; (act l m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@(λ {R : Type u} {M N : Type v} {_inst_1 : comm_ring.{u} R} {_inst_2 : add_comm_group.{v} M} {_inst_3 : add_comm_group.{v} N} {_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2} {_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3} (c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), M → N → N) R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 to_linear_action'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {R : Type u} {M N : Type v} {_inst_1 : comm_ring.{u} R} {_inst_2 : add_comm_group.{v} M} {_inst_3 : add_comm_group.{v} N} {_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2} {_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3} (c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), M → N → N) R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 to_linear_action'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@(λ {R : Type u} {M N : Type v} {_inst_1 : comm_ring.{u} R} {_inst_2 : add_comm_group.{v} M} {_inst_3 : add_comm_group.{v} N} {_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2} {_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3} (c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), M → N → N) R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 to_linear_action'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {R : Type u} {M N : Type v} {_inst_1 : comm_ring.{u} R} {_inst_2 : add_comm_group.{v} M} {_inst_3 : add_comm_group.{v} N} {_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2} {_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3} (c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), M → N → N) R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 to_linear_action'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@(λ {R : Type u} {M N : Type v} {_inst_1 : comm_ring.{u} R} {_inst_2 : add_comm_group.{v} M} {_inst_3 : add_comm_group.{v} N} {_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2} {_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3} (c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5), M → N → N) R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 to_linear_action'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  end prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  @[simp] lemma lie_act [lie_module R L M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    (l l&#x27; : L) (m : M) : linear_action.act R ⁅l, l&#x27;⁆ m =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287                         linear_action.act R l (linear_action.act R l&#x27; m) -</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288                         linear_action.act R l&#x27; (linear_action.act R l m) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289    lie_module.lie_act R l l&#x27; m</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_module.lie_act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (R : Type u) {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [c : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] (l l&#x27; : L) (m : M), @eq.{v+1} M (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) l l&#x27;) m) (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4)) (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l&#x27; m)) (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l&#x27; (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  protected lemma of_endo_map_action (α : L →ₗ⁅R⁆ module.End R M) (x : L) (m : M) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='module.End'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 260, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    @linear_action.act R _ _ _ _ _ _ _ (linear_action.of_endo_map R L M α) x m = α x m := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='linear_action.of_endo_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π (R : Type u) (M N : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3], @linear_map.{u v v} R M (@module.End.{u v} R N _inst_1 _inst_3 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R N N (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_3 _inst_5 _inst_5) _inst_4 (@linear_map.module.{u v v} R N N _inst_1 _inst_3 _inst_3 _inst_5 _inst_5) → @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='A linear map to the endomorphism algebra yields a linear action.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  A Lie morphism from a Lie algebra to the endomorphism algebra of a module yields</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  a Lie module structure.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  def lie_module.of_endo_morphism (α : L →ₗ⁅R⁆ module.End R M) : lie_module R L M := {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_algebra.morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='module.End'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 260, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (L L&#x27; : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A morphism of Lie algebras is a linear map respecting the bracket operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299    lie_act := by { intros x y m, rw [of_endo_map_action, lie_algebra.map_lie,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='of_endo_map_action'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_algebra.map_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 291, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] (α : @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)) (x : L) (m : M), @eq.{v+1} M (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@coe.{v+1 v+1} (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)) (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5)) (@coe_to_lift.{v+1 v+1} (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)) (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5)) (@coe_base.{v+1 v+1} (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)) (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5)) (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))) α)) x m) (@coe_fn.{v+1 v+1} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@coe_fn.{v+1 v+1} (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)) (@coe_fn_trans.{v+1 v+1 v+1} (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)) (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))) (@coe_base_aux.{v+1 v+1} (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)) (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))) (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))) (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))) α x) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L L&#x27; : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} L&#x27;] [_inst_5 : @lie_algebra.{u v} R L&#x27; _inst_1 _inst_4] (f : @lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (x y : L), @eq.{v+1} L&#x27; (@coe_fn.{v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@coe_fn_trans.{v+1 v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@coe_base_aux.{v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@lie_algebra.has_coe.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (@linear_map.has_coe_to_fun.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5))) f (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} L&#x27; (@lie_ring.to_has_bracket.{v} L&#x27; _inst_4 (@lie_algebra.to_lie_ring.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@coe_fn.{v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@coe_fn_trans.{v+1 v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@coe_base_aux.{v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@lie_algebra.has_coe.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (@linear_map.has_coe_to_fun.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5))) f x) (@coe_fn.{v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@coe_fn_trans.{v+1 v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@coe_base_aux.{v+1 v+1} (@lie_algebra.morphism.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5)) (@lie_algebra.has_coe.{u v} R L L&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5)) (@linear_map.has_coe_to_fun.{u v v} R L L&#x27; (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L&#x27; _inst_1 _inst_4 _inst_5))) f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
α :
  @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
    (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
    (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)
⊢ ∀ (l l&#x27; : L) (m : M),
    @eq.{v+1} M
      (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         _inst_5
         (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            _inst_5
            (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@coe.{v+1 v+1}
                     (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                        _inst_3
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                     (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        _inst_2
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                     (@coe_to_lift.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_base.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                     α)))
            (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@coe.{v+1 v+1}
                     (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                        _inst_3
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                     (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        _inst_2
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                     (@coe_to_lift.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_base.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                     α)))
            (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@coe.{v+1 v+1}
                     (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                        _inst_3
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                     (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        _inst_2
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                     (@coe_to_lift.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_base.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                     α)))
            (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@coe.{v+1 v+1}
                     (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                        _inst_3
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                     (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        _inst_2
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                     (@coe_to_lift.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_base.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                     α)))
            (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@coe.{v+1 v+1}
                     (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                        _inst_3
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                     (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        _inst_2
                        (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                           _inst_5
                           _inst_5)
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                     (@coe_to_lift.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_base.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                     α))))
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            l
            l&#x27;)
         m)
      (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4))
         (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            _inst_5
            (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     _inst_5
                     (@coe.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_to_lift.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@coe_base.{v+1 v+1}
                              (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                              (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                 (@comm_ring.to_ring.{u} R _inst_1)
                                 _inst_2
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                              (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                        α)))
               (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     _inst_5
                     (@coe.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_to_lift.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@coe_base.{v+1 v+1}
                              (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                              (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                 (@comm_ring.to_ring.{u} R _inst_1)
                                 _inst_2
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                              (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                        α)))
               (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     _inst_5
                     (@coe.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_to_lift.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@coe_base.{v+1 v+1}
                              (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                              (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                 (@comm_ring.to_ring.{u} R _inst_1)
                                 _inst_2
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                              (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                        α)))
               (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     _inst_5
                     (@coe.{v+1 v+1}
                        (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                           _inst_3
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                        (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           _inst_2
                           (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                              _inst_5
                              _inst_5)
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                        (@coe_to_lift.{v+1 v+1}
                           (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                              _inst_2
                              _inst_3
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                           (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              _inst_2
                              (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                 _inst_4
                                 _inst_5
                                 _inst_5)
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                           (@coe_base.{v+1 v+1}
                              (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                              (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                 (@comm_ring.to_ring.{u} R _inst_1)
                                 _inst_2
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                              (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                 _inst_2
                                 _inst_3
                                 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                    _inst_4
                                    _inst_5
                                    _inst_5)
                                 (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                        α)))
               (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     _inst_5
                     (@coe.{v+1 v+1} (… … _inst_1 _inst_2 _inst_3 … …) … … α))))
            l
            …)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
α :
  @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
    (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
    (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5),
x y : L,
m : M
⊢ @eq.{v+1} M
    (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       _inst_5
       (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@coe.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                   (@coe_to_lift.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_base.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                   α)))
          (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@coe.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                   (@coe_to_lift.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_base.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                   α)))
          (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@coe.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                   (@coe_to_lift.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_base.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                   α)))
          (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@coe.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                   (@coe_to_lift.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_base.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                   α)))
          (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@coe.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                   (@coe_to_lift.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_base.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                   α))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y)
       m)
    (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1} (@lie_algebra.morphism.{u v} R L … _inst_1 _inst_2 _inst_3 … …) … … α))))
          x
          …)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
α :
  @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
    (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
    (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5),
x y : L,
m : M
⊢ @eq.{v+1} M
    (@coe_fn.{v+1 v+1} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
       (@linear_map.has_coe_to_fun.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
       (@coe_fn.{v+1 v+1}
          (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
             (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                _inst_5)
             (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
          (@coe_fn_trans.{v+1 v+1 v+1}
             (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
             (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@comm_ring.to_ring.{u} R _inst_1)
                _inst_2
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
             (@coe_base_aux.{v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
             (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                (@comm_ring.to_ring.{u} R _inst_1)
                _inst_2
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
          α
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y))
       m)
    (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α))))
          x
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@coe.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_to_lift.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@coe_base.{v+1 v+1}
                               (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                               (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                  (@comm_ring.to_ring.{u} R _inst_1)
                                  _inst_2
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                               (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                         α)))
                (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@coe.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_to_lift.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@coe_base.{v+1 v+1}
                               (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                               (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                  (@comm_ring.to_ring.{u} R _inst_1)
                                  _inst_2
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                               (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                         α)))
                (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@coe.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_to_lift.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@coe_base.{v+1 v+1}
                               (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                               (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                  (@comm_ring.to_ring.{u} R _inst_1)
                                  _inst_2
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                               (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  …)))
                         α)))
                …
                …)
             y
             m))
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
α :
  @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
    (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
    (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5),
x y : L,
m : M
⊢ @eq.{v+1} M
    (@coe_fn.{v+1 v+1} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
       (@linear_map.has_coe_to_fun.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
       (@has_bracket.bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
          (@lie_ring.to_has_bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
             (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                _inst_5)
             (@lie_algebra.to_lie_ring.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
          (@coe_fn.{v+1 v+1}
             (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
             (@coe_fn_trans.{v+1 v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@coe_base_aux.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
             α
             x)
          (@coe_fn.{v+1 v+1}
             (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
             (@coe_fn_trans.{v+1 v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@coe_base_aux.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
             α
             y))
       m)
    (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α))))
          x
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@coe.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_to_lift.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@coe_base.{v+1 v+1}
                               (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                               (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                  (@comm_ring.to_ring.{u} R _inst_1)
                                  _inst_2
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                               (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                         α)))
                (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@coe.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_to_lift.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@coe_base.{v+1 v+1}
                               (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (… _inst_1 M _inst_4 _inst_5))
                               …
                               …))
                         α)))
                …
                …
                …)
             y
             m))
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300                                      lie_algebra.endo_algebra_bracket], refl, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='lie_algebra.endo_algebra_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 221, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : comm_ring.{u} R] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] (f g : @module.End.{u v} R M _inst_1 _inst_4 _inst_5), @eq.{v+1} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@has_bracket.bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@lie_ring.to_has_bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.to_lie_ring.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))) f g) (@has_sub.sub.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@add_group_has_sub.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@add_comm_group.to_add_group.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5))) (@linear_map.comp.{u v v v} R M M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_4 _inst_5 _inst_5 _inst_5 f g) (@linear_map.comp.{u v v v} R M M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_4 _inst_5 _inst_5 _inst_5 g f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
α :
  @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
    (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
    (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5),
x y : L,
m : M
⊢ @eq.{v+1} M
    (@coe_fn.{v+1 v+1} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
       (@linear_map.has_coe_to_fun.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
       (@has_bracket.bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
          (@lie_ring.to_has_bracket.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
             (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                _inst_5)
             (@lie_algebra.to_lie_ring.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
          (@coe_fn.{v+1 v+1}
             (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
             (@coe_fn_trans.{v+1 v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@coe_base_aux.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
             α
             x)
          (@coe_fn.{v+1 v+1}
             (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)
                (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
             (@coe_fn_trans.{v+1 v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@coe_base_aux.{v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   _inst_2
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
             α
             y))
       m)
    (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α))))
          x
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@coe.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_to_lift.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@coe_base.{v+1 v+1}
                               (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                               (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                                  (@comm_ring.to_ring.{u} R _inst_1)
                                  _inst_2
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                               (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                         α)))
                (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@coe.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_to_lift.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@coe_base.{v+1 v+1}
                               (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                                  _inst_2
                                  _inst_3
                                  (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                     _inst_4
                                     _inst_5
                                     _inst_5)
                                  (… _inst_1 M _inst_4 _inst_5))
                               …
                               …))
                         α)))
                …
                …
                …)
             y
             m))
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
α :
  @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
    (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
    (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5),
x y : L,
m : M
⊢ @eq.{v+1} M
    (@coe_fn.{v+1 v+1} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
       (@linear_map.has_coe_to_fun.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5)
       (@has_sub.sub.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
          (@add_group_has_sub.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
             (@add_comm_group.to_add_group.{v} (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                   _inst_5)))
          (@linear_map.comp.{u v v v} R M M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_4 _inst_5 _inst_5
             _inst_5
             (@coe_fn.{v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@coe_fn_trans.{v+1 v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@coe_base_aux.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                      (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                α
                x)
             (@coe_fn.{v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@coe_fn_trans.{v+1 v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@coe_base_aux.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                      (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                α
                y))
          (@linear_map.comp.{u v v v} R M M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_4 _inst_5 _inst_5
             _inst_5
             (@coe_fn.{v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@coe_fn_trans.{v+1 v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@coe_base_aux.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                      (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                α
                y)
             (@coe_fn.{v+1 v+1}
                (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3
                   (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5
                      _inst_5)
                   (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                (@coe_fn_trans.{v+1 v+1 v+1}
                   (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                      _inst_3
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                   (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@coe_base_aux.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                      (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)))
                   (@linear_map.has_coe_to_fun.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      _inst_2
                      (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                         _inst_5
                         _inst_5)
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra.to_module.{u v} R (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                α
                x)))
       m)
    (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@linear_action.mk.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.add_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_add.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.act_smul.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (@coe_base.{v+1 v+1}
                            (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                            (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               _inst_2
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                            (@lie_algebra.has_coe.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                               _inst_2
                               _inst_3
                               (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                  _inst_4
                                  _inst_5
                                  _inst_5)
                               (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))))
                      α)))
             (@linear_action.smul_act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@linear_action.of_endo_map.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@coe.{v+1 v+1}
                      (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2
                         _inst_3
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                      (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         _inst_2
                         (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                            _inst_5
                            _inst_5)
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                      (@coe_to_lift.{v+1 v+1}
                         (@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1
                            _inst_2
                            _inst_3
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5))
                         (@linear_map.{u v v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            _inst_2
                            (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4
                               _inst_5
                               _inst_5)
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@linear_map.module.{u v v} R M M _inst_1 _inst_4 _inst_4 _inst_5 _inst_5))
                         (… …))
                      α))))
          x
          …)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301    ..(linear_action.of_endo_map R L M α) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='linear_action.of_endo_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (R : Type u) (M N : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3], @linear_map.{u v v} R M (@module.End.{u v} R N _inst_1 _inst_3 _inst_5) (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@linear_map.add_comm_group.{u v v} R N N (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_3 _inst_5 _inst_5) _inst_4 (@linear_map.module.{u v v} R N N _inst_1 _inst_3 _inst_3 _inst_5 _inst_5) → @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A linear map to the endomorphism algebra yields a linear action.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304  Every Lie algebra is a module over itself.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306  instance lie_algebra_self_module : lie_module R L L :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    lie_module.of_endo_morphism R L L lie_algebra.Ad</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_module.of_endo_morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_algebra.Ad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 228, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], @lie_algebra.morphism.{u v} R L (@module.End.{u v} R M _inst_1 _inst_4 _inst_5) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R M M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_4 _inst_5 _inst_5) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 M _inst_4 _inst_5) → @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], @lie_algebra.morphism.{u v} R L (@module.End.{u v} R L _inst_1 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) _inst_1 _inst_2 _inst_3 (@linear_map.add_comm_group.{u v v} R L L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@lie_algebra.of_endomorphism_algebra.{u v} R _inst_1 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A Lie morphism from a Lie algebra to the endomorphism algebra of a module yields
a Lie module structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The adjoint action of a Lie algebra on itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310  A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  This is a sufficient condition for the subset itself to form a Lie module.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  structure lie_submodule [lie_module R L M] extends submodule R M :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314  (lie_mem : ∀ {x : L} {m : M}, m ∈ carrier → linear_action.act R x m ∈ carrier)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='lie_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='carrier'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='carrier'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {x : L} {m : M}, @has_mem.mem.{v v} M (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 to_submodule) (@set.has_mem.{v} M) m carrier → @has_mem.mem.{v v} M (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 to_submodule) (@set.has_mem.{v} M) (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) x m) carrier'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  instance lie_submodule_coe_submodule [lie_module R L M] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317    has_coe (lie_submodule R L M) (submodule R M) := ⟨lie_submodule.to_submodule⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lie_submodule.to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u → Sort v → Sort (max 1 (imax u v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → @submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319  instance lie_submodule_has_mem [lie_module R L M] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320    has_mem M (lie_submodule R L M) := ⟨λ x N, x ∈ (N : set M)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='out_param.{u+2} (Type u) → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322  instance lie_submodule_lie_module [lie_module R L M] (N : lie_submodule R L M) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lie_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323    lie_module R L N := {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324    act      := λ x m, ⟨linear_action.act R x m.val, N.lie_mem m.property⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='linear_action.act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_submodule.lie_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (set.{v} M) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (set.{v} M) (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)) (@set.has_coe_to_sort.{v} M))) N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], M → N → N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (set.{v} M) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (set.{v} M) (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)) (@set.has_coe_to_sort.{v} M))) N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] (c : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) {x : L} {m : M}, @has_mem.mem.{v v} M (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c)) (@set.has_mem.{v} M) m (@submodule.carrier.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c)) → @has_mem.mem.{v v} M (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c)) (@set.has_mem.{v} M) (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) x m) (@submodule.carrier.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (set.{v} M) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5) (set.{v} M) (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)) (@set.has_coe_to_sort.{v} M))) N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {p : α → Prop} (c : @subtype.{v+1} α p), p (@subtype.val.{v+1} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325    add_act  := by { intros x y m, apply set_coe.ext, apply linear_action.add_act, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='linear_action.add_act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5] (m m&#x27; : M) (n : N), @eq.{v+1} N (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c (@has_add.add.{v} M (@add_semigroup.to_has_add.{v} M (@add_monoid.to_add_semigroup.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) m m&#x27;) n) (@has_add.add.{v} N (@add_semigroup.to_has_add.{v} N (@add_monoid.to_add_semigroup.{v} N (@add_group.to_add_monoid.{v} N (@add_comm_group.to_add_group.{v} N _inst_3)))) (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c m n) (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c m&#x27; n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6
⊢ ∀ (m m&#x27; : L)
  (n :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
         (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (set.{v} M)
            (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
            (@set.has_coe_to_sort.{v} M)))
      N),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@set.has_coe_to_sort.{v} M)))
         N)
      (@subtype.mk.{v+1} M
         (λ (x : M),
            @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
              (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                 (set.{v} M)
                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                 (@has_coe_t_aux.coe.{v+1 v+1}
                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (@coe_base_aux.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                    N)))
         (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            _inst_5
            (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@has_add.add.{v} L
               (@add_semigroup.to_has_add.{v} L
                  (@add_monoid.to_add_semigroup.{v} L
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
               m
               m&#x27;)
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               n))
         (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N
            (@has_add.add.{v} L
               (@add_semigroup.to_has_add.{v} L
                  (@add_monoid.to_add_semigroup.{v} L
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
               m
               m&#x27;)
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               n)
            (@subtype.property.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               n)))
      (@has_add.add.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@set.has_coe_to_sort.{v} M)))
            N)
         (@add_semigroup.to_has_add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@set.has_coe_to_sort.{v} M)))
               N)
            (@add_monoid.to_add_semigroup.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@set.has_coe_to_sort.{v} M)))
                  N)
               (@add_group.to_add_monoid.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@add_comm_group.to_add_group.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
         (@subtype.mk.{v+1} M
            (λ (x : M),
               @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                 (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                    (@has_coe_t_aux.coe.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@coe_base_aux.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                       N)))
            (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               m
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n))
            (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n)
               (@subtype.property.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n)))
         (@subtype.mk.{v+1} M
            (λ (x : M),
               @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                 (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                    (@has_coe_t_aux.coe.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@coe_base_aux.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                       N)))
            (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               m&#x27;
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n))
            (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m&#x27;
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n)
               (@subtype.property.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
x y : L,
m :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@set.has_coe_to_sort.{v} M)))
       N)
    (@subtype.mk.{v+1} M
       (λ (x : M),
          @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@has_coe_t_aux.coe.{v+1 v+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  N)))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             x
             y)
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             m))
       (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             x
             y)
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             m)
          (@subtype.property.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             m)))
    (@has_add.add.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@set.has_coe_to_sort.{v} M)))
          N)
       (@add_semigroup.to_has_add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N)
          (@add_monoid.to_add_semigroup.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N)
             (@add_group.to_add_monoid.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@add_comm_group.to_add_group.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                      (@has_coe_t_aux.coe.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         N))))))
       (@subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m)
             (@subtype.property.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m)))
       (@subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             y
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N y
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m)
             (@subtype.property.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
x y : L,
m :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1} M
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       (@subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@has_add.add.{v} L
                (@add_semigroup.to_has_add.{v} L
                   (@add_monoid.to_add_semigroup.{v} L
                      (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
                x
                y)
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N
             (@has_add.add.{v} L
                (@add_semigroup.to_has_add.{v} L
                   (@add_monoid.to_add_semigroup.{v} L
                      (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
                x
                y)
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m)
             (@subtype.property.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m))))
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       (@has_add.add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N)
          (@add_semigroup.to_has_add.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N)
             (@add_monoid.to_add_semigroup.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@add_group.to_add_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_comm_group.to_add_group.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                         (@has_coe_t_aux.coe.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            N))))))
          (@subtype.mk.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m))
             (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)
                (@subtype.property.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)))
          (@subtype.mk.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                y
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m))
             (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N y
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)
                (@subtype.property.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326    act_add  := by { intros x m n, apply set_coe.ext, apply linear_action.act_add, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='linear_action.act_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5] (m : M) (n n&#x27; : N), @eq.{v+1} N (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c m (@has_add.add.{v} N (@add_semigroup.to_has_add.{v} N (@add_monoid.to_add_semigroup.{v} N (@add_group.to_add_monoid.{v} N (@add_comm_group.to_add_group.{v} N _inst_3)))) n n&#x27;)) (@has_add.add.{v} N (@add_semigroup.to_has_add.{v} N (@add_monoid.to_add_semigroup.{v} N (@add_group.to_add_monoid.{v} N (@add_comm_group.to_add_group.{v} N _inst_3)))) (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c m n) (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c m n&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6
⊢ ∀ (m : L)
  (n n&#x27; :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
         (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (set.{v} M)
            (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
            (@set.has_coe_to_sort.{v} M)))
      N),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@set.has_coe_to_sort.{v} M)))
         N)
      (@subtype.mk.{v+1} M
         (λ (x : M),
            @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
              (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                 (set.{v} M)
                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                 (@has_coe_t_aux.coe.{v+1 v+1}
                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (@coe_base_aux.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                    N)))
         (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            _inst_5
            (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            m
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               (@has_add.add.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@add_semigroup.to_has_add.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@add_monoid.to_add_semigroup.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@set.has_coe_to_sort.{v} M)))
                           N)
                        (@add_group.to_add_monoid.{v}
                           (@coe_sort.{v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                          _inst_5))
                                    (@set.has_coe_to_sort.{v} M)))
                              N)
                           (@add_comm_group.to_add_group.{v}
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))))))
                  n
                  n&#x27;)))
         (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               (@has_add.add.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@add_semigroup.to_has_add.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@add_monoid.to_add_semigroup.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@set.has_coe_to_sort.{v} M)))
                           N)
                        (@add_group.to_add_monoid.{v}
                           (@coe_sort.{v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                          _inst_5))
                                    (@set.has_coe_to_sort.{v} M)))
                              N)
                           (@add_comm_group.to_add_group.{v}
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))))))
                  n
                  n&#x27;))
            (@subtype.property.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               (@has_add.add.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@add_semigroup.to_has_add.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@add_monoid.to_add_semigroup.{v}
                        (@coe_sort.{v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@set.has_coe_to_sort.{v} M)))
                           N)
                        (@add_group.to_add_monoid.{v}
                           (@coe_sort.{v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                          _inst_5))
                                    (@set.has_coe_to_sort.{v} M)))
                              N)
                           (@add_comm_group.to_add_group.{v}
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))))))
                  n
                  n&#x27;))))
      (@has_add.add.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@set.has_coe_to_sort.{v} M)))
            N)
         (@add_semigroup.to_has_add.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@set.has_coe_to_sort.{v} M)))
               N)
            (@add_monoid.to_add_semigroup.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@set.has_coe_to_sort.{v} M)))
                  N)
               (@add_group.to_add_monoid.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           …
                           …
                           …))
                     N)
                  …)))
         …
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
x : L,
m n :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@set.has_coe_to_sort.{v} M)))
       N)
    (@subtype.mk.{v+1} M
       (λ (x : M),
          @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@has_coe_t_aux.coe.{v+1 v+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  N)))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          x
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@has_add.add.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@add_semigroup.to_has_add.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_monoid.to_add_semigroup.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@add_group.to_add_monoid.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_comm_group.to_add_group.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))))))
                m
                n)))
       (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@has_add.add.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@add_semigroup.to_has_add.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_monoid.to_add_semigroup.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@add_group.to_add_monoid.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_comm_group.to_add_group.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))))))
                m
                n))
          (@subtype.property.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@has_add.add.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@add_semigroup.to_has_add.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_monoid.to_add_semigroup.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@add_group.to_add_monoid.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_comm_group.to_add_group.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))))))
                m
                n))))
    (@has_add.add.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@set.has_coe_to_sort.{v} M)))
          N)
       (@add_semigroup.to_has_add.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N)
          (@add_monoid.to_add_semigroup.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N)
             (@add_group.to_add_monoid.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@add_comm_group.to_add_group.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            …
                            …
                            …))
                      N)
                   …))))
       …
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
x : L,
m n :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1} M
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       (@subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                (@has_add.add.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_semigroup.to_has_add.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@add_monoid.to_add_semigroup.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_group.to_add_monoid.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@add_comm_group.to_add_group.{v}
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N))))))
                   m
                   n)))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                (@has_add.add.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_semigroup.to_has_add.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@add_monoid.to_add_semigroup.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_group.to_add_monoid.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@add_comm_group.to_add_group.{v}
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N))))))
                   m
                   n))
             (@subtype.property.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                (@has_add.add.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_semigroup.to_has_add.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@add_monoid.to_add_semigroup.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_group.to_add_monoid.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@add_comm_group.to_add_group.{v}
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N))))))
                   m
                   n)))))
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (… _inst_1) _inst_4 _inst_5) … …
                   …))
             M
             …))
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327    act_smul := by { intros r x y, apply set_coe.ext, apply linear_action.act_smul, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='linear_action.act_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5] (r : R) (m : M) (n : N), @eq.{v+1} N (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c (@has_scalar.smul.{u v} R M (@mul_action.to_has_scalar.{u v} R M (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R M (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R M (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} M _inst_2) (@module.to_semimodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4)))) r m) n) (@has_scalar.smul.{u v} R N (@mul_action.to_has_scalar.{u v} R N (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R N (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} N (@add_comm_group.to_add_group.{v} N _inst_3)) (@semimodule.to_distrib_mul_action.{u v} R N (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} N _inst_3) (@module.to_semimodule.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_5)))) r (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c m n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6
⊢ ∀ (r : R) (m : L)
  (n :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
         (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (set.{v} M)
            (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
            (@set.has_coe_to_sort.{v} M)))
      N),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@set.has_coe_to_sort.{v} M)))
         N)
      (@subtype.mk.{v+1} M
         (λ (x : M),
            @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
              (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                 (set.{v} M)
                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                 (@has_coe_t_aux.coe.{v+1 v+1}
                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (@coe_base_aux.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                    N)))
         (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            _inst_5
            (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@has_scalar.smul.{u v} R L
               (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@distrib_mul_action.to_mul_action.{u v} R L
                     (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                     (@semimodule.to_distrib_mul_action.{u v} R L
                        (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                        (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
               r
               m)
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               n))
         (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N
            (@has_scalar.smul.{u v} R L
               (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@distrib_mul_action.to_mul_action.{u v} R L
                     (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                     (@semimodule.to_distrib_mul_action.{u v} R L
                        (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                        (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
               r
               m)
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               n)
            (@subtype.property.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               n)))
      (@has_scalar.smul.{u v} R
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@set.has_coe_to_sort.{v} M)))
            N)
         (@mul_action.to_has_scalar.{u v} R
            (@coe_sort.{v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@set.has_coe_to_sort.{v} M)))
               N)
            (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
            (@distrib_mul_action.to_mul_action.{u v} R
               (@coe_sort.{v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@set.has_coe_to_sort.{v} M)))
                  N)
               (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
               (@add_group.to_add_monoid.{v}
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@add_comm_group.to_add_group.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))
               (@semimodule.to_distrib_mul_action.{u v} R
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@add_comm_group.to_add_comm_monoid.{v}
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                  (@module.to_semimodule.{u v} R
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@comm_ring.to_ring.{u} R _inst_1)
                     (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))
                     (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
         r
         (@subtype.mk.{v+1} M
            (λ (x : M),
               @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                 (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                    (@has_coe_t_aux.coe.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@coe_base_aux.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                       N)))
            (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               m
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n))
            (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n)
               (@subtype.property.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
r : R,
x : L,
y :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@set.has_coe_to_sort.{v} M)))
       N)
    (@subtype.mk.{v+1} M
       (λ (x : M),
          @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@has_coe_t_aux.coe.{v+1 v+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  N)))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@has_scalar.smul.{u v} R L
             (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                   (@semimodule.to_distrib_mul_action.{u v} R L
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                      (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
             r
             x)
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             y))
       (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N
          (@has_scalar.smul.{u v} R L
             (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                   (@semimodule.to_distrib_mul_action.{u v} R L
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                      (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
             r
             x)
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             y)
          (@subtype.property.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             y)))
    (@has_scalar.smul.{u v} R
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@set.has_coe_to_sort.{v} M)))
          N)
       (@mul_action.to_has_scalar.{u v} R
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N)
          (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N)
             (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@add_group.to_add_monoid.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@add_comm_group.to_add_group.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                      (@has_coe_t_aux.coe.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         N))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                      (@has_coe_t_aux.coe.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         N)))
                (@module.to_semimodule.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                      (@has_coe_t_aux.coe.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         N))
                   (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                      (@has_coe_t_aux.coe.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         N))))))
       r
       (@subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                y))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                y)
             (@subtype.property.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
r : R,
x : L,
y :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1} M
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       (@subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@has_scalar.smul.{u v} R L
                (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@distrib_mul_action.to_mul_action.{u v} R L
                      (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                      (@semimodule.to_distrib_mul_action.{u v} R L
                         (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                         (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                         (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
                r
                x)
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                y))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N
             (@has_scalar.smul.{u v} R L
                (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@distrib_mul_action.to_mul_action.{u v} R L
                      (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                      (@semimodule.to_distrib_mul_action.{u v} R L
                         (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                         (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                         (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
                r
                x)
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                y)
             (@subtype.property.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                y))))
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       (@has_scalar.smul.{u v} R
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N)
          (@mul_action.to_has_scalar.{u v} R
             (@coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N)
             (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v}
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@add_comm_group.to_add_group.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                         (@has_coe_t_aux.coe.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            N))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                         (@has_coe_t_aux.coe.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            N)))
                   (@module.to_semimodule.{u v} R
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                         (@has_coe_t_aux.coe.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            N))
                      (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                         (@has_coe_t_aux.coe.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            N))))))
          r
          (@subtype.mk.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   y))
             (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   y)
                (@subtype.property.{v+1} M (λ (x : M), @has_mem.mem.{v v} M (set.{v} M) … x …) y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328    smul_act := by { intros r x y, apply set_coe.ext, apply linear_action.smul_act, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='linear_action.smul_act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/linear_action.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M N : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} N] [_inst_4 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2] [_inst_5 : @module.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3] [c : @linear_action.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5] (r : R) (m : M) (n : N), @eq.{v+1} N (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c m (@has_scalar.smul.{u v} R N (@mul_action.to_has_scalar.{u v} R N (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R N (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} N (@add_comm_group.to_add_group.{v} N _inst_3)) (@semimodule.to_distrib_mul_action.{u v} R N (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} N _inst_3) (@module.to_semimodule.{u v} R N (@comm_ring.to_ring.{u} R _inst_1) _inst_3 _inst_5)))) r n)) (@linear_action.act.{u v} R M N _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 c (@has_scalar.smul.{u v} R M (@mul_action.to_has_scalar.{u v} R M (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R M (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R M (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} M _inst_2) (@module.to_semimodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_2 _inst_4)))) r m) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6
⊢ ∀ (r : R) (m : L)
  (n :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
         (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (set.{v} M)
            (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
            (@set.has_coe_to_sort.{v} M)))
      N),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@set.has_coe_to_sort.{v} M)))
         N)
      (@subtype.mk.{v+1} M
         (λ (x : M),
            @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
              (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                 (set.{v} M)
                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                 (@has_coe_t_aux.coe.{v+1 v+1}
                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (@coe_base_aux.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                    N)))
         (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            _inst_5
            (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            m
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               (@has_scalar.smul.{u v} R
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@mul_action.to_has_scalar.{u v} R
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@distrib_mul_action.to_mul_action.{u v} R
                        (@coe_sort.{v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@set.has_coe_to_sort.{v} M)))
                           N)
                        (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_group.to_add_monoid.{v}
                           (@coe_sort.{v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                          _inst_5))
                                    (@set.has_coe_to_sort.{v} M)))
                              N)
                           (@add_comm_group.to_add_group.{v}
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))))
                        (@semimodule.to_distrib_mul_action.{u v} R
                           (@coe_sort.{v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                          _inst_5))
                                    (@set.has_coe_to_sort.{v} M)))
                              N)
                           (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                           (@add_comm_group.to_add_comm_monoid.{v}
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N)))
                           (@module.to_semimodule.{u v} R
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))
                              (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))))))
                  r
                  n)))
         (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m
            (@subtype.val.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               (@has_scalar.smul.{u v} R
                  (@coe_sort.{v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@set.has_coe_to_sort.{v} M)))
                     N)
                  (@mul_action.to_has_scalar.{u v} R
                     (@coe_sort.{v+1 (max 1 (v+1))+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@set.has_coe_to_sort.{v} M)))
                        N)
                     (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@distrib_mul_action.to_mul_action.{u v} R
                        (@coe_sort.{v+1 (max 1 (v+1))+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@set.has_coe_to_sort.{v} M)))
                           N)
                        (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                        (@add_group.to_add_monoid.{v}
                           (@coe_sort.{v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                          _inst_5))
                                    (@set.has_coe_to_sort.{v} M)))
                              N)
                           (@add_comm_group.to_add_group.{v}
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))))
                        (@semimodule.to_distrib_mul_action.{u v} R
                           (@coe_sort.{v+1 (max 1 (v+1))+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                          _inst_5))
                                    (@set.has_coe_to_sort.{v} M)))
                              N)
                           (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                           (@add_comm_group.to_add_comm_monoid.{v}
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N)))
                           (@module.to_semimodule.{u v} R
                              (@coe_sort.{v+1 (max 1 (v+1))+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (set.{v} M)
                                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                          (set.{v} M)
                                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                             _inst_5))
                                       (@set.has_coe_to_sort.{v} M)))
                                 N)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))
                              (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N))))))
                  r
                  n))
            (@subtype.property.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)} (@submodule.{u v} R M … _inst_4 _inst_5) … … …))
               …)))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
r : R,
x : L,
y :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@set.has_coe_to_sort.{v} M)))
       N)
    (@subtype.mk.{v+1} M
       (λ (x : M),
          @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
            (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@has_coe_t_aux.coe.{v+1 v+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  N)))
       (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          _inst_5
          (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          x
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@has_scalar.smul.{u v} R
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@mul_action.to_has_scalar.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@distrib_mul_action.to_mul_action.{u v} R
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_group.to_add_monoid.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_comm_group.to_add_group.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))))
                      (@semimodule.to_distrib_mul_action.{u v} R
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                         (@add_comm_group.to_add_comm_monoid.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N)))
                         (@module.to_semimodule.{u v} R
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))
                            (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))))))
                r
                y)))
       (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
          (@subtype.val.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@has_scalar.smul.{u v} R
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@mul_action.to_has_scalar.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@distrib_mul_action.to_mul_action.{u v} R
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_group.to_add_monoid.{v}
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@add_comm_group.to_add_group.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))))
                      (@semimodule.to_distrib_mul_action.{u v} R
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                         (@add_comm_group.to_add_comm_monoid.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N)))
                         (@module.to_semimodule.{u v} R
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))
                            (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                               (@has_coe_t_aux.coe.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  N))))))
                r
                y))
          (@subtype.property.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@has_scalar.smul.{u v} R
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1} (… _inst_3 M _inst_4 _inst_5 _inst_6) … … …)
                   N)
                …
                r
                y))))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
r : R,
x : L,
y :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1} M
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       (@subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                (@has_scalar.smul.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@mul_action.to_has_scalar.{u v} R
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@distrib_mul_action.to_mul_action.{u v} R
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                         (@add_group.to_add_monoid.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@add_comm_group.to_add_group.{v}
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N))))
                         (@semimodule.to_distrib_mul_action.{u v} R
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                            (@add_comm_group.to_add_comm_monoid.{v}
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N)))
                            (@module.to_semimodule.{u v} R
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@comm_ring.to_ring.{u} R _inst_1)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N))
                               (@submodule.module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N))))))
                   r
                   y)))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                (@has_scalar.smul.{u v} R
                   (@coe_sort.{v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@coe_base_aux.{v+1 v+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@coe_base_aux.{v+1 (max (v+1) 1)}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                            (@set.has_coe_to_sort.{v} M)))
                      N)
                   (@mul_action.to_has_scalar.{u v} R
                      (@coe_sort.{v+1 (max 1 (v+1))+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (@coe_base_aux.{v+1 v+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                  _inst_6))
                            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (set.{v} M)
                               (@coe_base_aux.{v+1 (max (v+1) 1)}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                               (@set.has_coe_to_sort.{v} M)))
                         N)
                      (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@distrib_mul_action.to_mul_action.{u v} R
                         (@coe_sort.{v+1 (max 1 (v+1))+1}
                            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                               (@coe_base_aux.{v+1 v+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                     _inst_6))
                               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (set.{v} M)
                                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                  (@set.has_coe_to_sort.{v} M)))
                            N)
                         (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                         (@add_group.to_add_monoid.{v}
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@add_comm_group.to_add_group.{v}
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N))))
                         (@semimodule.to_distrib_mul_action.{u v} R
                            (@coe_sort.{v+1 (max 1 (v+1))+1}
                               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                  (@coe_base_aux.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                        _inst_6))
                                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (set.{v} M)
                                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                           _inst_5))
                                     (@set.has_coe_to_sort.{v} M)))
                               N)
                            (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                            (@add_comm_group.to_add_comm_monoid.{v}
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (set.{v} M)
                                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                           (set.{v} M)
                                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4
                                              _inst_5))
                                        (@set.has_coe_to_sort.{v} M)))
                                  N)
                               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                                  (@has_coe_t_aux.coe.{v+1 v+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     N)))
                            (@module.to_semimodule.{u v} R
                               (@coe_sort.{v+1 (max 1 (v+1))+1}
                                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                     (@coe_base_aux.{v+1 v+1}
                                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4
                                           _inst_5
                                           _inst_6))
                                     (… … … …))
                                  N)
                               …
                               …
                               …))))
                   r
                   y))
             …)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329    lie_act  := by { intros x y m, apply set_coe.ext, apply lie_module.lie_act, } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='set_coe.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_module.lie_act'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s : set.{v} α} {a b : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s}, @eq.{v+1} α (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) a) (@coe.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_to_lift.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_base.{(max 1 (v+1)) v+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) α (@coe_subtype.{v+1} α (λ (x : α), @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) x s)))) b) → @eq.{(max 1 (v+1))} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} α) (@set.has_coe_to_sort.{v} α) s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [c : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] (l l&#x27; : L) (m : M), @eq.{v+1} M (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) l l&#x27;) m) (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_4)) (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l&#x27; m)) (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l&#x27; (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 c) l m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6
⊢ ∀ (l l&#x27; : L)
  (m :
    @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
      (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
         (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
         (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (set.{v} M)
            (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
            (@set.has_coe_to_sort.{v} M)))
      N),
    @eq.{v+1}
      (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
         (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
            (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
            (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
            (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (set.{v} M)
               (@coe_base_aux.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
               (@set.has_coe_to_sort.{v} M)))
         N)
      ((λ (x : L)
        (m :
          @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@set.has_coe_to_sort.{v} M)))
            N),
          @subtype.mk.{v+1} M
            (λ (x : M),
               @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                 (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                    (set.{v} M)
                    (@coe_base_aux.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                    (@has_coe_t_aux.coe.{v+1 v+1}
                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (@coe_base_aux.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                       N)))
            (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               _inst_5
               (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               x
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  m))
            (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
               (@subtype.val.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  m)
               (@subtype.property.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  m)))
         (@has_bracket.bracket.{v} L
            (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
            l
            l&#x27;)
         m)
      (@has_sub.sub.{v}
         (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
            (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
               (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
               (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@set.has_coe_to_sort.{v} M)))
            N)
         (@add_group_has_sub.{v}
            (@coe_sort.{v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@set.has_coe_to_sort.{v} M)))
               N)
            (@add_comm_group.to_add_group.{v}
               (@coe_sort.{v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@set.has_coe_to_sort.{v} M)))
                  N)
               (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N))))
         ((λ (x : L)
           (m :
             @coe_sort.{v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@set.has_coe_to_sort.{v} M)))
               N),
             @subtype.mk.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  x
                  (@subtype.val.{v+1} M
                     (λ (x : M),
                        @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                             (@has_coe_t_aux.coe.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@coe_base_aux.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                      _inst_6))
                                N)))
                     m))
               (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                  (@subtype.val.{v+1} M
                     (λ (x : M),
                        @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                             (@has_coe_t_aux.coe.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@coe_base_aux.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                      _inst_6))
                                N)))
                     m)
                  (@subtype.property.{v+1} M
                     (λ (x : M),
                        @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                             (@has_coe_t_aux.coe.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@coe_base_aux.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                      _inst_6))
                                N)))
                     m)))
            l
            ((λ (x : L)
              (m :
                @coe_sort.{v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@set.has_coe_to_sort.{v} M)))
                  N),
                @subtype.mk.{v+1} M
                  (λ (x : M),
                     @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                       (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@coe_base_aux.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                          (@has_coe_t_aux.coe.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@coe_base_aux.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                   _inst_6))
                             N)))
                  (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     _inst_5
                     (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     x
                     (@subtype.val.{v+1} M
                        (λ (x : M),
                           @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (set.{v} M)
                                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                (@has_coe_t_aux.coe.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@coe_base_aux.{v+1 v+1}
                                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                         _inst_6))
                                   N)))
                        m))
                  (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                     (@subtype.val.{v+1} M
                        (λ (x : M),
                           @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (set.{v} M)
                                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                (@has_coe_t_aux.coe.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@coe_base_aux.{v+1 v+1}
                                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                         _inst_6))
                                   N)))
                        m)
                     (@subtype.property.{v+1} M
                        (λ (x : M),
                           @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@coe_base_aux.{v+1 (max (v+1) 1)}
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (set.{v} M)
                                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                (@has_coe_t_aux.coe.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@coe_base_aux.{v+1 v+1}
                                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                         _inst_6))
                                   N)))
                        m)))
               l&#x27;
               m))
         ((λ (x : L)
           (m :
             @coe_sort.{v+1 (max 1 (v+1))+1}
               (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
               (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                  (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                  (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@set.has_coe_to_sort.{v} M)))
               N),
             @subtype.mk.{v+1} M
               (λ (x : M),
                  @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                    (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                       (set.{v} M)
                       (@coe_base_aux.{v+1 (max (v+1) 1)}
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (set.{v} M)
                          (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                       (@has_coe_t_aux.coe.{v+1 v+1}
                          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                          (@coe_base_aux.{v+1 v+1}
                             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                          N)))
               (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  _inst_5
                  (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                  x
                  (@subtype.val.{v+1} M
                     (λ (x : M),
                        @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                             (@has_coe_t_aux.coe.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@coe_base_aux.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                      _inst_6))
                                N)))
                     m))
               (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                  (@subtype.val.{v+1} M
                     (λ (x : M),
                        @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                             (@has_coe_t_aux.coe.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@coe_base_aux.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                      _inst_6))
                                N)))
                     m)
                  (@subtype.property.{v+1} M
                     (λ (x : M),
                        @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                             (set.{v} M)
                             (@coe_base_aux.{v+1 (max (v+1) 1)}
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (set.{v} M)
                                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                             (@has_coe_t_aux.coe.{v+1 v+1}
                                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                (@coe_base_aux.{v+1 v+1}
                                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                      _inst_6))
                                N)))
                     m)))
            l&#x27;
            ((λ (x : L) (m : @coe_sort.{v+1 (max 1 (v+1))+1} (… _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) … N),
                …)
               l
               m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
x y : L,
m :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1}
    (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
          (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@set.has_coe_to_sort.{v} M)))
       N)
    ((λ (x : L)
      (m :
        @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@set.has_coe_to_sort.{v} M)))
          N),
        @subtype.mk.{v+1} M
          (λ (x : M),
             @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
               (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                  (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                  (set.{v} M)
                  (@coe_base_aux.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                  (@has_coe_t_aux.coe.{v+1 v+1}
                     (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (@coe_base_aux.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                     N)))
          (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             _inst_5
             (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m))
          (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
             (@subtype.val.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m)
             (@subtype.property.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                m)))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y)
       m)
    (@has_sub.sub.{v}
       (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
             (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@set.has_coe_to_sort.{v} M)))
          N)
       (@add_group_has_sub.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N)
          (@add_comm_group.to_add_group.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N)
             (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N))))
       ((λ (x : L)
         (m :
           @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N),
           @subtype.mk.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m))
             (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)
                (@subtype.property.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)))
          x
          ((λ (x : L)
            (m :
              @coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N),
              @subtype.mk.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   x
                   (@subtype.val.{v+1} M
                      (λ (x : M),
                         @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                           (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@has_coe_t_aux.coe.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 N)))
                      m))
                (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                   (@subtype.val.{v+1} M
                      (λ (x : M),
                         @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                           (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@has_coe_t_aux.coe.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 N)))
                      m)
                   (@subtype.property.{v+1} M
                      (λ (x : M),
                         @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                           (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@has_coe_t_aux.coe.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 N)))
                      m)))
             y
             m))
       ((λ (x : L)
         (m :
           @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N),
           @subtype.mk.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m))
             (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)
                (@subtype.property.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)))
          y
          ((λ (x : L)
            (m :
              @coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N), @subtype.mk.{v+1} M (λ (x : M), … … … x …) … …)
             x
             m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
M : Type v,
_inst_4 : add_comm_group.{v} M,
_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4,
_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5,
N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6,
x y : L,
m :
  @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
    (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
       (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
          (set.{v} M)
          (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
          (@set.has_coe_to_sort.{v} M)))
    N
⊢ @eq.{v+1} M
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       ((λ (x : L)
         (m :
           @coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N),
           @subtype.mk.{v+1} M
             (λ (x : M),
                @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                  (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                     (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                     (set.{v} M)
                     (@coe_base_aux.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                     (@has_coe_t_aux.coe.{v+1 v+1}
                        (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (@coe_base_aux.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                        N)))
             (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                _inst_5
                (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m))
             (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                (@subtype.val.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)
                (@subtype.property.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   m)))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)
          m))
    (@coe.{(max 1 (v+1)) v+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
          (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
             (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
             (set.{v} M)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
             (@has_coe_t_aux.coe.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                N)))
       M
       (@coe_to_lift.{(max 1 (v+1)) v+1}
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
             (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (set.{v} M)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                (@has_coe_t_aux.coe.{v+1 v+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   N)))
          M
          (@coe_base.{(max 1 (v+1)) v+1}
             (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} M) (@set.has_coe_to_sort.{v} M)
                (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N)))
             M
             (@coe_subtype.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N))))))
       (@has_sub.sub.{v}
          (@coe_sort.{v+1 (max 1 (v+1))+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
             (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (set.{v} M)
                   (@coe_base_aux.{v+1 (max (v+1) 1)}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                   (@set.has_coe_to_sort.{v} M)))
             N)
          (@add_group_has_sub.{v}
             (@coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N)
             (@add_comm_group.to_add_group.{v}
                (@coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N)
                (@submodule.add_comm_group.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5
                   (@has_coe_t_aux.coe.{v+1 v+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      N))))
          ((λ (x : L)
            (m :
              @coe_sort.{v+1 (max 1 (v+1))+1}
                (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                   (@coe_base_aux.{v+1 v+1} (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                   (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (set.{v} M)
                      (@coe_base_aux.{v+1 (max (v+1) 1)}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                      (@set.has_coe_to_sort.{v} M)))
                N),
              @subtype.mk.{v+1} M
                (λ (x : M),
                   @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                     (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                        (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                        (set.{v} M)
                        (@coe_base_aux.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                        (@has_coe_t_aux.coe.{v+1 v+1}
                           (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (@coe_base_aux.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                 _inst_6))
                           N)))
                (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   _inst_5
                   (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   x
                   (@subtype.val.{v+1} M
                      (λ (x : M),
                         @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                           (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@has_coe_t_aux.coe.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 N)))
                      m))
                (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                   (@subtype.val.{v+1} M
                      (λ (x : M),
                         @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                           (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@has_coe_t_aux.coe.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 N)))
                      m)
                   (@subtype.property.{v+1} M
                      (λ (x : M),
                         @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                           (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@coe_base_aux.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                              (@has_coe_t_aux.coe.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@coe_base_aux.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                       _inst_6))
                                 N)))
                      m)))
             x
             ((λ (x : L)
               (m :
                 @coe_sort.{v+1 (max 1 (v+1))+1}
                   (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                   (@coe_sort_trans.{v+1 v+1 (max 1 (v+1))+1}
                      (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                      (@coe_base_aux.{v+1 v+1}
                         (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6))
                      (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                         (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                         (set.{v} M)
                         (@coe_base_aux.{v+1 (max (v+1) 1)}
                            (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                            (set.{v} M)
                            (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                         (@set.has_coe_to_sort.{v} M)))
                   N),
                 @subtype.mk.{v+1} M
                   (λ (x : M),
                      @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                        (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                           (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                           (set.{v} M)
                           (@coe_base_aux.{v+1 (max (v+1) 1)}
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (set.{v} M)
                              (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                           (@has_coe_t_aux.coe.{v+1 v+1}
                              (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                              (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                              (@coe_base_aux.{v+1 v+1}
                                 (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                    _inst_6))
                              N)))
                   (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      _inst_5
                      (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                      x
                      (@subtype.val.{v+1} M
                         (λ (x : M),
                            @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                              (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N)))
                         m))
                   (@lie_submodule.lie_mem.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N x
                      (@subtype.val.{v+1} M
                         (λ (x : M),
                            @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                              (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       (@lie_submodule_coe_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5
                                          _inst_6))
                                    N)))
                         m)
                      (@subtype.property.{v+1} M
                         (λ (x : M),
                            @has_mem.mem.{v v} M (set.{v} M) (@set.has_mem.{v} M) x
                              (@has_coe_t_aux.coe.{v+1 (max (v+1) 1)}
                                 (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                 (set.{v} M)
                                 (@coe_base_aux.{v+1 (max (v+1) 1)}
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (set.{v} M)
                                    (@submodule.has_coe.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5))
                                 (@has_coe_t_aux.coe.{v+1 v+1}
                                    (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                    (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                    (@coe_base_aux.{v+1 v+1}
                                       (@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6)
                                       (@submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5)
                                       …)
                                    N)))
                         m)))
                y
                m))
          …))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332  An ideal of a Lie algebra is a Lie submodule of the Lie algebra as a Lie module over itself.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334  abbreviation lie_ideal := lie_submodule R L L</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='lie_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336  lemma lie_mem_right (I : lie_ideal R L) (x y : L) (h : y ∈ I) : ⁅x, y⁆ ∈ I := I.lie_mem h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='lie_ideal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_submodule.lie_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 334, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] (c : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) {x : L} {m : M}, @has_mem.mem.{v v} M (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c)) (@set.has_mem.{v} M) m (@submodule.carrier.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c)) → @has_mem.mem.{v v} M (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c)) (@set.has_mem.{v} M) (@linear_action.act.{u v} R L M _inst_1 _inst_2 _inst_4 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) _inst_5 (@lie_module.to_linear_action.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6) x m) (@submodule.carrier.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) y I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An ideal of a Lie algebra is a Lie submodule of the Lie algebra as a Lie module over itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  lemma lie_mem_left (I : lie_ideal R L) (x y : L) (h : x ∈ I) : ⁅x, y⁆ ∈ I := by {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='lie_ideal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 334, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An ideal of a Lie algebra is a Lie submodule of the Lie algebra as a Lie module over itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y : L,
h :
  @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    x
    I
⊢ @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x
       y)
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339    rw [←lie_skew, ←neg_lie], apply lie_mem_right, assumption, }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lie_skew'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='neg_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='lie_mem_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 129, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 336, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y x)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) x) y) (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (x y : L), @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) y I → @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y : L,
h :
  @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    x
    I
⊢ @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x
       y)
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y : L,
h :
  @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    x
    I
⊢ @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y
          x))
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y : L,
h :
  @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    x
    I
⊢ @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_neg.neg.{v} L (@add_group.to_has_neg.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) y)
       x)
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y : L,
h :
  @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    x
    I
⊢ @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    x
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342  An ideal of a Lie algebra is a Lie subalgebra.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344  def lie_ideal_subalgebra (I : lie_ideal R L) : lie_subalgebra R L := {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='lie_ideal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_subalgebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 334, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 252, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An ideal of a Lie algebra is a Lie submodule of the Lie algebra as a Lie module over itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie algebra.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345    lie_mem := by { intros x y hx hy, apply lie_mem_right, exact hy, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='lie_mem_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 336, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (x y : L), @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) y I → @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{v v} L (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β} {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β) R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)))) (@set.has_mem.{v} L) y (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀ {x y : L},
    @has_mem.mem.{v v} L
      (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
        {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3),
          set.{v} β)
         R
         L
         (@comm_ring.to_ring.{u} R _inst_1)
         _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))))
      (@set.has_mem.{v} L)
      x
      (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)))) →
    @has_mem.mem.{v v} L
      (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
        {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3),
          set.{v} β)
         R
         L
         (@comm_ring.to_ring.{u} R _inst_1)
         _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))))
      (@set.has_mem.{v} L)
      y
      (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)))) →
    @has_mem.mem.{v v} L
      (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
        {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3),
          set.{v} β)
         R
         L
         (@comm_ring.to_ring.{u} R _inst_1)
         _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))))
      (@set.has_mem.{v} L)
      (@has_bracket.bracket.{v} L
         (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
         x
         y)
      (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y : L,
hx :
  @has_mem.mem.{v v} L
    (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
      {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β)
       R
       L
       (@comm_ring.to_ring.{u} R _inst_1)
       _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))
    (@set.has_mem.{v} L)
    x
    (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)))),
hy :
  @has_mem.mem.{v v} L
    (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
      {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β)
       R
       L
       (@comm_ring.to_ring.{u} R _inst_1)
       _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))
    (@set.has_mem.{v} L)
    y
    (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))
⊢ @has_mem.mem.{v v} L
    (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
      {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β)
       R
       L
       (@comm_ring.to_ring.{u} R _inst_1)
       _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))
    (@set.has_mem.{v} L)
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x
       y)
    (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y : L,
hx :
  @has_mem.mem.{v v} L
    (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
      {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β)
       R
       L
       (@comm_ring.to_ring.{u} R _inst_1)
       _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))
    (@set.has_mem.{v} L)
    x
    (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)))),
hy :
  @has_mem.mem.{v v} L
    (@(λ {α : Type u} {β : Type v} {_inst_1 : ring.{u} α} {_inst_2 : add_comm_group.{v} β}
      {_inst_3 : @module.{u v} α β _inst_1 _inst_2} (c : @submodule.{u v} α β _inst_1 _inst_2 _inst_3), set.{v} β)
       R
       L
       (@comm_ring.to_ring.{u} R _inst_1)
       _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))
    (@set.has_mem.{v} L)
    y
    (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@submodule.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@submodule.carrier.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.zero.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.add.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          (@submodule.smul.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))))
⊢ @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3))
    y
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346    ..I.to_submodule, }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_submodule.to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → @submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348  end lie_module</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350  namespace lie_submodule</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352  variables {R : Type u} {L : Type v} [comm_ring R] [add_comm_group L] [lie_algebra R L]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  variables {M : Type v} [add_comm_group M] [module R M] [lie_module R L M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lie_module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra
on this module, such that the Lie bracket acts as the commutator of endomorphisms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  variables (N : lie_submodule R L M) (I : lie_ideal R L)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='lie_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='lie_ideal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 334, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (M : Type v) [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.
This is a sufficient condition for the subset itself to form a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An ideal of a Lie algebra is a Lie submodule of the Lie algebra as a Lie module over itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  The quotient of a Lie module by a Lie submodule. It is a Lie module.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359  abbreviation quotient := N.to_submodule.quotient</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_submodule.to_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='submodule.quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 784, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → @submodule.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2], @submodule.{u v} R M _inst_1 _inst_2 _inst_5 → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='The quotient of a module `M` by a submodule `p ⊆ M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  namespace quotient</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363  variables {N I}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366  Map sending an element of `M` to the corresponding element of `M/N`, when `N` is a lie_submodule of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367  the lie_module `N`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369  abbreviation mk : M → N.quotient := submodule.quotient.mk</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_submodule.quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='submodule.quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 359, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] {p : @submodule.{u v} R M _inst_1 _inst_2 _inst_5}, M → @submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The quotient of a Lie module by a Lie submodule. It is a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Map associating to an element of `M` the corresponding element of `M/p`,
when `p` is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>370  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>371  lemma is_quotient_mk (m : M) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>372    quotient.mk&#x27; m = (mk m : N.quotient) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_submodule.quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_submodule.quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 369, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 359, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u_1} {s₁ : setoid.{u_1} α}, α → @quotient.{u_1} α s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6}, M → @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Map sending an element of `M` to the corresponding element of `M/N`, when `N` is a lie_submodule of
the lie_module `N`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The quotient of a Lie module by a Lie submodule. It is a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>373  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>374  instance lie_quotient_has_bracket : has_bracket (quotient I) := ⟨by {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='has_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_submodule.quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 359, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A binary operation, intended use in Lie algebras and similar structures.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The quotient of a Lie module by a Lie submodule. It is a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I →
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I →
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>375    intros x y,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I →
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I →
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>376    apply quotient.lift_on₂&#x27; x y (λ x&#x27; y&#x27;, mk ⁅x&#x27;, y&#x27;⁆),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='quotient.lift_on₂&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lie_submodule.quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 239, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 369, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β γ : Type v} {s₁ : setoid.{v+1} α} {s₂ : setoid.{v+1} β}, @quotient.{v+1} α s₁ → @quotient.{v+1} β s₂ → Π (f : α → β → γ), (∀ (a₁ : α) (a₂ : β) (b₁ : α) (b₂ : β), @setoid.r.{v+1} α s₁ a₁ b₁ → @setoid.r.{v+1} β s₂ a₂ b₂ → @eq.{v+1} γ (f a₁ a₂) (f b₁ b₂)) → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6}, M → @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Map sending an element of `M` to the corresponding element of `M/N`, when `N` is a lie_submodule of
the lie_module `N`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ ∀ (a₁ a₂ b₁ b₂ : L),
    @setoid.r.{v+1} L
      (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I))
      a₁
      b₁ →
    @setoid.r.{v+1} L
      (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I))
      a₂
      b₂ →
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      ((λ (x&#x27; y&#x27; : L),
          @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x&#x27;
               y&#x27;))
         a₁
         a₂)
      ((λ (x&#x27; y&#x27; : L),
          @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x&#x27;
               y&#x27;))
         b₁
         b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>377    intros x₁ x₂ y₁ y₂ h₁ h₂,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ ∀ (a₁ a₂ b₁ b₂ : L),
    @setoid.r.{v+1} L
      (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I))
      a₁
      b₁ →
    @setoid.r.{v+1} L
      (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I))
      a₂
      b₂ →
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      ((λ (x&#x27; y&#x27; : L),
          @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x&#x27;
               y&#x27;))
         a₁
         a₂)
      ((λ (x&#x27; y&#x27; : L),
          @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I
            (@has_bracket.bracket.{v} L
               (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
               x&#x27;
               y&#x27;))
         b₁
         b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    ((λ (x&#x27; y&#x27; : L),
        @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x&#x27;
             y&#x27;))
       x₁
       x₂)
    ((λ (x&#x27; y&#x27; : L),
        @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x&#x27;
             y&#x27;))
       y₁
       y₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>378    apply (submodule.quotient.eq I.to_submodule).2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='submodule.quotient.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 796, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 313, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] (p : @submodule.{u v} R M _inst_1 _inst_2 _inst_5) {x y : M}, iff (@eq.{v+1} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p x) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p y)) (@has_mem.mem.{v v} M (@submodule.{u v} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u v} R M _inst_1 _inst_2 _inst_5) (@has_sub.sub.{v} M (@add_group_has_sub.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)) x y) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    ((λ (x&#x27; y&#x27; : L),
        @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x&#x27;
             y&#x27;))
       x₁
       x₂)
    ((λ (x&#x27; y&#x27; : L),
        @lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x&#x27;
             y&#x27;))
       y₁
       y₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>379    have h : ⁅x₁, x₂⁆ - ⁅y₁, y₂⁆ = ⁅x₁, x₂ - y₂⁆ + ⁅x₁ - y₁, y₂⁆ := by { simp [-lie_skew], },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂
⊢ @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>380    rw h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} L (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x₁ x₂) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) y₁ y₂)) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x₁ (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁) y₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>381    apply submodule.add_mem,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='submodule.add_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 294, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] (p : @submodule.{u v} α β _inst_1 _inst_2 _inst_4) {x y : β}, @has_mem.mem.{v v} β (@submodule.{u v} α β _inst_1 _inst_2 _inst_4) (@submodule.has_mem.{u v} α β _inst_1 _inst_2 _inst_4) x p → @has_mem.mem.{v v} β (@submodule.{u v} α β _inst_1 _inst_2 _inst_4) (@submodule.has_mem.{u v} α β _inst_1 _inst_2 _inst_4) y p → @has_mem.mem.{v v} β (@submodule.{u v} α β _inst_1 _inst_2 _inst_4) (@submodule.has_mem.{u v} α β _inst_1 _inst_2 _inst_4) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β _inst_2)))) x y) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x₁
       (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)

R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
       y₂)
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>382    { apply lie_mem_right R L I x₁ (x₂ - y₂) h₂, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lie_mem_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 336, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (x y : L), @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) y I → @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@setoid.r.{v+1} L (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) x₂ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x₁
       (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)

R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
       y₂)
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x₁
       (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
       y₂)
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>383    { apply lie_mem_left R L I (x₁ - y₁) y₂ h₁, }, }⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lie_mem_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (x y : L), @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) x I → @has_mem.mem.{v v} L (@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule_has_mem.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@setoid.r.{v+1} L (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I)) x₁ y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x y :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x₁ x₂ y₁ y₂ : L,
h₁ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₁
    y₁,
h₂ :
  @setoid.r.{v+1} L
    (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I))
    x₂
    y₂,
h :
  @eq.{v+1} L
    (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          x₂)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y₁
          y₂))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x₁
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₂ y₂))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
          y₂))
⊢ @has_mem.mem.{v v} L
    (@submodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{v} L (@add_group_has_sub.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) x₁ y₁)
       y₂)
    (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>384  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>385  @[simp] lemma mk_bracket (x y : L) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>386    (mk ⁅x, y⁆ : quotient I) = ⁅mk x, mk y⁆ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_submodule.quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_submodule.quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_submodule.quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lie_submodule.quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_bracket.bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 369, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 359, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 369, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 369, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6}, M → @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6}, M → @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6}, M → @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {L : Type v} [c : has_bracket.{v} L], L → L → L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Map sending an element of `M` to the corresponding element of `M/N`, when `N` is a lie_submodule of
the lie_module `N`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The quotient of a Lie module by a Lie submodule. It is a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Map sending an element of `M` to the corresponding element of `M/N`, when `N` is a lie_submodule of
the lie_module `N`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Map sending an element of `M` to the corresponding element of `M/N`, when `N` is a lie_submodule of
the lie_module `N`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>387  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>388  instance lie_quotient_lie_algebra : lie_algebra R (quotient I) := {</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lie_submodule.quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 359, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5], @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The quotient of a Lie module by a Lie submodule. It is a Lie module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>389    add_lie  := by { intros x&#x27; y&#x27; z&#x27;, apply quotient.induction_on₃&#x27; x&#x27; y&#x27; z&#x27;, intros x y z,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='quotient.induction_on₃&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 264, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type v} {s₁ : setoid.{v+1} α} {s₂ : setoid.{v+1} β} {s₃ : setoid.{v+1} γ} {p : @quotient.{v+1} α s₁ → @quotient.{v+1} β s₂ → @quotient.{v+1} γ s₃ → Prop} (q₁ : @quotient.{v+1} α s₁) (q₂ : @quotient.{v+1} β s₂) (q₃ : @quotient.{v+1} γ s₃), (∀ (a₁ : α) (a₂ : β) (a₃ : γ), p (@quotient.mk&#x27;.{v+1} α s₁ a₁) (@quotient.mk&#x27;.{v+1} β s₂ a₂) (@quotient.mk&#x27;.{v+1} γ s₃ a₃)) → p q₁ q₂ q₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x y z :
    @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
      I),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         (@has_add.add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_semigroup.to_has_add.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_monoid.to_add_semigroup.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_group.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_group.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))))
            x
            y)
         z)
      (@has_add.add.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_semigroup.to_has_add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_monoid.to_add_semigroup.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_group.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_group.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            x
            z)
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            y
            z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          x&#x27;
          y&#x27;)
       z&#x27;)
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          x&#x27;
          z&#x27;)
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          y&#x27;
          z&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ ∀ (a₁ a₂ a₃ : L),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         (@has_add.add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_semigroup.to_has_add.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_monoid.to_add_semigroup.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_group.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_group.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))))
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₁)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₂))
         (@quotient.mk&#x27;.{v+1} L
            (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            a₃))
      (@has_add.add.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_semigroup.to_has_add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_monoid.to_add_semigroup.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_group.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_group.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₁)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₃))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₂)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₃)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y))
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>390                     repeat { rw is_quotient_mk &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='lie_submodule.quotient.is_quotient_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 371, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6} (m : M), @eq.{v+1} (@quotient.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N))) (@quotient.mk&#x27;.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N)) m) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y))
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>391                              rw ←mk_bracket &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='lie_submodule.quotient.mk_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 385, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3} (x y : L), @eq.{v+1} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I x) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y))
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>392                              rw ←submodule.quotient.mk_add, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='submodule.quotient.mk_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 810, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] (p : @submodule.{u v} R M _inst_1 _inst_2 _inst_5) {x y : M}, @eq.{v+1} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p (@has_add.add.{v} M (@add_semigroup.to_has_add.{v} M (@add_monoid.to_add_semigroup.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) x y)) (@has_add.add.{v} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.has_add.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p x) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y))
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y))
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             x
             y)
          z))
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             z)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>393                     apply congr_arg, apply add_lie, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='add_lie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y) z) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x z) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             x
             y)
          z))
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             z)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          x
          y)
       z)
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          z)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          y
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>394    lie_add  := by { intros x&#x27; y&#x27; z&#x27;, apply quotient.induction_on₃&#x27; x&#x27; y&#x27; z&#x27;, intros x y z,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='quotient.induction_on₃&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 264, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type v} {s₁ : setoid.{v+1} α} {s₂ : setoid.{v+1} β} {s₃ : setoid.{v+1} γ} {p : @quotient.{v+1} α s₁ → @quotient.{v+1} β s₂ → @quotient.{v+1} γ s₃ → Prop} (q₁ : @quotient.{v+1} α s₁) (q₂ : @quotient.{v+1} β s₂) (q₃ : @quotient.{v+1} γ s₃), (∀ (a₁ : α) (a₂ : β) (a₃ : γ), p (@quotient.mk&#x27;.{v+1} α s₁ a₁) (@quotient.mk&#x27;.{v+1} β s₂ a₂) (@quotient.mk&#x27;.{v+1} γ s₃ a₃)) → p q₁ q₂ q₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x y z :
    @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
      I),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         z
         (@has_add.add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_semigroup.to_has_add.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_monoid.to_add_semigroup.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_group.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_group.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))))
            x
            y))
      (@has_add.add.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_semigroup.to_has_add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_monoid.to_add_semigroup.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_group.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_group.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            z
            x)
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            z
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       z&#x27;
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          x&#x27;
          y&#x27;))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          z&#x27;
          x&#x27;)
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          z&#x27;
          y&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ ∀ (a₁ a₂ a₃ : L),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         (@quotient.mk&#x27;.{v+1} L
            (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            a₃)
         (@has_add.add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_semigroup.to_has_add.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_monoid.to_add_semigroup.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_group.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_group.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))))
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₁)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₂)))
      (@has_add.add.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_semigroup.to_has_add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_monoid.to_add_semigroup.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_group.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_group.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₃)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₁))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₃)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>395                     repeat { rw is_quotient_mk &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='lie_submodule.quotient.is_quotient_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 371, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6} (m : M), @eq.{v+1} (@quotient.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N))) (@quotient.mk&#x27;.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N)) m) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>396                              rw ←mk_bracket &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='lie_submodule.quotient.mk_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 385, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3} (x y : L), @eq.{v+1} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I x) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>397                              rw ←submodule.quotient.mk_add, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='submodule.quotient.mk_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 810, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] (p : @submodule.{u v} R M _inst_1 _inst_2 _inst_5) {x y : M}, @eq.{v+1} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p (@has_add.add.{v} M (@add_semigroup.to_has_add.{v} M (@add_monoid.to_add_semigroup.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) x y)) (@has_add.add.{v} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.has_add.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p x) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          z)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          z)
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I
             z)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             x
             y)))
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             x)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>398                     apply congr_arg, apply lie_add, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) x y)) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z x) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) z y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             x
             y)))
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             x)
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       z
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          x
          y))
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          x)
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>399    lie_self := by { intros x&#x27;, apply quotient.induction_on&#x27; x&#x27;, intros x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='quotient.induction_on&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 255, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {s₁ : setoid.{v+1} α} {p : @quotient.{v+1} α s₁ → Prop} (q : @quotient.{v+1} α s₁), (∀ (a : α), p (@quotient.mk&#x27;.{v+1} α s₁ a)) → p q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x :
    @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
      I),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         x
         x)
      (@has_zero.zero.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_monoid.to_has_zero.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_group.to_add_monoid.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_comm_group.to_add_group.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       x&#x27;
       x&#x27;)
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ ∀ (a : L),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         (@quotient.mk&#x27;.{v+1} L
            (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            a)
         (@quotient.mk&#x27;.{v+1} L
            (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            a))
      (@has_zero.zero.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_monoid.to_has_zero.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_group.to_add_monoid.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_comm_group.to_add_group.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>400                     rw [is_quotient_mk, ←mk_bracket],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='lie_submodule.quotient.is_quotient_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lie_submodule.quotient.mk_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 371, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 385, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6} (m : M), @eq.{v+1} (@quotient.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N))) (@quotient.mk&#x27;.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N)) m) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3} (x y : L), @eq.{v+1} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I x) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          x)
       (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          x))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          x))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>401                     apply congr_arg, apply lie_self, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 107, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [_inst_2 : @lie_ring.{v} L _inst_1] (x : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 _inst_2) x x) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          x))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x
       x)
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>402    jacobi   := by { intros x&#x27; y&#x27; z&#x27;, apply quotient.induction_on₃&#x27; x&#x27; y&#x27; z&#x27;, intros x y z,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='quotient.induction_on₃&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 264, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type v} {s₁ : setoid.{v+1} α} {s₂ : setoid.{v+1} β} {s₃ : setoid.{v+1} γ} {p : @quotient.{v+1} α s₁ → @quotient.{v+1} β s₂ → @quotient.{v+1} γ s₃ → Prop} (q₁ : @quotient.{v+1} α s₁) (q₂ : @quotient.{v+1} β s₂) (q₃ : @quotient.{v+1} γ s₃), (∀ (a₁ : α) (a₂ : β) (a₃ : γ), p (@quotient.mk&#x27;.{v+1} α s₁ a₁) (@quotient.mk&#x27;.{v+1} β s₂ a₂) (@quotient.mk&#x27;.{v+1} γ s₃ a₃)) → p q₁ q₂ q₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀
  (x y z :
    @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
      I),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_add.add.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_semigroup.to_has_add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_monoid.to_add_semigroup.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_group.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_group.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))))
         (@has_add.add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_semigroup.to_has_add.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_monoid.to_add_semigroup.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_group.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_group.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))))
            (@has_bracket.bracket.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
               x
               (@has_bracket.bracket.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                  y
                  z))
            (@has_bracket.bracket.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
               y
               (@has_bracket.bracket.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                  z
                  x)))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            z
            (@has_bracket.bracket.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
               x
               y)))
      (@has_zero.zero.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_monoid.to_has_zero.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_group.to_add_monoid.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_comm_group.to_add_group.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             x&#x27;
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                y&#x27;
                z&#x27;))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             y&#x27;
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                z&#x27;
                x&#x27;)))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          z&#x27;
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             x&#x27;
             y&#x27;)))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ ∀ (a₁ a₂ a₃ : L),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_add.add.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_semigroup.to_has_add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_monoid.to_add_semigroup.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_group.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_group.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))))
         (@has_add.add.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_semigroup.to_has_add.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_monoid.to_add_semigroup.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_group.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_group.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))))
            (@has_bracket.bracket.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
               (@quotient.mk&#x27;.{v+1} L
                  (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))
                  a₁)
               (@has_bracket.bracket.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                  (@quotient.mk&#x27;.{v+1} L
                     (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))
                     a₂)
                  (@quotient.mk&#x27;.{v+1} L
                     (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))
                     a₃)))
            (@has_bracket.bracket.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
               (@quotient.mk&#x27;.{v+1} L
                  (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))
                  a₂)
               (@has_bracket.bracket.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                  (@quotient.mk&#x27;.{v+1} L
                     (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))
                     a₃)
                  (@quotient.mk&#x27;.{v+1} L
                     (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))
                     a₁))))
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₃)
            (@has_bracket.bracket.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
               (@quotient.mk&#x27;.{v+1} L
                  (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))
                  a₁)
               (@quotient.mk&#x27;.{v+1} L
                  (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))
                  a₂))))
      (@has_zero.zero.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@add_monoid.to_has_zero.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@add_group.to_add_monoid.{v}
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@add_comm_group.to_add_group.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   y)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   x))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y))))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>403                     repeat { rw is_quotient_mk &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='lie_submodule.quotient.is_quotient_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 371, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6} (m : M), @eq.{v+1} (@quotient.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N))) (@quotient.mk&#x27;.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N)) m) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   y)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   x))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y))))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>404                              rw ←mk_bracket &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='lie_submodule.quotient.mk_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 385, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3} (x y : L), @eq.{v+1} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I x) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   y)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   x))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y))))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>405                              rw ←submodule.quotient.mk_add, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='submodule.quotient.mk_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 810, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] (p : @submodule.{u v} R M _inst_1 _inst_2 _inst_5) {x y : M}, @eq.{v+1} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p (@has_add.add.{v} M (@add_semigroup.to_has_add.{v} M (@add_monoid.to_add_semigroup.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) x y)) (@has_add.add.{v} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.has_add.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p x) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   y)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   x))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                x)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y))))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_add.add.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_semigroup.to_has_add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_monoid.to_add_semigroup.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_group.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_group.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))))
       (@has_add.add.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_semigroup.to_has_add.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_monoid.to_add_semigroup.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_group.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_group.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I
                x)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   y)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)))
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y)
             (@has_bracket.bracket.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
                (@quotient.mk&#x27;.{v+1} L
                   (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   z)
                (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I
                   x))))
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             z)
          (@has_bracket.bracket.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
             (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I
                x)
             (@quotient.mk&#x27;.{v+1} L
                (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))
                y))))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   y
                   z))
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                y
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   z
                   x)))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x
                y))))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>406                     apply congr_arg, apply lie_ring.jacobi, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_ring.jacobi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {L : Type v} [_inst_1 : add_comm_group.{v} L] [c : @lie_ring.{v} L _inst_1] (x y z : L), @eq.{v+1} L (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_add.add.{v} L (@add_semigroup.to_has_add.{v} L (@add_monoid.to_add_semigroup.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1)))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) y z)) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) y (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z x))) (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) z (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_1 c) x y))) (@has_zero.zero.{v} L (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_add.add.{v} L
             (@add_semigroup.to_has_add.{v} L
                (@add_monoid.to_add_semigroup.{v} L
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   y
                   z))
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                y
                (@has_bracket.bracket.{v} L
                   (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                   z
                   x)))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             z
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                x
                y))))
    (@has_zero.zero.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@add_monoid.to_has_zero.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@add_group.to_add_monoid.{v}
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@add_comm_group.to_add_group.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
x&#x27; y&#x27; z&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y z : L
⊢ @eq.{v+1} L
    (@has_add.add.{v} L
       (@add_semigroup.to_has_add.{v} L
          (@add_monoid.to_add_semigroup.{v} L
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
       (@has_add.add.{v} L
          (@add_semigroup.to_has_add.{v} L
             (@add_monoid.to_add_semigroup.{v} L
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                y
                z))
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             y
             (@has_bracket.bracket.{v} L
                (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
                z
                x)))
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          z
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))
    (@has_zero.zero.{v} L
       (@add_monoid.to_has_zero.{v} L (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>407    lie_smul := by { intros t x&#x27; y&#x27;, apply quotient.induction_on₂&#x27; x&#x27; y&#x27;, intros x y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='quotient.induction_on₂&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {s₁ : setoid.{v+1} α} {s₂ : setoid.{v+1} β} {p : @quotient.{v+1} α s₁ → @quotient.{v+1} β s₂ → Prop} (q₁ : @quotient.{v+1} α s₁) (q₂ : @quotient.{v+1} β s₂), (∀ (a₁ : α) (a₂ : β), p (@quotient.mk&#x27;.{v+1} α s₁ a₁) (@quotient.mk&#x27;.{v+1} β s₂ a₂)) → p q₁ q₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3
⊢ ∀ (t : R)
  (x y :
    @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
      I),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         x
         (@has_scalar.smul.{u v} R
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@mul_action.to_has_scalar.{u v} R
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
               (@distrib_mul_action.to_mul_action.{u v} R
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                  (@add_comm_monoid.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_comm_monoid.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))
                  (@semimodule.to_distrib_mul_action.{u v} R
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_comm_group.to_add_comm_monoid.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I)))
                     (@module.to_semimodule.{u v} R
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))
                        (@module.mk.{u v} R
                           (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I))
                           (@module.to_semimodule.{u v} R
                              (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    I))
                              (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    I))))))))
            t
            y))
      (@has_scalar.smul.{u v} R
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@mul_action.to_has_scalar.{u v} R
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
            (@distrib_mul_action.to_mul_action.{u v} R
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
               (@add_comm_monoid.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_comm_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))
               (@semimodule.to_distrib_mul_action.{u v} R
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@add_comm_group.to_add_comm_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)))
                  (@module.to_semimodule.{u v} R
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@comm_ring.to_ring.{u} R _inst_1)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))
                     (@module.mk.{u v} R
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))
                        (@module.to_semimodule.{u v} R
                           (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I))
                           (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I))))))))
         t
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            x
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       x&#x27;
       (@has_scalar.smul.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@mul_action.to_has_scalar.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)))
                   (@module.to_semimodule.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.mk.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@module.to_semimodule.{u v} R
                            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))
                            (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))))))))
          t
          y&#x27;))
    (@has_scalar.smul.{u v} R
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@mul_action.to_has_scalar.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)))
                (@module.to_semimodule.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   (@module.mk.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.to_semimodule.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))))))))
       t
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          x&#x27;
          y&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I
⊢ ∀ (a₁ a₂ : L),
    @eq.{v+1}
      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
         I)
      (@has_bracket.bracket.{v}
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
         (@quotient.mk&#x27;.{v+1} L
            (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I))
            a₁)
         (@has_scalar.smul.{u v} R
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@mul_action.to_has_scalar.{u v} R
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
               (@distrib_mul_action.to_mul_action.{u v} R
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                  (@add_comm_monoid.to_add_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@add_comm_group.to_add_comm_monoid.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))))
                  (@semimodule.to_distrib_mul_action.{u v} R
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                     (@add_comm_group.to_add_comm_monoid.{v}
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I)))
                     (@module.to_semimodule.{u v} R
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))
                        (@module.mk.{u v} R
                           (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I))
                           (@module.to_semimodule.{u v} R
                              (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I)
                              (@comm_ring.to_ring.{u} R _inst_1)
                              (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    I))
                              (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                    I))))))))
            t
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₂)))
      (@has_scalar.smul.{u v} R
         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
            I)
         (@mul_action.to_has_scalar.{u v} R
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
            (@distrib_mul_action.to_mul_action.{u v} R
               (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  I)
               (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
               (@add_comm_monoid.to_add_monoid.{v}
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@add_comm_group.to_add_comm_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))))
               (@semimodule.to_distrib_mul_action.{u v} R
                  (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I)
                  (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                  (@add_comm_group.to_add_comm_monoid.{v}
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)))
                  (@module.to_semimodule.{u v} R
                     (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        I)
                     (@comm_ring.to_ring.{u} R _inst_1)
                     (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                        (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                        (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I))
                     (@module.mk.{u v} R
                        (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           I)
                        (@comm_ring.to_ring.{u} R _inst_1)
                        (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                           (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                           (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I))
                        (@module.to_semimodule.{u v} R
                           (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              I)
                           (@comm_ring.to_ring.{u} R _inst_1)
                           (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I))
                           (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                              (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                              (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                 I))))))))
         t
         (@has_bracket.bracket.{v}
            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
               I)
            (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₁)
            (@quotient.mk&#x27;.{v+1} L
               (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                  (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                     (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                     I))
               a₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x)
       (@has_scalar.smul.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@mul_action.to_has_scalar.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)))
                   (@module.to_semimodule.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.mk.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@module.to_semimodule.{u v} R
                            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))
                            (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))))))))
          t
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_scalar.smul.{u v} R
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@mul_action.to_has_scalar.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)))
                (@module.to_semimodule.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   (@module.mk.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.to_semimodule.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))))))))
       t
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>408                     repeat { rw is_quotient_mk &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='lie_submodule.quotient.is_quotient_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 371, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {M : Type v} [_inst_4 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4] [_inst_6 : @lie_module.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5] {N : @lie_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6} (m : M), @eq.{v+1} (@quotient.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N))) (@quotient.mk&#x27;.{v+1} M (@submodule.quotient_rel.{u v} R M (@comm_ring.to_ring.{u} R _inst_1) _inst_4 _inst_5 (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N)) m) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 M _inst_4 _inst_5 _inst_6 N m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x)
       (@has_scalar.smul.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@mul_action.to_has_scalar.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)))
                   (@module.to_semimodule.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.mk.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@module.to_semimodule.{u v} R
                            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))
                            (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))))))))
          t
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_scalar.smul.{u v} R
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@mul_action.to_has_scalar.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)))
                (@module.to_semimodule.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   (@module.mk.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.to_semimodule.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))))))))
       t
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>409                              rw ←mk_bracket &lt;|&gt;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='lie_submodule.quotient.mk_bracket'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 385, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] {I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3} (x y : L), @eq.{v+1} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y)) (@has_bracket.bracket.{v} (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I) (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I x) (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3) (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3) I y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x)
       (@has_scalar.smul.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@mul_action.to_has_scalar.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)))
                   (@module.to_semimodule.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.mk.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@module.to_semimodule.{u v} R
                            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))
                            (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))))))))
          t
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_scalar.smul.{u v} R
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@mul_action.to_has_scalar.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)))
                (@module.to_semimodule.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   (@module.mk.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.to_semimodule.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))))))))
       t
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>410                              rw ←submodule.quotient.mk_smul, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='submodule.quotient.mk_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 827, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} {M : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] (p : @submodule.{u v} R M _inst_1 _inst_2 _inst_5) {r : R} {x : M}, @eq.{v+1} (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p (@has_scalar.smul.{u v} R M (@mul_action.to_has_scalar.{u v} R M (@ring.to_monoid.{u} R _inst_1) (@distrib_mul_action.to_mul_action.{u v} R M (@ring.to_monoid.{u} R _inst_1) (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R M (@ring.to_semiring.{u} R _inst_1) (@add_comm_group.to_add_comm_monoid.{v} M _inst_2) (@module.to_semimodule.{u v} R M _inst_1 _inst_2 _inst_5)))) r x)) (@has_scalar.smul.{u v} R (@submodule.quotient.{u v} R M _inst_1 _inst_2 _inst_5 p) (@submodule.quotient.has_scalar.{u v} R M _inst_1 _inst_2 _inst_5 p) r (@submodule.quotient.mk.{u v} R M _inst_1 _inst_2 _inst_5 p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@quotient.mk&#x27;.{v+1} L
          (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I))
          x)
       (@has_scalar.smul.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@mul_action.to_has_scalar.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)))
                   (@module.to_semimodule.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.mk.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@module.to_semimodule.{u v} R
                            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))
                            (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))))))))
          t
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_scalar.smul.{u v} R
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@mul_action.to_has_scalar.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)))
                (@module.to_semimodule.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   (@module.mk.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.to_semimodule.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))))))))
       t
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@has_bracket.bracket.{v}
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
       (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I
          x)
       (@has_scalar.smul.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@mul_action.to_has_scalar.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@distrib_mul_action.to_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
                (@add_comm_monoid.to_add_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))))
                (@semimodule.to_distrib_mul_action.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v}
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)))
                   (@module.to_semimodule.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.mk.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@module.to_semimodule.{u v} R
                            (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I)
                            (@comm_ring.to_ring.{u} R _inst_1)
                            (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))
                            (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                                  (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                                  I))))))))
          t
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))
    (@has_scalar.smul.{u v} R
       (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@mul_action.to_has_scalar.{u v} R
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
          (@distrib_mul_action.to_mul_action.{u v} R
             (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                I)
             (@semiring.to_monoid.{u} R (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)))
             (@add_comm_monoid.to_add_monoid.{v}
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))))
             (@semimodule.to_distrib_mul_action.{u v} R
                (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I)
                (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v}
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)))
                (@module.to_semimodule.{u v} R
                   (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      I)
                   (@comm_ring.to_ring.{u} R _inst_1)
                   (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                      (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I))
                   (@module.mk.{u v} R
                      (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         I)
                      (@comm_ring.to_ring.{u} R _inst_1)
                      (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                         (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I))
                      (@module.to_semimodule.{u v} R
                         (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            I)
                         (@comm_ring.to_ring.{u} R _inst_1)
                         (@submodule.quotient.add_comm_group.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))
                         (@submodule.quotient.module.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                            (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                            (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                               (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                               I))))))))
       t
       (@has_bracket.bracket.{v}
          (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I)
          (@lie_submodule.quotient.lie_quotient_has_bracket.{u v} R L _inst_1 _inst_2 _inst_3 I)
          (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
             (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
             (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
             I
             x)
          (@quotient.mk&#x27;.{v+1} L
             (@submodule.quotient_rel.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
                   I))
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_scalar.smul.{u v} R L
             (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                   (@semimodule.to_distrib_mul_action.{u v} R L
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                      (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
             t
             y)))
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_scalar.smul.{u v} R L
          (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                (@semimodule.to_distrib_mul_action.{u v} R L
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                   (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
          t
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>411                     apply congr_arg, apply lie_smul, } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lie_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 173, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L] [_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2] (t : R) (x y : L), @eq.{v+1} L (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))) t y)) (@has_scalar.smul.{u v} R L (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2)) (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1)) (@add_comm_group.to_add_comm_monoid.{v} L _inst_2) (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2 (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3))))) t (@has_bracket.bracket.{v} L (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3)) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1}
    (@lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I)
    (@lie_submodule.quotient.mk.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
       I
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          (@has_scalar.smul.{u v} R L
             (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                   (@semimodule.to_distrib_mul_action.{u v} R L
                      (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                      (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                      (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                         (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
             t
             y)))
    (@submodule.quotient.mk.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
       (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
       (@lie_submodule.to_submodule.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
          (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
          (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
          I)
       (@has_scalar.smul.{u v} R L
          (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                (@semimodule.to_distrib_mul_action.{u v} R L
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                   (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
          t
          (@has_bracket.bracket.{v} L
             (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
L : Type v,
_inst_1 : comm_ring.{u} R,
_inst_2 : add_comm_group.{v} L,
_inst_3 : @lie_algebra.{u v} R L _inst_1 _inst_2,
I : @lie_ideal.{u v} R L _inst_1 _inst_2 _inst_3,
t : R,
x&#x27; y&#x27; :
  @lie_submodule.quotient.{u v} R L _inst_1 _inst_2 _inst_3 L _inst_2
    (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)
    (@lie_algebra_self_module.{u v} R L _inst_1 _inst_2 _inst_3)
    I,
x y : L
⊢ @eq.{v+1} L
    (@has_bracket.bracket.{v} L
       (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
       x
       (@has_scalar.smul.{u v} R L
          (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
                (@semimodule.to_distrib_mul_action.{u v} R L
                   (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                   (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                   (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                      (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
          t
          y))
    (@has_scalar.smul.{u v} R L
       (@mul_action.to_has_scalar.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
          (@distrib_mul_action.to_mul_action.{u v} R L (@ring.to_monoid.{u} R (@comm_ring.to_ring.{u} R _inst_1))
             (@add_group.to_add_monoid.{v} L (@add_comm_group.to_add_group.{v} L _inst_2))
             (@semimodule.to_distrib_mul_action.{u v} R L (@ring.to_semiring.{u} R (@comm_ring.to_ring.{u} R _inst_1))
                (@add_comm_group.to_add_comm_monoid.{v} L _inst_2)
                (@module.to_semimodule.{u v} R L (@comm_ring.to_ring.{u} R _inst_1) _inst_2
                   (@lie_algebra.to_module.{u v} R L _inst_1 _inst_2 _inst_3)))))
       t
       (@has_bracket.bracket.{v} L
          (@lie_ring.to_has_bracket.{v} L _inst_2 (@lie_algebra.to_lie_ring.{u v} R L _inst_1 _inst_2 _inst_3))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>412  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>413  end quotient</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>414  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>415  end lie_submodule</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>416  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>417  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>418  An important class of Lie algebras are those arising from the associative algebra structure on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>419  square matrices over a commutative ring.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>420  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>421  def matrix.lie_algebra (n : Type u) (R : Type v)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>422    [fintype n] [decidable_eq n] [comm_ring R] : lie_algebra R (matrix n n R) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lie_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (R : Type u) (L : Type v) [_inst_1 : comm_ring.{u} R] [_inst_2 : add_comm_group.{v} L], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi
identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>423  lie_algebra.of_associative_algebra (matrix n n R)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lie_algebra.of_associative_algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} [_inst_1 : comm_ring.{u} R] (A : Type v) [_inst_4 : ring.{v} A] [_inst_5 : @algebra.{u v} R A _inst_1 _inst_4], @lie_algebra.{u v} R A _inst_1 (@ring.to_add_comm_group.{v} A _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An associative algebra gives rise to a Lie algebra by taking the bracket to be the ring commutator.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font></pre>
</body>