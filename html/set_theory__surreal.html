<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Mario Carneiro. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Mario Carneiro, Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import set_theory.pgame</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  # Surreal numbers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  The basic theory of surreal numbers, built on top of the theory of combinatorial (pre-)games.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  A pregame is `numeric` if all the Left options are strictly smaller than all the Right options,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  and all those options are themselves numeric. In terms of combinatorial games, the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  numeric games have &quot;frozen&quot;; you can only make your position worse by playing, and Left is some</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  definite &quot;number&quot; of moves ahead (or behind) Right.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  A surreal number is an equivalence class of numeric pregames.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  In fact, the surreals form a complete ordered field, containing a copy of the reals (and much else besides!)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  but we do not yet have a complete development.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  ## Order properties</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  Surreal numbers inherit the relations `≤` and `&lt;` from games, and these relations</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  satisfy the axioms of a partial order (recall that `x &lt; y ↔ x ≤ y ∧ ¬ y ≤ x` did not hold for games).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  ## Algebraic operations</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  At this point, we have defined addition and negation (from pregames), and shown that surreals</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  form an additive semigroup. It would be very little work to finish showing that the surreals form</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  an ordered commutative group.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  We define the operations of multiplication and inverse on surreals, but do not yet establish any of the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  necessary properties to show the surreals form an ordered field.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  ## Embeddings</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  It would be nice projects to define the group homomorphism `surreal → game`, and also</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  `ℤ → surreal`, and then the homomorphic inclusion of the dyadic rationals into surreals, and finally</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  via dyadic Dedekind cuts the homomorphic inclusion of the reals into the surreals.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  One can also map all the cardinals into the surreals!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  ## References</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  * [Conway, *On numbers and games*][conway2001]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  universes u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  namespace pgame</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  /- Multiplicative operations can be defined at the level of pre-games, but as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  they are only useful on surreal numbers, we define them here. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  /-- The product of `x = {xL | xR}` and `y = {yL | yR}` is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    `{xL*y + x*yL - xL*yL, xR*y + x*yR - xR*yR | xL*y + x*yR - xL*yR, x*yL + xR*y - xR*yL }`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  def mul (x y : pgame) : pgame :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{?l_1},
y : pgame.{?l_2}
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    induction x with xl xr xL xR IHxl IHxr generalizing y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{?l_1},
y : pgame.{?l_2}
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xR a),
y : pgame.{?l_2}
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    induction y with yl yr yL yR IHyl IHyr,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xR a),
y : pgame.{?l_2}
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yR a)
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    have y := mk yl yr yL yR,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pgame.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='yL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='yR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β : Type u_2), (α → pgame.{u_2}) → (β → pgame.{u_2}) → pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl → pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr → pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yR a)
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yR a),
y : pgame.{?l_2}
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    refine ⟨xl × yl ⊕ xr × yr, xl × yr ⊕ xr × yl, _, _⟩; rintro (⟨i, j⟩ | ⟨i, j⟩),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (max u_1 u_2) → Type (max u_1 u_2) → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{?l_3}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{?l_3}) (yR a),
y : pgame.{?l_2}
⊢ pgame.{?l_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    { exact IHxl i y + IHyl j - IHxl i (yL j) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHyl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHxl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ((max u_1 u_2)+1)} [c : has_add.{(max u_1 u_2)+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : yl), (λ (y : pgame.{u_2}), pgame.{(max u_1 u_2)}) (yL a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ((max u_1 u_2)+1)} [c : has_sub.{(max u_1 u_2)+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : xl), (λ (x : pgame.{u_1}), pgame.{u_2} → pgame.{(max u_1 u_2)}) (xL a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='yl → pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    { exact IHxr i y + IHyr j - IHxr i (yR j) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='IHyr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='IHxr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : yr), (λ (y : pgame.{u_2}), pgame.{(max u_1 u_2)}) (yR a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : xr), (λ (x : pgame.{u_1}), pgame.{u_2} → pgame.{(max u_1 u_2)}) (xR a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='yr → pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    { exact IHxl i y + IHyr j - IHxl i (yR j) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='IHyr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='IHxl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : yr), (λ (y : pgame.{u_2}), pgame.{(max u_1 u_2)}) (yR a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : xl), (λ (x : pgame.{u_1}), pgame.{u_2} → pgame.{(max u_1 u_2)}) (xL a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='yr → pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}

xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xl,
j : yr
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    { exact IHxr i y + IHyl j - IHxr i (yL j) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='IHyl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='IHxr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : yl), (λ (y : pgame.{u_2}), pgame.{(max u_1 u_2)}) (yL a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (a : xr), (λ (x : pgame.{u_1}), pgame.{u_2} → pgame.{(max u_1 u_2)}) (xR a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='yl → pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xL a),
IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_2} → pgame.{(max ?l_1 ?l_2)}) (xR a),
yl yr : Type ?l_2,
yL : yl → pgame.{?l_2},
yR : yr → pgame.{?l_2},
IHyl : Π (a : yl), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yL a),
IHyr : Π (a : yr), (λ (y : pgame.{?l_2}), pgame.{(max ?l_1 ?l_2)}) (yR a),
y : pgame.{?l_2},
i : xr,
j : yl
⊢ pgame.{(max ?l_1 ?l_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  instance : has_mul pgame := ⟨mul⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_1} → pgame.{u_2} → pgame.{(max u_1 u_2)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The product of `x = {xL | xR}` and `y = {yL | yR}` is
 `{xL*y + x*yL - xL*yL, xR*y + x*yR - xR*yR | xL*y + x*yR - xL*yR, x*yL + xR*y - xR*yL }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  /-- Because the two halves of the definition of inv produce more elements</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70    of each side, we have to define the two families inductively.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    This is the indexing set for the function, and `inv_val` is the function part. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  inductive inv_ty (l r : Type u) : bool → Type u</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  | zero {} : inv_ty ff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  | left₁ : r → inv_ty ff → inv_ty ff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='inv_ty bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  | left₂ : l → inv_ty tt → inv_ty ff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='inv_ty bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  | right₁ : l → inv_ty ff → inv_ty tt</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='inv_ty bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  | right₂ : r → inv_ty tt → inv_ty tt</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='inv_ty bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  /-- Because the two halves of the definition of inv produce more elements</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    of each side, we have to define the two families inductively.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    This is the function part, defined by recursion on `inv_ty`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  def inv_val {l r} (L : l → pgame) (R : r → pgame)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    (IHl : l → pgame) (IHr : r → pgame) : ∀ {b}, inv_ty l r b → pgame</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='inv_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.inv_ty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {b : bool}, pgame.inv_ty.{u_1} l r b → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u → bool → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Because the two halves of the definition of inv produce more elements
 of each side, we have to define the two families inductively.
 This is the indexing set for the function, and `inv_val` is the function part.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  | _ inv_ty.zero := 0</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.inv_ty.zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {l r : Type u_1}, pgame.inv_ty.{u_1} l r bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  | _ (inv_ty.left₁ i j) := (1 + (R i - mk l r L R) * inv_val j) * IHr i</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.inv_ty.left₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {l r : Type u_1}, r → pgame.inv_ty.{u_1} l r bool.ff → pgame.inv_ty.{u_1} l r bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.inv_ty.{u_1} l r bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_sub.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β : Type u), (α → pgame.{u}) → (β → pgame.{u}) → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {b : bool}, pgame.inv_ty.{u_1} l r b → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  | _ (inv_ty.left₂ i j) := (1 + (L i - mk l r L R) * inv_val j) * IHl i</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.inv_ty.left₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {l r : Type u_1}, l → pgame.inv_ty.{u_1} l r bool.tt → pgame.inv_ty.{u_1} l r bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.inv_ty.{u_1} l r bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_sub.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β : Type u), (α → pgame.{u}) → (β → pgame.{u}) → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {b : bool}, pgame.inv_ty.{u_1} l r b → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  | _ (inv_ty.right₁ i j) := (1 + (L i - mk l r L R) * inv_val j) * IHl i</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.inv_ty.right₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {l r : Type u_1}, l → pgame.inv_ty.{u_1} l r bool.ff → pgame.inv_ty.{u_1} l r bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.inv_ty.{u_1} l r bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_sub.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β : Type u), (α → pgame.{u}) → (β → pgame.{u}) → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {b : bool}, pgame.inv_ty.{u_1} l r b → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  | _ (inv_ty.right₂ i j) := (1 + (R i - mk l r L R) * inv_val j) * IHr i</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.inv_ty.right₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {l r : Type u_1}, r → pgame.inv_ty.{u_1} l r bool.tt → pgame.inv_ty.{u_1} l r bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.inv_ty.{u_1} l r bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_sub.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β : Type u), (α → pgame.{u}) → (β → pgame.{u}) → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {b : bool}, pgame.inv_ty.{u_1} l r b → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  /-- The inverse of a positive surreal number `x = {L | R}` is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    given by `x⁻¹ = {0,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92      (1 + (R - x) * x⁻¹L) * R, (1 + (L - x) * x⁻¹R) * L |</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      (1 + (L - x) * x⁻¹L) * L, (1 + (R - x) * x⁻¹R) * R}`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    Because the two halves `x⁻¹L, x⁻¹R` of `x⁻¹` are used in their own</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    definition, the sets and elements are inductively generated. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  def inv&#x27; : pgame → pgame</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1} → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  | ⟨l, r, L, R⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    let l&#x27; := {i // 0 &lt; L i},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99        L&#x27; : l&#x27; → pgame := λ i, L i.1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l&#x27; → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100        IHl&#x27; : l&#x27; → pgame := λ i, inv&#x27; (L i.1),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHl&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='inv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l&#x27; → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101        IHr := λ i, inv&#x27; (R i) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='IHr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='inv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    ⟨inv_ty l&#x27; r ff, inv_ty l&#x27; r tt,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.inv_ty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.inv_ty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u → bool → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u → bool → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Because the two halves of the definition of inv produce more elements
 of each side, we have to define the two families inductively.
 This is the indexing set for the function, and `inv_val` is the function part.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Because the two halves of the definition of inv produce more elements
 of each side, we have to define the two families inductively.
 This is the indexing set for the function, and `inv_val` is the function part.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103      inv_val L&#x27; R IHl&#x27; IHr, inv_val L&#x27; R IHl&#x27; IHr⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.inv_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='IHl&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.inv_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='IHl&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='IHr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 82, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 82, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {l r : Type u_1}, (l → pgame.{u_1}) → (r → pgame.{u_1}) → (l → pgame.{u_1}) → (r → pgame.{u_1}) → Π {b : bool}, pgame.inv_ty.{u_1} l r b → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l&#x27; → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='l&#x27; → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {l r : Type u_1}, (l → pgame.{u_1}) → (r → pgame.{u_1}) → (l → pgame.{u_1}) → (r → pgame.{u_1}) → Π {b : bool}, pgame.inv_ty.{u_1} l r b → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l&#x27; → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='l&#x27; → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Because the two halves of the definition of inv produce more elements
 of each side, we have to define the two families inductively.
 This is the function part, defined by recursion on `inv_ty`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Because the two halves of the definition of inv produce more elements
 of each side, we have to define the two families inductively.
 This is the function part, defined by recursion on `inv_ty`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  /-- The inverse of a surreal number in terms of the inverse on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    positive surreals. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  noncomputable def inv (x : pgame) : pgame :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  by classical; exact</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='x : pgame.{?l_1}
⊢ pgame.{?l_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  if x = 0 then 0 else if 0 &lt; x then inv&#x27; x else inv&#x27; (-x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='pgame.inv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1} → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_neg.{u_1+1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The inverse of a positive surreal number `x = {L | R}` is
 given by `x⁻¹ = {0,
   (1 + (R - x) * x⁻¹L) * R, (1 + (L - x) * x⁻¹R) * L |
   (1 + (L - x) * x⁻¹L) * L, (1 + (R - x) * x⁻¹R) * R}`.
 Because the two halves `x⁻¹L, x⁻¹R` of `x⁻¹` are used in their own
 definition, the sets and elements are inductively generated.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{?l_1}
⊢ pgame.{?l_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{?l_1}
⊢ pgame.{?l_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  noncomputable instance : has_inv pgame := ⟨inv⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='has_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 107, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_1} → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The inverse of a surreal number in terms of the inverse on
 positive surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  noncomputable instance : has_div pgame := ⟨λ x y, x * y⁻¹⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='has_div'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_mul.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_inv.{u_1+1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  /-- A pre-game is numeric if</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    everything in the L set is less than everything in the R set,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    and all the elements of L and R are also numeric. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  def numeric : pgame → Prop</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  | ⟨l, r, L, R⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    (∀ i j, L i &lt; R j) ∧ (∀ i, numeric (L i)) ∧ (∀ i, numeric (R i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  lemma numeric.move_left {x : pgame} (o : numeric x) (i : x.left_moves) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.left_moves'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1} → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The indexing type for allowable moves by Left.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    numeric (x.move_left i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (g : pgame.{u_1}), pgame.left_moves.{u_1} g → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The new game after Left makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
i : pgame.left_moves.{u_1} x
⊢ pgame.numeric.{u_1} (pgame.move_left.{u_1} x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    cases x with xl xr xL xR,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
i : pgame.left_moves.{u_1} x
⊢ pgame.numeric.{u_1} (pgame.move_left.{u_1} x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
o : pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR),
i : pgame.left_moves.{u_1} (pgame.mk.{u_1} xl xr xL xR)
⊢ pgame.numeric.{u_1} (pgame.move_left.{u_1} (pgame.mk.{u_1} xl xr xL xR) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    exact o.2.1 i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.left_moves.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
o : pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR),
i : pgame.left_moves.{u_1} (pgame.mk.{u_1} xl xr xL xR)
⊢ pgame.numeric.{u_1} (pgame.move_left.{u_1} (pgame.mk.{u_1} xl xr xL xR) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  lemma numeric.move_right {x : pgame} (o : numeric x) (j : x.right_moves) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.right_moves'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1} → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The indexing type for allowable moves by Right.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    numeric (x.move_right j) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (g : pgame.{u_1}), pgame.right_moves.{u_1} g → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The new game after Right makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ pgame.numeric.{u_1} (pgame.move_right.{u_1} x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    cases x with xl xr xL xR,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ pgame.numeric.{u_1} (pgame.move_right.{u_1} x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
o : pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR),
j : pgame.right_moves.{u_1} (pgame.mk.{u_1} xl xr xL xR)
⊢ pgame.numeric.{u_1} (pgame.move_right.{u_1} (pgame.mk.{u_1} xl xr xL xR) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    exact o.2.2 j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.right_moves.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
o : pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR),
j : pgame.right_moves.{u_1} (pgame.mk.{u_1} xl xr xL xR)
⊢ pgame.numeric.{u_1} (pgame.move_right.{u_1} (pgame.mk.{u_1} xl xr xL xR) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  @[elab_as_eliminator]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated as f were an eliminator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  theorem numeric_rec {C : pgame → Prop}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    (H : ∀ l r (L : l → pgame) (R : r → pgame),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137      (∀ i j, L i &lt; R j) → (∀ i, numeric (L i)) → (∀ i, numeric (R i)) →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138      (∀ i, C (L i)) → (∀ i, C (R i)) → C ⟨l, r, L, R⟩) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    ∀ x, numeric x → C x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  | ⟨l, r, L, R⟩ ⟨h, hl, hr⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ (i : l) (j : r), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (L i) (R j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (i : l), pgame.numeric.{u_1} (L i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (i : r), pgame.numeric.{u_1} (R i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    H _ _ _ _ h hl hr (λ i, numeric_rec _ (hl i)) (λ i, numeric_rec _ (hr i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='numeric_rec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='numeric_rec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (l r : Type u_1) (L : l → pgame.{u_1}) (R : r → pgame.{u_1}), (∀ (i : l) (j : r), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (L i) (R j)) → (∀ (i : l), pgame.numeric.{u_1} (L i)) → (∀ (i : r), pgame.numeric.{u_1} (R i)) → (Π (i : l), C (L i)) → (Π (i : r), C (R i)) → C (pgame.mk.{u_1} l r L R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x : pgame.{u_1}), pgame.numeric.{u_1} x → C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x : pgame.{u_1}), pgame.numeric.{u_1} x → C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  theorem lt_asymm {x y : pgame} (ox : numeric x) (oy : numeric y) : x &lt; y → ¬ y &lt; x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y
⊢ @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y →
  not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    refine numeric_rec (λ xl xr xL xR hx oxl oxr IHxl IHxr, _) x ox y oy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.numeric_rec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : pgame.{u_1} → Prop}, (∀ (l r : Type u_1) (L : l → pgame.{u_1}) (R : r → pgame.{u_1}), (∀ (i : l) (j : r), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (L i) (R j)) → (∀ (i : l), pgame.numeric.{u_1} (L i)) → (∀ (i : r), pgame.numeric.{u_1} (R i)) → (∀ (i : l), C (L i)) → (∀ (i : r), C (R i)) → C (pgame.mk.{u_1} l r L R)) → ∀ (x : pgame.{u_1}), pgame.numeric.{u_1} x → C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y
⊢ @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y →
  not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i))
⊢ ∀ (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (pgame.mk.{u_1} xl xr xL xR))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    refine numeric_rec (λ yl yr yL yR hy oyl oyr IHyl IHyr, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.numeric_rec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : pgame.{u_1} → Prop}, (∀ (l r : Type u_1) (L : l → pgame.{u_1}) (R : r → pgame.{u_1}), (∀ (i : l) (j : r), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (L i) (R j)) → (∀ (i : l), pgame.numeric.{u_1} (L i)) → (∀ (i : r), pgame.numeric.{u_1} (R i)) → (∀ (i : l), C (L i)) → (∀ (i : r), C (R i)) → C (pgame.mk.{u_1} l r L R)) → ∀ (x : pgame.{u_1}), pgame.numeric.{u_1} x → C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i))
⊢ ∀ (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (pgame.mk.{u_1} xl xr xL xR))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR))
⊢ @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (pgame.mk.{u_1} yl yr yL yR) →
  not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} yl yr yL yR) (pgame.mk.{u_1} xl xr xL xR))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    rw [mk_lt_mk, mk_lt_mk], rintro (⟨i, h₁⟩ | ⟨j, h₁⟩) (⟨i, h₂⟩ | ⟨j, h₂⟩),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='pgame.mk_lt_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.mk_lt_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 233, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 233, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {xl xr : Type u_1} {xL : xl → pgame.{u_1}} {xR : xr → pgame.{u_1}} {yl yr : Type u_1} {yL : yl → pgame.{u_1}} {yR : yr → pgame.{u_1}}, iff (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (pgame.mk.{u_1} yl yr yL yR)) (or (@Exists.{u_1+1} yl (λ (i : yl), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i))) (@Exists.{u_1+1} xr (λ (j : xr), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {xl xr : Type u_1} {xL : xl → pgame.{u_1}} {xR : xr → pgame.{u_1}} {yl yr : Type u_1} {yL : yl → pgame.{u_1}} {yR : yr → pgame.{u_1}}, iff (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (pgame.mk.{u_1} yl yr yL yR)) (or (@Exists.{u_1+1} yl (λ (i : yl), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i))) (@Exists.{u_1+1} xr (λ (j : xr), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Definition of `x &lt; y` on pre-games built using the constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Definition of `x &lt; y` on pre-games built using the constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR))
⊢ @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (pgame.mk.{u_1} yl yr yL yR) →
  not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} yl yr yL yR) (pgame.mk.{u_1} xl xr xL xR))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR))
⊢ or
    (@Exists.{u_1+1} yl
       (λ (i : yl), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i)))
    (@Exists.{u_1+1} xr
       (λ (j : xr), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR))) →
  not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} yl yr yL yR) (pgame.mk.{u_1} xl xr xL xR))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR))
⊢ or
    (@Exists.{u_1+1} yl
       (λ (i : yl), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i)))
    (@Exists.{u_1+1} xr
       (λ (j : xr), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR))) →
  not
    (or
       (@Exists.{u_1+1} xl
          (λ (i : xl), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)))
       (@Exists.{u_1+1} yr
          (λ (j : yr), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    { exact IHxl _ _ (oyl _) (lt_of_le_mk h₁) (lt_of_le_mk h₂) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='IHxl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='oyl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.lt_of_le_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 328, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : xl) (_a : pgame.{u_1}), pgame.numeric.{u_1} _a → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a → not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : yl), pgame.numeric.{u_1} (yL i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {xl xr : Type u_1} {xL : xl → pgame.{u_1}} {xR : xr → pgame.{u_1}} {y : pgame.{u_1}} {i : xl}, @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) y → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    { exact not_lt.2 (le_trans h₂ h₁) (hy _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='pgame.not_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 356, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 381, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y)) (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x y z : pgame.{u_1}}, @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y z → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
i : yl,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    { exact not_lt.2 (le_trans h₁ h₂) (hx _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='pgame.not_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 356, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 381, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y)) (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x y z : pgame.{u_1}}, @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y z → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false

x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
i : xl,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.mk.{u_1} yl yr yL yR) (xL i)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    { exact IHxr _ _ (oyr _) (lt_of_mk_le h₁) (lt_of_mk_le h₂) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='IHxr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='oyr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.lt_of_mk_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : xr) (_a : pgame.{u_1}), pgame.numeric.{u_1} _a → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a → not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : yr), pgame.numeric.{u_1} (yR i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x : pgame.{u_1}} {yl yr : Type u_1} {yL : yl → pgame.{u_1}} {yR : yr → pgame.{u_1}} {i : yr}, @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x (pgame.mk.{u_1} yl yr yL yR) → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x (yR i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : pgame.{u_1},
ox : pgame.numeric.{u_1} x,
oy : pgame.numeric.{u_1} y,
xl xr : Type u_1,
xL : xl → pgame.{u_1},
xR : xr → pgame.{u_1},
hx : ∀ (i : xl) (j : xr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) (xR j),
oxl : ∀ (i : xl), pgame.numeric.{u_1} (xL i),
oxr : ∀ (i : xr), pgame.numeric.{u_1} (xR i),
IHxl :
  ∀ (i : xl) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xL i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xL i)),
IHxr :
  ∀ (i : xr) (_a : pgame.{u_1}),
    pgame.numeric.{u_1} _a →
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (xR i) _a →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} _a (xR i)),
yl yr : Type u_1,
yL : yl → pgame.{u_1},
yR : yr → pgame.{u_1},
hy : ∀ (i : yl) (j : yr), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (yR j),
oyl : ∀ (i : yl), pgame.numeric.{u_1} (yL i),
oyr : ∀ (i : yr), pgame.numeric.{u_1} (yR i),
IHyl :
  ∀ (i : yl),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yL i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yL i) (pgame.mk.{u_1} xl xr xL xR)),
IHyr :
  ∀ (i : yr),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.mk.{u_1} xl xr xL xR) (yR i) →
    not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (yR i) (pgame.mk.{u_1} xl xr xL xR)),
j : xr,
h₁ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (xR j) (pgame.mk.{u_1} yl yr yL yR),
j : yr,
h₂ : @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (yR j) (pgame.mk.{u_1} xl xr xL xR)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  theorem le_of_lt {x y : pgame} (ox : numeric x) (oy : numeric y) (h : x &lt; y) : x ≤ y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_le.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  not_lt.1 (lt_asymm ox oy h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.not_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.lt_asymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 356, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 143, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y)) (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y → not (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  /-- On numeric pre-games, `&lt;` and `≤` satisfy the axioms of a partial order (even though they</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      don&#x27;t on all pre-games). -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  theorem lt_iff_le_not_le {x y : pgame} (ox : numeric x) (oy : numeric y) : x &lt; y ↔ x ≤ y ∧ ¬ y ≤ x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_le.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_le.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  ⟨λ h, ⟨le_of_lt ox oy h, not_le.2 h⟩, λ h, not_le.1 h.2⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 154, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (not (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y)) (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='and (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y) (not (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (not (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y)) (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='and (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y) (not (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  theorem numeric_zero : numeric 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  ⟨by rintros ⟨⟩ ⟨⟩, ⟨by rintros ⟨⟩, by rintros ⟨⟩⟩⟩</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='lime'><a title='⊢ ∀ (i j : pempty.{u_1+1}),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (@pempty.elim.{u_1+2 u_1+1} pgame.{u_1} i)
      (@pempty.elim.{u_1+2 u_1+1} pgame.{u_1} j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='⊢ ∀ (i : pempty.{u_1+1}), pgame.numeric.{u_1} (@pempty.elim.{u_1+2 u_1+1} pgame.{u_1} i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='⊢ ∀ (i : pempty.{u_1+1}), pgame.numeric.{u_1} (@pempty.elim.{u_1+2 u_1+1} pgame.{u_1} i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  theorem numeric_one : numeric 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  ⟨by rintros ⟨⟩ ⟨⟩, ⟨λ x, numeric_zero, by rintros ⟨⟩⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 162, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='punit.{u_1+1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u_1} (@has_zero.zero.{u_1+1} pgame.{u_1} pgame.has_zero.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='lime'><a title='⊢ ∀ (i : punit.{u_1+1}) (j : pempty.{u_1+1}),
    @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1}
      ((λ (_x : punit.{u_1+1}), @has_zero.zero.{u_1+1} pgame.{u_1} pgame.has_zero.{u_1}) i)
      (@pempty.elim.{u_1+2 u_1+1} pgame.{u_1} j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='⊢ ∀ (i : pempty.{u_1+1}), pgame.numeric.{u_1} (@pempty.elim.{u_1+2 u_1+1} pgame.{u_1} i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  theorem numeric_neg : Π {x : pgame} (o : numeric x), numeric (-x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='numeric_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} (@has_neg.neg.{u_1+1} pgame.{u_1} pgame.has_neg.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_neg.{u_1+1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  | ⟨l, r, L, R⟩ o :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} l r L R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  ⟨λ j i, lt_iff_neg_gt.1 (o.1 i j),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.lt_iff_neg_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 606, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y) (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (@has_neg.neg.{u_1+1} pgame.{u_1} pgame.has_neg.{u_1} y) (@has_neg.neg.{u_1+1} pgame.{u_1} pgame.has_neg.{u_1} x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    ⟨λ j, numeric_neg (o.2.2 j), λ i, numeric_neg (o.2.1 i)⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='numeric_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='numeric_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} (@has_neg.neg.{u_1+1} pgame.{u_1} pgame.has_neg.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} (@has_neg.neg.{u_1+1} pgame.{u_1} pgame.has_neg.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  theorem numeric.move_left_lt {x : pgame.{u}} (o : numeric x) (i : x.left_moves) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.left_moves'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u} → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The indexing type for allowable moves by Left.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    x.move_left i &lt; x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (g : pgame.{u}), pgame.left_moves.{u} g → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_lt.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The new game after Left makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u},
o : pgame.numeric.{u} x,
i : pgame.left_moves.{u} x
⊢ @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} (pgame.move_left.{u} x i) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    rw lt_def_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.lt_def_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 239, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u}}, iff (@has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} x y) (or (@Exists.{u+1} (pgame.left_moves.{u} y) (λ (i : pgame.left_moves.{u} y), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} x (pgame.move_left.{u} y i))) (@Exists.{u+1} (pgame.right_moves.{u} x) (λ (j : pgame.right_moves.{u} x), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} x j) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Definition of `x &lt; y` on pre-games, in terms of `≤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u},
o : pgame.numeric.{u} x,
i : pgame.left_moves.{u} x
⊢ @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} (pgame.move_left.{u} x i) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u},
o : pgame.numeric.{u} x,
i : pgame.left_moves.{u} x
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} x)
       (λ (i_1 : pgame.left_moves.{u} x),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_left.{u} x i) (pgame.move_left.{u} x i_1)))
    (@Exists.{u+1} (pgame.right_moves.{u} (pgame.move_left.{u} x i))
       (λ (j : pgame.right_moves.{u} (pgame.move_left.{u} x i)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} (pgame.move_left.{u} x i) j) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    left,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u},
o : pgame.numeric.{u} x,
i : pgame.left_moves.{u} x
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} x)
       (λ (i_1 : pgame.left_moves.{u} x),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_left.{u} x i) (pgame.move_left.{u} x i_1)))
    (@Exists.{u+1} (pgame.right_moves.{u} (pgame.move_left.{u} x i))
       (λ (j : pgame.right_moves.{u} (pgame.move_left.{u} x i)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} (pgame.move_left.{u} x i) j) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u},
o : pgame.numeric.{u} x,
i : pgame.left_moves.{u} x
⊢ @Exists.{u+1} (pgame.left_moves.{u} x)
    (λ (i_1 : pgame.left_moves.{u} x),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_left.{u} x i) (pgame.move_left.{u} x i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    use i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.left_moves.{u} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u},
o : pgame.numeric.{u} x,
i : pgame.left_moves.{u} x
⊢ @Exists.{u+1} (pgame.left_moves.{u} x)
    (λ (i_1 : pgame.left_moves.{u} x),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_left.{u} x i) (pgame.move_left.{u} x i_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  theorem numeric.move_left_le {x : pgame} (o : numeric x) (i : x.left_moves) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.left_moves'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1} → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The indexing type for allowable moves by Left.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181    x.move_left i ≤ x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (g : pgame.{u_1}), pgame.left_moves.{u_1} g → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_le.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The new game after Left makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  le_of_lt (o.move_left i) o (o.move_left_lt i)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.numeric.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.numeric.move_left_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 154, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 172, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → ∀ (i : pgame.left_moves.{u_1} x), pgame.numeric.{u_1} (pgame.move_left.{u_1} x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → ∀ (i : pgame.left_moves.{u_1} x), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (pgame.move_left.{u_1} x i) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  theorem numeric.lt_move_right {x : pgame} (o : numeric x) (j : x.right_moves) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.right_moves'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1} → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The indexing type for allowable moves by Right.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    x &lt; x.move_right j :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (g : pgame.{u_1}), pgame.right_moves.{u_1} g → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The new game after Right makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x (pgame.move_right.{u_1} x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    rw lt_def_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.lt_def_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 239, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y) (or (@Exists.{u_1+1} (pgame.left_moves.{u_1} y) (λ (i : pgame.left_moves.{u_1} y), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x (pgame.move_left.{u_1} y i))) (@Exists.{u_1+1} (pgame.right_moves.{u_1} x) (λ (j : pgame.right_moves.{u_1} x), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.move_right.{u_1} x j) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Definition of `x &lt; y` on pre-games, in terms of `≤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x (pgame.move_right.{u_1} x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ or
    (@Exists.{u_1+1} (pgame.left_moves.{u_1} (pgame.move_right.{u_1} x j))
       (λ (i : pgame.left_moves.{u_1} (pgame.move_right.{u_1} x j)),
          @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x (pgame.move_left.{u_1} (pgame.move_right.{u_1} x j) i)))
    (@Exists.{u_1+1} (pgame.right_moves.{u_1} x)
       (λ (j_1 : pgame.right_moves.{u_1} x),
          @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.move_right.{u_1} x j_1)
            (pgame.move_right.{u_1} x j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    right,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ or
    (@Exists.{u_1+1} (pgame.left_moves.{u_1} (pgame.move_right.{u_1} x j))
       (λ (i : pgame.left_moves.{u_1} (pgame.move_right.{u_1} x j)),
          @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x (pgame.move_left.{u_1} (pgame.move_right.{u_1} x j) i)))
    (@Exists.{u_1+1} (pgame.right_moves.{u_1} x)
       (λ (j_1 : pgame.right_moves.{u_1} x),
          @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.move_right.{u_1} x j_1)
            (pgame.move_right.{u_1} x j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ @Exists.{u_1+1} (pgame.right_moves.{u_1} x)
    (λ (j_1 : pgame.right_moves.{u_1} x),
       @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.move_right.{u_1} x j_1) (pgame.move_right.{u_1} x j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    use j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.right_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : pgame.{u_1},
o : pgame.numeric.{u_1} x,
j : pgame.right_moves.{u_1} x
⊢ @Exists.{u_1+1} (pgame.right_moves.{u_1} x)
    (λ (j_1 : pgame.right_moves.{u_1} x),
       @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} (pgame.move_right.{u_1} x j_1) (pgame.move_right.{u_1} x j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  theorem numeric.le_move_right {x : pgame} (o : numeric x) (j : x.right_moves) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.right_moves'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1} → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The indexing type for allowable moves by Right.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    x ≤ x.move_right j :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_le.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (g : pgame.{u_1}), pgame.right_moves.{u_1} g → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The new game after Right makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  le_of_lt o (o.move_right j) (o.lt_move_right j)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.numeric.move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.numeric.lt_move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 154, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 184, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → ∀ (j : pgame.right_moves.{u_1} x), pgame.numeric.{u_1} (pgame.move_right.{u_1} x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → ∀ (j : pgame.right_moves.{u_1} x), @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x (pgame.move_right.{u_1} x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  theorem add_lt_add</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197    {w x y z : pgame.{u}} (ow : numeric w) (ox : numeric x) (oy : numeric y) (oz : numeric z)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198    (hwx : w &lt; x) (hyz : y &lt; z) : w + y &lt; x + z :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_lt.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_lt.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_add.{u+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_lt.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_add.{u+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
hwx : @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} w x,
hyz : @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} y z
⊢ @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    rw lt_def_le at *,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.lt_def_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 239, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{?l_1}}, iff (@has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} x y) (or (@Exists.{?l_1+1} (pgame.left_moves.{?l_1} y) (λ (i : pgame.left_moves.{?l_1} y), @has_le.le.{?l_1+1} pgame.{?l_1} pgame.has_le.{?l_1} x (pgame.move_left.{?l_1} y i))) (@Exists.{?l_1+1} (pgame.right_moves.{?l_1} x) (λ (j : pgame.right_moves.{?l_1} x), @has_le.le.{?l_1+1} pgame.{?l_1} pgame.has_le.{?l_1} (pgame.move_right.{?l_1} x j) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Definition of `x &lt; y` on pre-games, in terms of `≤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
hwx : @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} w x,
hyz : @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} y z
⊢ @has_lt.lt.{u+1} pgame.{u} pgame.has_lt.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
hwx :
  or
    (@Exists.{u+1} (pgame.left_moves.{u} x)
       (λ (i : pgame.left_moves.{u} x), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x i)))
    (@Exists.{u+1} (pgame.right_moves.{u} w)
       (λ (j : pgame.right_moves.{u} w), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w j) x)),
hyz :
  or
    (@Exists.{u+1} (pgame.left_moves.{u} z)
       (λ (i : pgame.left_moves.{u} z), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z i)))
    (@Exists.{u+1} (pgame.right_moves.{u} y)
       (λ (j : pgame.right_moves.{u} y), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y j) z))
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    rcases hwx with ⟨ix, hix⟩|⟨jw, hjw⟩;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hwx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@Exists.{u+1} (pgame.left_moves.{u} x) (λ (i : pgame.left_moves.{u} x), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x i))) (@Exists.{u+1} (pgame.right_moves.{u} w) (λ (j : pgame.right_moves.{u} w), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w j) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
hwx :
  or
    (@Exists.{u+1} (pgame.left_moves.{u} x)
       (λ (i : pgame.left_moves.{u} x), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x i)))
    (@Exists.{u+1} (pgame.right_moves.{u} w)
       (λ (j : pgame.right_moves.{u} w), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w j) x)),
hyz :
  or
    (@Exists.{u+1} (pgame.left_moves.{u} z)
       (λ (i : pgame.left_moves.{u} z), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z i)))
    (@Exists.{u+1} (pgame.right_moves.{u} y)
       (λ (j : pgame.right_moves.{u} y), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y j) z))
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    rcases hyz with ⟨iz, hiz⟩|⟨jy, hjy⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hyz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@Exists.{u+1} (pgame.left_moves.{u} z) (λ (i : pgame.left_moves.{u} z), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z i))) (@Exists.{u+1} (pgame.right_moves.{u} y) (λ (j : pgame.right_moves.{u} y), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y j) z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
hwx :
  or
    (@Exists.{u+1} (pgame.left_moves.{u} x)
       (λ (i : pgame.left_moves.{u} x), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x i)))
    (@Exists.{u+1} (pgame.right_moves.{u} w)
       (λ (j : pgame.right_moves.{u} w), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w j) x)),
hyz :
  or
    (@Exists.{u+1} (pgame.left_moves.{u} z)
       (λ (i : pgame.left_moves.{u} z), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z i)))
    (@Exists.{u+1} (pgame.right_moves.{u} y)
       (λ (j : pgame.right_moves.{u} y), @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y j) z))
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    { left,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
    (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
         (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204      use (left_moves_add x z).symm (sum.inl ix),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.left_moves_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 673, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x y : pgame.{u}), equiv.{u+1 u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y)) (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, α → sum.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.left_moves.{u} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An explicit equivalence between the moves for Left in `x + y` and the type-theory sum
   of the moves for Left in `x` and in `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
    (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
         (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.symm.{u+1 u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
             (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves_add.{u} x z))
          (@sum.inl.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z) ix)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205      simp only [add_move_left_inl],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pgame.add_move_left_inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 684, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{?l_1}} {i : pgame.left_moves.{?l_1} x}, @eq.{?l_1+2} pgame.{?l_1} (pgame.move_left.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y) (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1} (equiv.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y)) (pgame.left_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y)) (pgame.left_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.symm.{?l_1+1 ?l_1+1} (pgame.left_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y)) (sum.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y)) (pgame.left_moves_add.{?l_1} x y)) (@sum.inl.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y) i))) (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (pgame.move_left.{?l_1} x i) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.symm.{u+1 u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
             (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves_add.{u} x z))
          (@sum.inl.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z) ix)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206      calc w + y ≤ move_left x ix + y : add_le_add_right hix</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pgame.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 769, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_add.{u+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (g : pgame.{u}), pgame.left_moves.{u} g → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} x y → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} y z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The new game after Left makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207              ... ≤ move_left x ix + move_left z iz : add_le_add_left hiz</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='blue'><a title='hiz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208              ... ≤ move_left x ix + z : add_le_add_left (oz.move_left_le iz) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='oz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 819, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 180, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y z → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u} z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u} z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    { left,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
    (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
         (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210      use (left_moves_add x z).symm (sum.inl ix),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.left_moves_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 673, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x y : pgame.{u}), equiv.{u+1 u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y)) (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, α → sum.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.left_moves.{u} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An explicit equivalence between the moves for Left in `x + y` and the type-theory sum
   of the moves for Left in `x` and in `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
    (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
         (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.symm.{u+1 u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
             (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves_add.{u} x z))
          (@sum.inl.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z) ix)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211      simp only [add_move_left_inl],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pgame.add_move_left_inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 684, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{?l_1}} {i : pgame.left_moves.{?l_1} x}, @eq.{?l_1+2} pgame.{?l_1} (pgame.move_left.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y) (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1} (equiv.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y)) (pgame.left_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y)) (pgame.left_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.symm.{?l_1+1 ?l_1+1} (pgame.left_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y)) (sum.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y)) (pgame.left_moves_add.{?l_1} x y)) (@sum.inl.{?l_1 ?l_1} (pgame.left_moves.{?l_1} x) (pgame.left_moves.{?l_1} y) i))) (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (pgame.move_left.{?l_1} x i) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))
          (@equiv.symm.{u+1 u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
             (sum.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z))
             (pgame.left_moves_add.{u} x z))
          (@sum.inl.{u u} (pgame.left_moves.{u} x) (pgame.left_moves.{u} z) ix)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212      calc w + y ≤ move_left x ix + y : add_le_add_right hix</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pgame.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 769, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (g : pgame.{u}), pgame.left_moves.{u} g → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} x y → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} y z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The new game after Left makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213              ... ≤ move_left x ix + move_right y jy : add_le_add_left (oy.le_move_right jy)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='pgame.move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 192, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π (g : pgame.{u}), pgame.right_moves.{u} g → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='pgame.numeric.{u} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The new game after Right makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214              ... ≤ move_left x ix + z : add_le_add_left hjy },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hjy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 819, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y z → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
ix : pgame.left_moves.{u} x,
hix : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} w (pgame.move_left.{u} x ix),
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_left.{u} x ix) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    { right,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))

w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
    (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
         (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
         (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216      use (right_moves_add w y).symm (sum.inl jw),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.right_moves_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 678, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x y : pgame.{u}), equiv.{u+1 u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y)) (sum.{u u} (pgame.right_moves.{u} x) (pgame.right_moves.{u} y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, α → sum.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.right_moves.{u} w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An explicit equivalence between the moves for Right in `x + y` and the type-theory sum
   of the moves for Right in `x` and in `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
    (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
         (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
         (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.symm.{u+1 u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
             (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves_add.{u} w y))
          (@sum.inl.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y) jw)))
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217      simp only [add_move_right_inl],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pgame.add_move_right_inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 691, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{?l_1}} {i : pgame.right_moves.{?l_1} x}, @eq.{?l_1+2} pgame.{?l_1} (pgame.move_right.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y) (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1} (equiv.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y)) (pgame.right_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y)) (pgame.right_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.symm.{?l_1+1 ?l_1+1} (pgame.right_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y)) (sum.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y)) (pgame.right_moves_add.{?l_1} x y)) (@sum.inl.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y) i))) (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (pgame.move_right.{?l_1} x i) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.symm.{u+1 u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
             (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves_add.{u} w y))
          (@sum.inl.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y) jw)))
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218      calc move_right w jw + y ≤ x + y : add_le_add_right hjw</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame.move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hjw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 769, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (g : pgame.{u}), pgame.right_moves.{u} g → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u} w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} x y → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} y z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The new game after Right makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219              ... ≤ x + move_left z iz : add_le_add_left hiz</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='pgame.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='hiz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (g : pgame.{u}), pgame.left_moves.{u} g → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The new game after Left makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220              ... ≤ x + z : add_le_add_left (oz.move_left_le iz), },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='oz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 819, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 180, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y z → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u} z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.left_moves.{u} z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
iz : pgame.left_moves.{u} z,
hiz : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y (pgame.move_left.{u} z iz)
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221    { right,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ or
    (@Exists.{u+1} (pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))
       (λ (i : pgame.left_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
            (pgame.move_left.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) i)))
    (@Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
       (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
          @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
            (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
            (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
    (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
         (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
         (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222      use (right_moves_add w y).symm (sum.inl jw),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.right_moves_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 678, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x y : pgame.{u}), equiv.{u+1 u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y)) (sum.{u u} (pgame.right_moves.{u} x) (pgame.right_moves.{u} y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, α → sum.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.right_moves.{u} w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An explicit equivalence between the moves for Right in `x + y` and the type-theory sum
   of the moves for Right in `x` and in `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @Exists.{u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
    (λ (j : pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)),
       @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
         (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y) j)
         (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.symm.{u+1 u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
             (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves_add.{u} w y))
          (@sum.inl.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y) jw)))
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223      simp only [add_move_right_inl],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pgame.add_move_right_inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 691, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{?l_1}} {i : pgame.right_moves.{?l_1} x}, @eq.{?l_1+2} pgame.{?l_1} (pgame.move_right.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y) (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1} (equiv.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y)) (pgame.right_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1} (sum.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y)) (pgame.right_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y))) (@equiv.symm.{?l_1+1 ?l_1+1} (pgame.right_moves.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y)) (sum.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y)) (pgame.right_moves_add.{?l_1} x y)) (@sum.inl.{?l_1 ?l_1} (pgame.right_moves.{?l_1} x) (pgame.right_moves.{?l_1} y) i))) (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (pgame.move_right.{?l_1} x i) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (pgame.move_right.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)
       (@coe_fn.{(max 1 (u+1)) u+1}
          (equiv.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.has_coe_to_fun.{u+1 u+1} (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y)))
          (@equiv.symm.{u+1 u+1} (pgame.right_moves.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} w y))
             (sum.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y))
             (pgame.right_moves_add.{u} w y))
          (@sum.inl.{u u} (pgame.right_moves.{u} w) (pgame.right_moves.{u} y) jw)))
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224      calc move_right w jw + y ≤ x + y : add_le_add_right hjw</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hjw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 769, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u} w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} x y → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} y z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225              ... ≤ x + move_right y jy : add_le_add_left (oy.le_move_right jy)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='pgame.move_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 192, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (g : pgame.{u}), pgame.right_moves.{u} g → pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='pgame.numeric.{u} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.right_moves.{u} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The new game after Right makes an allowed move.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226              ... ≤ x + z : add_le_add_left hjy, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.add_le_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hjy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 819, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='pgame.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {x y z : pgame.{u}}, @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} y z → @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x y) (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='w x y z : pgame.{u},
ow : pgame.numeric.{u} w,
ox : pgame.numeric.{u} x,
oy : pgame.numeric.{u} y,
oz : pgame.numeric.{u} z,
jw : pgame.right_moves.{u} w,
hjw : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} w jw) x,
jy : pgame.right_moves.{u} y,
hjy : @has_le.le.{u+1} pgame.{u} pgame.has_le.{u} (pgame.move_right.{u} y jy) z
⊢ @has_le.le.{u+1} pgame.{u} pgame.has_le.{u}
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} (pgame.move_right.{u} w jw) y)
    (@has_add.add.{u+1} pgame.{u} pgame.has_add.{u} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  theorem numeric_add : Π {x y : pgame} (ox : numeric x) (oy : numeric y), numeric (x + y)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='numeric_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  | ⟨xl, xr, xL, xR⟩ ⟨yl, yr, yL, yR⟩ ox oy :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  ⟨begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xl yl) (j : sum.{?l_1 ?l_1} xr yr),
    @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
         (λ (i : xl),
            (λ (a : xl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xL a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yl),
            (λ (a : yl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yL a))
              i)
         i)
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
         (λ (i : xr),
            (λ (a : xr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xR a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yr),
            (λ (a : yr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yR a))
              i)
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232     rintros (ix|iy) (jx|jy),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xl yl) (j : sum.{?l_1 ?l_1} xr yr),
    @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
         (λ (i : xl),
            (λ (a : xl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xL a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yl),
            (λ (a : yl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yL a))
              i)
         i)
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
         (λ (i : xr),
            (λ (a : xr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xR a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yr),
            (λ (a : yr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yR a))
              i)
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233     { show xL ix + ⟨yl, yr, yL, yR⟩ &lt; xR jx + ⟨yl, yr, yL, yR⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='xL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (xL ix) (pgame.mk.{?l_1} yl yr yL yR))
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (xR jx) (pgame.mk.{?l_1} yl yr yL yR))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234       exact add_lt_add_right (ox.1 ix jx), },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='pgame.add_lt_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y z : pgame.{u_1}}, @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x z) (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} y z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (xL ix) (pgame.mk.{?l_1} yl yr yL yR))
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (xR jx) (pgame.mk.{?l_1} yl yr yL yR))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235     { show xL ix + ⟨yl, yr, yL, yR⟩ &lt; ⟨xl, xr, xL, xR⟩ + yR jy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='yR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (xL ix) (pgame.mk.{?l_1} yl yr yL yR))
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (pgame.mk.{?l_1} xl xr xL xR) (yR jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236       apply add_lt_add (ox.move_left ix) ox oy (oy.move_right jy),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='pgame.add_lt_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 196, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {w x y z : pgame.{u_1}}, pgame.numeric.{u_1} w → pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} z → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} w x → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y z → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} w y) (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → ∀ (i : pgame.left_moves.{u_1} x), pgame.numeric.{u_1} (pgame.move_left.{u_1} x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (xL ix) (pgame.mk.{?l_1} yl yr yL yR))
    (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} (pgame.mk.{?l_1} xl xr xL xR) (yR jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.move_left.{?l_1} (pgame.mk.{?l_1} xl xr xL xR) ix)
    (pgame.mk.{?l_1} xl xr xL xR)

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
    (pgame.move_right.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) jy)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237       apply ox.move_left_lt,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.move_left.{?l_1} (pgame.mk.{?l_1} xl xr xL xR) ix)
    (pgame.mk.{?l_1} xl xr xL xR)

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
    (pgame.move_right.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) jy)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
    (pgame.move_right.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) jy)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238       apply oy.lt_move_right },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
    (pgame.move_right.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) jy)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239     { --  show ⟨xl, xr, xL, xR⟩ + yL iy &lt; xR jx + ⟨yl, yr, yL, yR⟩, -- fails?</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240       apply add_lt_add ox (ox.move_right jx) (oy.move_left iy) oy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='pgame.add_lt_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.numeric.move_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 196, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {w x y z : pgame.{u_1}}, pgame.numeric.{u_1} w → pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} z → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} w x → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y z → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} w y) (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x : pgame.{u_1}}, pgame.numeric.{u_1} x → ∀ (i : pgame.left_moves.{u_1} x), pgame.numeric.{u_1} (pgame.move_left.{u_1} x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.mk.{?l_1} xl xr xL xR)
    (pgame.move_right.{?l_1} (pgame.mk.{?l_1} xl xr xL xR) jx)

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.move_left.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) iy)
    (pgame.mk.{?l_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241       apply ox.lt_move_right,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.mk.{?l_1} xl xr xL xR)
    (pgame.move_right.{?l_1} (pgame.mk.{?l_1} xl xr xL xR) jx)

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.move_left.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) iy)
    (pgame.mk.{?l_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.move_left.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) iy)
    (pgame.mk.{?l_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242       apply oy.move_left_lt, },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jx : xr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1} (pgame.move_left.{?l_1} (pgame.mk.{?l_1} yl yr yL yR) iy)
    (pgame.mk.{?l_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243     { --  show ⟨xl, xr, xL, xR⟩ + yL iy &lt; ⟨xl, xr, xL, xR⟩ + yR jy, -- fails?</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244       exact @add_lt_add_left ⟨xl, xr, xL, xR⟩ _ _ (oy.1 iy jy), }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pgame.add_lt_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='iy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 882, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x y z : pgame.{u_1}}, @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y z → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y) (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr → pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl,
jy : yr
⊢ @has_lt.lt.{?l_1+1} pgame.{?l_1} pgame.has_lt.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245   end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246   begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ and
    (∀ (i : sum.{?l_1 ?l_1} xl yl),
       pgame.numeric.{?l_1}
         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
            (λ (i : xl),
               (λ (a : xl),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                     (y : pgame.{?l_1}),
                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yl), IHyl i))
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yr), IHyr i)))
                         y)
                    (xL a))
                 i
                 (pgame.mk.{?l_1} yl yr yL yR))
            (λ (i : yl),
               (λ (a : yl),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl),
                               (λ (a : xl),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xL a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr),
                               (λ (a : xr),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xR a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    (yL a))
                 i)
            i))
    (∀ (i : sum.{?l_1 ?l_1} xr yr),
       pgame.numeric.{?l_1}
         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
            (λ (i : xr),
               (λ (a : xr),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                     (y : pgame.{?l_1}),
                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yl), IHyl i))
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yr), IHyr i)))
                         y)
                    (xR a))
                 i
                 (pgame.mk.{?l_1} yl yr yL yR))
            (λ (i : yr),
               (λ (a : yr),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl),
                               (λ (a : xl),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xL a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr),
                               (λ (a : xr),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xR a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    (yR a))
                 i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247     split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ and
    (∀ (i : sum.{?l_1 ?l_1} xl yl),
       pgame.numeric.{?l_1}
         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
            (λ (i : xl),
               (λ (a : xl),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                     (y : pgame.{?l_1}),
                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yl), IHyl i))
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yr), IHyr i)))
                         y)
                    (xL a))
                 i
                 (pgame.mk.{?l_1} yl yr yL yR))
            (λ (i : yl),
               (λ (a : yl),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl),
                               (λ (a : xl),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xL a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr),
                               (λ (a : xr),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xR a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    (yL a))
                 i)
            i))
    (∀ (i : sum.{?l_1 ?l_1} xr yr),
       pgame.numeric.{?l_1}
         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
            (λ (i : xr),
               (λ (a : xr),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                     (y : pgame.{?l_1}),
                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yl), IHyl i))
                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                 (λ (i : yr), IHyr i)))
                         y)
                    (xR a))
                 i
                 (pgame.mk.{?l_1} yl yr yL yR))
            (λ (i : yr),
               (λ (a : yr),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl),
                               (λ (a : xl),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xL a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr),
                               (λ (a : xr),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                    (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                     (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                     (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                     (y : pgame.{?l_1}),
                                       @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                         (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                          (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                          (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                            pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                                 (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                                 (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yl), IHyl i))
                                              (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                                 (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                                 (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                                 (λ (i : yr), IHyr i)))
                                         y)
                                    (xR a))
                                 i
                                 (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    (yR a))
                 i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xl yl),
    pgame.numeric.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
         (λ (i : xl),
            (λ (a : xl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xL a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yl),
            (λ (a : yl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yL a))
              i)
         i)

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xr yr),
    pgame.numeric.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
         (λ (i : xr),
            (λ (a : xr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xR a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yr),
            (λ (a : yr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yR a))
              i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248     { rintros (ix|iy),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xl yl),
    pgame.numeric.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
         (λ (i : xl),
            (λ (a : xl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xL a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yl),
            (λ (a : yl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yL a))
              i)
         i)

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xr yr),
    pgame.numeric.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
         (λ (i : xr),
            (λ (a : xr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xR a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yr),
            (λ (a : yr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yR a))
              i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xl yl),
    pgame.numeric.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
         (λ (i : xl),
            (λ (a : xl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xL a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yl),
            (λ (a : yl),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yL a))
              i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249       { apply numeric_add (ox.move_left ix) oy, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='numeric_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
ix : xl
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inl.{?l_1 ?l_1} xl yl ix))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250       { apply numeric_add ox (oy.move_left iy), }, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='numeric_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
iy : yl
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
       (λ (i : xl),
          (λ (a : xl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xL a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yl),
          (λ (a : yl),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yL a))
            i)
       (@sum.inr.{?l_1 ?l_1} xl yl iy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xr yr),
    pgame.numeric.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
         (λ (i : xr),
            (λ (a : xr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xR a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yr),
            (λ (a : yr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yR a))
              i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251     { rintros (jx|jy),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR)
⊢ ∀ (i : sum.{?l_1 ?l_1} xr yr),
    pgame.numeric.{?l_1}
      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
         (λ (i : xr),
            (λ (a : xr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                  (y : pgame.{?l_1}),
                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yl), IHyl i))
                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                              (λ (i : yr), IHyr i)))
                      y)
                 (xR a))
              i
              (pgame.mk.{?l_1} yl yr yL yR))
         (λ (i : yr),
            (λ (a : yr),
               @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                 (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                  (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                  (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                    pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                         (λ (i : xl),
                            (λ (a : xl),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xL a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yl), IHyl i))
                      (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                         (λ (i : xr),
                            (λ (a : xr),
                               @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                                 (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                  (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                  (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                  (y : pgame.{?l_1}),
                                    @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                      (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                       (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                       (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                         pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                              (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                              (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yl), IHyl i))
                                           (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                              (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                              (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                              (λ (i : yr), IHyr i)))
                                      y)
                                 (xR a))
                              i
                              (pgame.mk.{?l_1} yl yr yL yR))
                         (λ (i : yr), IHyr i)))
                 (yR a))
              i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
jx : xr
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
jy : yr
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252       { apply numeric_add (ox.move_right jx) oy, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='numeric_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='xr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
jx : xr
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))

numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
jy : yr
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
jx : xr
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inl.{?l_1 ?l_1} xr yr jx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
jy : yr
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253       { apply numeric_add ox (oy.move_right jy), }, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='numeric_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='jy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} xl xr xL xR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} (pgame.mk.{u_1} yl yr yL yR)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='yr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='numeric_add :
  ∀ {x y : pgame.{?l_1}},
    pgame.numeric.{?l_1} x →
    pgame.numeric.{?l_1} y → pgame.numeric.{?l_1} (@has_add.add.{?l_1+1} pgame.{?l_1} pgame.has_add.{?l_1} x y),
xl xr : Type ?l_1,
xL : xl → pgame.{?l_1},
xR : xr → pgame.{?l_1},
yl yr : Type ?l_1,
yL : yl → pgame.{?l_1},
yR : yr → pgame.{?l_1},
ox : pgame.numeric.{?l_1} (pgame.mk.{?l_1} xl xr xL xR),
oy : pgame.numeric.{?l_1} (pgame.mk.{?l_1} yl yr yL yR),
jy : yr
⊢ pgame.numeric.{?l_1}
    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
       (λ (i : xr),
          (λ (a : xr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a)) (y : pgame.{?l_1}),
                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yl), IHyl i))
                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                            (λ (i : yr), IHyr i)))
                    y)
               (xR a))
            i
            (pgame.mk.{?l_1} yl yr yL yR))
       (λ (i : yr),
          (λ (a : yr),
             @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
               (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                  pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                       (λ (i : xl),
                          (λ (a : xl),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xL a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yl), IHyl i))
                    (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                       (λ (i : xr),
                          (λ (a : xr),
                             @pgame.rec.{?l_1+2 ?l_1} (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1})
                               (λ (xl xr : Type ?l_1) (xL : xl → pgame.{?l_1}) (xR : xr → pgame.{?l_1})
                                (IHxl : Π (a : xl), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xL a))
                                (IHxr : Π (a : xr), (λ (x : pgame.{?l_1}), pgame.{?l_1} → pgame.{?l_1}) (xR a))
                                (y : pgame.{?l_1}),
                                  @pgame.rec.{?l_1+2 ?l_1} (λ (y : pgame.{?l_1}), pgame.{?l_1})
                                    (λ (yl yr : Type ?l_1) (yL : yl → pgame.{?l_1}) (yR : yr → pgame.{?l_1})
                                     (IHyl : Π (a : yl), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yL a))
                                     (IHyr : Π (a : yr), (λ (y : pgame.{?l_1}), pgame.{?l_1}) (yR a)),
                                       pgame.mk.{?l_1} (sum.{?l_1 ?l_1} xl yl) (sum.{?l_1 ?l_1} xr yr)
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xl yl
                                            (λ (n : sum.{?l_1 ?l_1} xl yl), pgame.{?l_1})
                                            (λ (i : xl), IHxl i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yl), IHyl i))
                                         (@sum.rec.{?l_1+2 ?l_1 ?l_1} xr yr
                                            (λ (n : sum.{?l_1 ?l_1} xr yr), pgame.{?l_1})
                                            (λ (i : xr), IHxr i (pgame.mk.{?l_1} yl yr yL yR))
                                            (λ (i : yr), IHyr i)))
                                    y)
                               (xR a))
                            i
                            (pgame.mk.{?l_1} yl yr yL yR))
                       (λ (i : yr), IHyr i)))
               (yR a))
            i)
       (@sum.inr.{?l_1 ?l_1} xr yr jy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254   end⟩</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  using_well_founded { dec_tac := pgame_wf_tac }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='pgame.pgame_wf_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A local tactic for proving well-foundedness of recursive definitions involving pregames.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  -- TODO prove</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  -- theorem numeric_nat (n : ℕ) : numeric n := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  -- theorem numeric_omega : numeric omega := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  end pgame</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  /-- The equivalence on numeric pre-games. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  def surreal.equiv (x y : {x // pgame.numeric x}) : Prop := x.1.equiv y.1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {α : Type (u_1+1)}, (α → Prop) → Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} {p : α → Prop}, @subtype.{u_1+2} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1} → pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} {p : α → Prop}, @subtype.{u_1+2} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Define the equivalence relation on pre-games. Two pre-games
 `x`, `y` are equivalent if `x ≤ y` and `y ≤ x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  local infix ` ≈ ` := surreal.equiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='surreal.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 264, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) → @subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The equivalence on numeric pre-games.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  instance surreal.setoid : setoid {x // pgame.numeric x} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/setoid.lean&#x27;, &#x27;line&#x27;: 10, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)}, (α → Prop) → Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  ⟨λ x y, x.1.equiv y.1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pgame.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} {p : α → Prop}, @subtype.{u_1+2} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1} → pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_1+1)} {p : α → Prop}, @subtype.{u_1+2} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Define the equivalence relation on pre-games. Two pre-games
 `x`, `y` are equivalent if `x ≤ y` and `y ≤ x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269   λ x, pgame.equiv_refl _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.equiv_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 413, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x : pgame.{u_1}), pgame.equiv.{u_1} x x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270   λ x y, pgame.equiv_symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.equiv_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 414, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.equiv.{u_1} x y → pgame.equiv.{u_1} y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271   λ x y z, pgame.equiv_trans⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.equiv_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 415, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y z : pgame.{u_1}}, pgame.equiv.{u_1} x y → pgame.equiv.{u_1} y z → pgame.equiv.{u_1} x z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  /-- The type of surreal numbers. These are the numeric pre-games quotiented</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275    the order becomes a total order. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  def surreal := quotient surreal.setoid</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal.setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 267, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='setoid.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  namespace surreal</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  open pgame</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  /-- Construct a surreal number from a numeric pre-game. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  def mk (x : pgame) (h : x.numeric) : surreal := quotient.mk ⟨x, h⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Sort u} [s : setoid.{u} α], α → @quotient.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  instance : has_zero surreal :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  { zero := ⟦⟨0, numeric_zero⟩⟧ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.numeric_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 162, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type (u_1+1)} [s : setoid.{(max 1 (u_1+2))} α], α → @quotient.{(max 1 (u_1+2))} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.numeric.{u_1} (@has_zero.zero.{u_1+1} pgame.{u_1} pgame.has_zero.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [s : setoid.{(max 1 (u_1+2))} α], α → @quotient.{(max 1 (u_1+2))} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286  instance : has_one surreal :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 310, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  { one := ⟦⟨1, numeric_one⟩⟧ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.numeric_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 164, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type (u_1+1)} [s : setoid.{(max 1 (u_1+2))} α], α → @quotient.{(max 1 (u_1+2))} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.numeric.{u_1} (@has_one.one.{u_1+1} pgame.{u_1} pgame.has_one.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [s : setoid.{(max 1 (u_1+2))} α], α → @quotient.{(max 1 (u_1+2))} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  instance : inhabited surreal := ⟨0⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  /-- Lift an equivalence-respecting function on pre-games to surreals. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  def lift {α} (f : ∀ x, numeric x → α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_3+2} pgame.{u_3} (λ (x : pgame.{u_3}), pgame.numeric.{u_3} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Sort u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293    (H : ∀ {x y} (hx : numeric x) (hy : numeric y), x.equiv y → f x hx = f y hy) : surreal → α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_fun_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2} → pgame.{u_2} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (_a : @subtype.{u_3+2} pgame.{u_3} (λ (x : pgame.{u_3}), pgame.numeric.{u_3} x)), @eq.{u_1} α (surreal.lift.{u_1 u_3} α (λ (y : pgame.{u_3}) (oy : pgame.numeric.{u_3} y), f x₁ y ox₁ oy) (λ (y₁ y₂ : pgame.{u_3}) (oy₁ : pgame.numeric.{u_3} y₁) (oy₂ : pgame.numeric.{u_3} y₂) (h : pgame.equiv.{u_3} y₁ y₂), H x₁ y₁ x₁ y₂ ox₁ oy₁ ox₁ oy₂ (pgame.equiv_refl.{u_2} x₁) h) (@quotient.mk.{(max 1 (u_3+2))} (@subtype.{u_3+2} pgame.{u_3} (λ (x : pgame.{u_3}), pgame.numeric.{u_3} x)) surreal.setoid.{u_3} _a)) (surreal.lift.{u_1 u_3} α (λ (y : pgame.{u_3}) (oy : pgame.numeric.{u_3} y), f x₂ y ox₂ oy) (λ (y₁ y₂ : pgame.{u_3}) (oy₁ : pgame.numeric.{u_3} y₁) (oy₂ : pgame.numeric.{u_3} y₂) (h : pgame.equiv.{u_3} y₁ y₂), H x₂ y₁ x₂ y₂ ox₂ oy₁ ox₂ oy₂ (pgame.equiv_refl.{u_2} x₂) h) (@quotient.mk.{(max 1 (u_3+2))} (@subtype.{u_3+2} pgame.{u_3} (λ (x : pgame.{u_3}), pgame.numeric.{u_3} x)) surreal.setoid.{u_3} _a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : pgame.{u_2}), pgame.numeric.{u_2} x → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : pgame.{u_2}), pgame.numeric.{u_2} x → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Sort u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Define the equivalence relation on pre-games. Two pre-games
 `x`, `y` are equivalent if `x ≤ y` and `y ≤ x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  quotient.lift (λ x : {x // numeric x}, f x.1 x.2) (λ x y, H x.2 y.2)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort u} {β : Sort v} [s : setoid.{u} α] (f : α → β), (∀ (a b : α), @has_equiv.equiv.{u} α (@setoid_has_equiv.{u} α s) a b → @eq.{v} β (f a) (f b)) → @quotient.{u} α s → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type (u_2+1)}, (α → Prop) → Type (u_2+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : pgame.{u_2}), pgame.numeric.{u_2} x → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_2+2} pgame.{u_2} (λ (x : pgame.{u_2}), pgame.numeric.{u_2} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (u_2+1)} {p : α → Prop}, @subtype.{u_2+2} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{u_2+2} pgame.{u_2} (λ (x : pgame.{u_2}), pgame.numeric.{u_2} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u_2+1)} {p : α → Prop} (c : @subtype.{u_2+2} α p), p (@subtype.val.{u_2+2} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@subtype.{u_2+2} pgame.{u_2} (λ (x : pgame.{u_2}), pgame.numeric.{u_2} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_2+2} pgame.{u_2} (λ (x : pgame.{u_2}), pgame.numeric.{u_2} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : pgame.{u_2}} (hx : pgame.numeric.{u_2} x) (hy : pgame.numeric.{u_2} y), pgame.equiv.{u_2} x y → @eq.{u_1} α (f x hx) (f y hy)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_2+2} pgame.{u_2} (λ (x : pgame.{u_2}), pgame.numeric.{u_2} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u_2+1)} {p : α → Prop} (c : @subtype.{u_2+2} α p), p (@subtype.val.{u_2+2} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{u_2+2} pgame.{u_2} (λ (x : pgame.{u_2}), pgame.numeric.{u_2} x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u_2+1)} {p : α → Prop} (c : @subtype.{u_2+2} α p), p (@subtype.val.{u_2+2} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  /-- Lift a binary equivalence-respecting function on pre-games to surreals. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  def lift₂ {α} (f : ∀ x y, numeric x → numeric y → α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Sort u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298    (H : ∀ {x₁ y₁ x₂ y₂} (ox₁ : numeric x₁) (oy₁ : numeric y₁) (ox₂ : numeric x₂) (oy₂ : numeric y₂),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.numeric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='pgame.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A pre-game is numeric if
 everything in the L set is less than everything in the R set,
 and all the elements of L and R are also numeric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299      x₁.equiv x₂ → y₁.equiv y₂ → f x₁ y₁ ox₁ oy₁ = f x₂ y₂ ox₂ oy₂) : surreal → surreal → α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pgame.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_2} → pgame.{u_2} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.{u_3} → pgame.{u_3} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : pgame.{u_2}) (y : pgame.{u_3}), pgame.numeric.{u_2} x → pgame.numeric.{u_3} y → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_3} y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : pgame.{u_2}) (y : pgame.{u_3}), pgame.numeric.{u_2} x → pgame.numeric.{u_3} y → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_3} y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Sort u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Define the equivalence relation on pre-games. Two pre-games
 `x`, `y` are equivalent if `x ≤ y` and `y ≤ x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Define the equivalence relation on pre-games. Two pre-games
 `x`, `y` are equivalent if `x ≤ y` and `y ≤ x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  lift (λ x ox, lift (λ y oy, f x y ox oy) (λ y₁ y₂ oy₁ oy₂ h, H _ _ _ _ (equiv_refl _) h))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='surreal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='surreal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='pgame.equiv_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 413, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort u_1} (f : Π (x : pgame.{u_2}), pgame.numeric.{u_2} x → α), (∀ {x y : pgame.{u_2}} (hx : pgame.numeric.{u_2} x) (hy : pgame.numeric.{u_2} y), pgame.equiv.{u_2} x y → @eq.{u_1} α (f x hx) (f y hy)) → surreal.{u_2} → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u_1} (f : Π (x : pgame.{u_2}), pgame.numeric.{u_2} x → α), (∀ {x y : pgame.{u_2}} (hx : pgame.numeric.{u_2} x) (hy : pgame.numeric.{u_2} y), pgame.equiv.{u_2} x y → @eq.{u_1} α (f x hx) (f y hy)) → surreal.{u_2} → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_3} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x : pgame.{u_2}) (y : pgame.{u_3}), pgame.numeric.{u_2} x → pgame.numeric.{u_3} y → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_3} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_3}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_3} y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_3} y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_3} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x₁ : pgame.{u_2}} {y₁ : pgame.{u_3}} {x₂ : pgame.{u_2}} {y₂ : pgame.{u_3}} (ox₁ : pgame.numeric.{u_2} x₁) (oy₁ : pgame.numeric.{u_3} y₁) (ox₂ : pgame.numeric.{u_2} x₂) (oy₂ : pgame.numeric.{u_3} y₂), pgame.equiv.{u_2} x₁ x₂ → pgame.equiv.{u_3} y₁ y₂ → @eq.{u_1} α (f x₁ y₁ ox₁ oy₁) (f x₂ y₂ ox₂ oy₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ (x : pgame.{u_1}), pgame.equiv.{u_1} x x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.equiv.{u_3} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Lift an equivalence-respecting function on pre-games to surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Lift an equivalence-respecting function on pre-games to surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301    (λ x₁ x₂ ox₁ ox₂ h, funext $ quotient.ind $ by exact λ ⟨y, oy⟩, H _ _ _ _ h (equiv_refl _))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient.ind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.equiv_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 413, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_2}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_2} x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_2} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Sort u} [s : setoid.{u} α] {β : @quotient.{u} α s → Prop}, (∀ (a : α), β (@quotient.mk.{u} α s a)) → ∀ (q : @quotient.{u} α s), β q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x₁ : pgame.{u_2}} {y₁ : pgame.{u_3}} {x₂ : pgame.{u_2}} {y₂ : pgame.{u_3}} (ox₁ : pgame.numeric.{u_2} x₁) (oy₁ : pgame.numeric.{u_3} y₁) (ox₂ : pgame.numeric.{u_2} x₂) (oy₂ : pgame.numeric.{u_3} y₂), pgame.equiv.{u_2} x₁ x₂ → pgame.equiv.{u_3} y₁ y₂ → @eq.{u_1} α (f x₁ y₁ ox₁ oy₁) (f x₂ y₂ ox₂ oy₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.equiv.{u_2} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : pgame.{u_3}), pgame.equiv.{u_3} x x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='lime'><a title='α : Sort ?l_1,
f : Π (x : pgame.{?l_2}) (y : pgame.{?l_3}), pgame.numeric.{?l_2} x → pgame.numeric.{?l_3} y → α,
H :
  ∀ {x₁ : pgame.{?l_2}} {y₁ : pgame.{?l_3}} {x₂ : pgame.{?l_2}} {y₂ : pgame.{?l_3}}
  (ox₁ : pgame.numeric.{?l_2} x₁) (oy₁ : pgame.numeric.{?l_3} y₁) (ox₂ : pgame.numeric.{?l_2} x₂)
  (oy₂ : pgame.numeric.{?l_3} y₂),
    pgame.equiv.{?l_2} x₁ x₂ →
    pgame.equiv.{?l_3} y₁ y₂ → @eq.{?l_1} α (f x₁ y₁ ox₁ oy₁) (f x₂ y₂ ox₂ oy₂),
x₁ x₂ : pgame.{?l_2},
ox₁ : pgame.numeric.{?l_2} x₁,
ox₂ : pgame.numeric.{?l_2} x₂,
h : pgame.equiv.{?l_2} x₁ x₂
⊢ ∀ (a : @subtype.{?l_3+2} pgame.{?l_3} (λ (x : pgame.{?l_3}), pgame.numeric.{?l_3} x)),
    @eq.{?l_1} α
      (@surreal.lift.{?l_1 ?l_3} α (λ (y : pgame.{?l_3}) (oy : pgame.numeric.{?l_3} y), f x₁ y ox₁ oy)
         (λ (y₁ y₂ : pgame.{?l_3}) (oy₁ : pgame.numeric.{?l_3} y₁) (oy₂ : pgame.numeric.{?l_3} y₂)
          (h : pgame.equiv.{?l_3} y₁ y₂),
            @H x₁ y₁ x₁ y₂ ox₁ oy₁ ox₁ oy₂ (pgame.equiv_refl.{?l_2} x₁) h)
         (@quotient.mk.{(max 1 (?l_3+2))}
            (@subtype.{?l_3+2} pgame.{?l_3} (λ (x : pgame.{?l_3}), pgame.numeric.{?l_3} x))
            surreal.setoid.{?l_3}
            a))
      (@surreal.lift.{?l_1 ?l_3} α (λ (y : pgame.{?l_3}) (oy : pgame.numeric.{?l_3} y), f x₂ y ox₂ oy)
         (λ (y₁ y₂ : pgame.{?l_3}) (oy₁ : pgame.numeric.{?l_3} y₁) (oy₂ : pgame.numeric.{?l_3} y₂)
          (h : pgame.equiv.{?l_3} y₁ y₂),
            @H x₂ y₁ x₂ y₂ ox₂ oy₁ ox₂ oy₂ (pgame.equiv_refl.{?l_2} x₂) h)
         (@quotient.mk.{(max 1 (?l_3+2))}
            (@subtype.{?l_3+2} pgame.{?l_3} (λ (x : pgame.{?l_3}), pgame.numeric.{?l_3} x))
            surreal.setoid.{?l_3}
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  /-- The relation `x ≤ y` on surreals. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304  def le : surreal → surreal → Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305  lift₂ (λ x y _ _, x ≤ y) (λ x₁ y₁ x₂ y₂ _ _ _ _ hx hy, propext (le_congr hx hy))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='surreal.lift₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='propext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.le_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 297, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/propext.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 423, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort u_1} (f : Π (x : pgame.{u_2}) (y : pgame.{u_3}), pgame.numeric.{u_2} x → pgame.numeric.{u_3} y → α), (∀ {x₁ : pgame.{u_2}} {y₁ : pgame.{u_3}} {x₂ : pgame.{u_2}} {y₂ : pgame.{u_3}} (ox₁ : pgame.numeric.{u_2} x₁) (oy₁ : pgame.numeric.{u_3} y₁) (ox₂ : pgame.numeric.{u_2} x₂) (oy₂ : pgame.numeric.{u_3} y₂), pgame.equiv.{u_2} x₁ x₂ → pgame.equiv.{u_3} y₁ y₂ → @eq.{u_1} α (f x₁ y₁ ox₁ oy₁) (f x₂ y₂ ox₂ oy₂)) → surreal.{u_2} → surreal.{u_3} → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_le.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, iff a b → @eq.{1} Prop a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x₁ y₁ x₂ y₂ : pgame.{u_1}}, pgame.equiv.{u_1} x₁ x₂ → pgame.equiv.{u_1} y₁ y₂ → iff (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x₁ y₁) (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x₂ y₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Lift a binary equivalence-respecting function on pre-games to surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307  /-- The relation `x &lt; y` on surreals. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308  def lt : surreal → surreal → Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  lift₂ (λ x y _ _, x &lt; y) (λ x₁ y₁ x₂ y₂ _ _ _ _ hx hy, propext (lt_congr hx hy))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='surreal.lift₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='propext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.lt_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 297, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/propext.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 426, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort u_1} (f : Π (x : pgame.{u_2}) (y : pgame.{u_3}), pgame.numeric.{u_2} x → pgame.numeric.{u_3} y → α), (∀ {x₁ : pgame.{u_2}} {y₁ : pgame.{u_3}} {x₂ : pgame.{u_2}} {y₂ : pgame.{u_3}} (ox₁ : pgame.numeric.{u_2} x₁) (oy₁ : pgame.numeric.{u_3} y₁) (ox₂ : pgame.numeric.{u_2} x₂) (oy₂ : pgame.numeric.{u_3} y₂), pgame.equiv.{u_2} x₁ x₂ → pgame.equiv.{u_3} y₁ y₂ → @eq.{u_1} α (f x₁ y₁ ox₁ oy₁) (f x₂ y₂ ox₂ oy₂)) → surreal.{u_2} → surreal.{u_3} → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_lt.{u_1+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, iff a b → @eq.{1} Prop a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x₁ y₁ x₂ y₂ : pgame.{u_1}}, pgame.equiv.{u_1} x₁ x₂ → pgame.equiv.{u_1} y₁ y₂ → iff (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x₁ y₁) (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x₂ y₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Lift a binary equivalence-respecting function on pre-games to surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  theorem not_le : ∀ {x y : surreal}, ¬ le x y ↔ lt y x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 304, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 308, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1} → surreal.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@preorder.le.{u_1+1} surreal.{u_1} surreal.preorder.{u_1} (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) surreal.setoid.{u_1}) (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x ox)) (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) surreal.setoid.{u_1}) (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y oy)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1} → surreal.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The relation `x ≤ y` on surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The relation `x &lt; y` on surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  by rintro ⟨⟨x, ox⟩⟩ ⟨⟨y, oy⟩⟩; exact not_le</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='pgame.not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (not (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y)) (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='⊢ ∀ {x y : surreal.{u_1}}, iff (not (surreal.le.{u_1} x y)) (surreal.lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ ∀ {x y : surreal.{u_1}}, iff (not (surreal.le.{u_1} x y)) (surreal.lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314  instance : preorder surreal :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  { le := le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='surreal.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 304, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='surreal.{u_1} → surreal.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The relation `x ≤ y` on surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316    lt := lt,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='surreal.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 308, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='surreal.{u_1} → surreal.{u_1} → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The relation `x &lt; y` on surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317    le_refl := by rintro ⟨⟨x, ox⟩⟩; exact le_refl _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='pgame.le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : pgame.{u_1}), @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='⊢ ∀ (a : surreal.{?l_1}), surreal.le.{?l_1} a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318    le_trans := by rintro ⟨⟨x, ox⟩⟩ ⟨⟨y, oy⟩⟩ ⟨⟨z, oz⟩⟩; exact le_trans,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='blue'><a title='pgame.le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 381, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y z : pgame.{u_1}}, @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y z → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='⊢ ∀ (a b c : surreal.{?l_1}), surreal.le.{?l_1} a b → surreal.le.{?l_1} b c → surreal.le.{?l_1} a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319    lt_iff_le_not_le := by rintro ⟨⟨x, ox⟩⟩ ⟨⟨y, oy⟩⟩; exact lt_iff_le_not_le ox oy }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='pgame.lt_iff_le_not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 159, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → iff (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y) (and (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y) (not (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} y x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='On numeric pre-games, `&lt;` and `≤` satisfy the axioms of a partial order (even though they
   don&#x27;t on all pre-games).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='⊢ ∀ (a b : surreal.{?l_1}), iff (surreal.lt.{?l_1} a b) (and (surreal.le.{?l_1} a b) (not (surreal.le.{?l_1} b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321  instance : partial_order surreal :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322  { le_antisymm := by rintro ⟨⟨x, ox⟩⟩ ⟨⟨y, oy⟩⟩ h₁ h₂; exact quot.sound ⟨h₁, h₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='blue'><a title='quot.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u_1+1)} {r : α → α → Prop} {a b : α}, r a b → @eq.{u_1+2} (@quot.{u_1+2} α r) (@quot.mk.{u_1+2} α r a) (@quot.mk.{u_1+2} α r b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.le.{u_1} (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) surreal.setoid.{u_1}) (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x ox)) (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) surreal.setoid.{u_1}) (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y oy))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='surreal.le.{u_1} (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) surreal.setoid.{u_1}) (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y oy)) (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)) surreal.setoid.{u_1}) (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x ox))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='⊢ ∀ (a b : surreal.{?l_1}), surreal.le.{?l_1} a b → surreal.le.{?l_1} b a → @eq.{?l_1+2} surreal.{?l_1} a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323    ..surreal.preorder }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='surreal.preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 314, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='preorder.{u_1+1} surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  instance : linear_order surreal :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  { le_total := by rintro ⟨⟨x, ox⟩⟩ ⟨⟨y, oy⟩⟩; classical; exact</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='⊢ ∀ (a b : surreal.{?l_1}),
    or (@preorder.le.{?l_1+1} surreal.{?l_1} surreal.preorder.{?l_1} a b)
      (@preorder.le.{?l_1+1} surreal.{?l_1} surreal.preorder.{?l_1} b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327      or_iff_not_imp_left.2 (λ h, le_of_lt oy ox (pgame.not_le.1 h)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='or_iff_not_imp_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pgame.le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 154, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (or a b) (not a → b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → @has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} x y → @has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, iff (not (@has_le.le.{u_1+1} pgame.{u_1} pgame.has_le.{u_1} x y)) (@has_lt.lt.{u_1+1} pgame.{u_1} pgame.has_lt.{u_1} y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ ∀ (a b : surreal.{?l_1}),
    or (@preorder.le.{?l_1+1} surreal.{?l_1} surreal.preorder.{?l_1} a b)
      (@preorder.le.{?l_1+1} surreal.{?l_1} surreal.preorder.{?l_1} b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328    ..surreal.partial_order }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='surreal.partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='partial_order.{u_1+1} surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330  def add : surreal → surreal → surreal :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331  surreal.lift₂</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='surreal.lift₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 297, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort u_1} (f : Π (x : pgame.{u_2}) (y : pgame.{u_3}), pgame.numeric.{u_2} x → pgame.numeric.{u_3} y → α), (∀ {x₁ : pgame.{u_2}} {y₁ : pgame.{u_3}} {x₂ : pgame.{u_2}} {y₂ : pgame.{u_3}} (ox₁ : pgame.numeric.{u_2} x₁) (oy₁ : pgame.numeric.{u_3} y₁) (ox₂ : pgame.numeric.{u_2} x₂) (oy₂ : pgame.numeric.{u_3} y₂), pgame.equiv.{u_2} x₁ x₂ → pgame.equiv.{u_3} y₁ y₂ → @eq.{u_1} α (f x₁ y₁ ox₁ oy₁) (f x₂ y₂ ox₂ oy₂)) → surreal.{u_2} → surreal.{u_3} → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Lift a binary equivalence-respecting function on pre-games to surreals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332    (λ (x y : pgame) (ox) (oy), ⟦⟨x + y, numeric_add ox oy⟩⟧)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pgame'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.numeric_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='oy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 229, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type (u_1+1)} [s : setoid.{(max 1 (u_1+2))} α], α → @quotient.{(max 1 (u_1+2))} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : pgame.{u_1}}, pgame.numeric.{u_1} x → pgame.numeric.{u_1} y → pgame.numeric.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [s : setoid.{(max 1 (u_1+2))} α], α → @quotient.{(max 1 (u_1+2))} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The type of pre-games, before we have quotiented
 by extensionality. In ZFC, a combinatorial game is constructed from
 two sets of combinatorial games that have been constructed at an earlier
 stage. To do this in type theory, we say that a pre-game is built
 inductively from two families of pre-games indexed over any type
 in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,
 reflecting that it is a proper class in ZFC.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333    (λ x₁ y₁ x₂ y₂ _ _ _ _ hx hy, quot.sound (pgame.add_congr hx hy))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pgame.add_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 824, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.numeric.{u_1} y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → @eq.{u} (@quot.{u} α r) (@quot.mk.{u} α r a) (@quot.mk.{u} α r b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {w x y z : pgame.{u_1}}, pgame.equiv.{u_1} w x → pgame.equiv.{u_1} y z → pgame.equiv.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} w y) (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pgame.equiv.{u_1} y₁ y₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335  instance : has_add surreal := ⟨add⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='surreal.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 330, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='surreal.{u_1} → surreal.{u_1} → surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337  theorem add_assoc : ∀ (x y z : surreal), (x + y) + z = x + (y + z) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u_1+1)} [c : has_add.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='surreal.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ ∀ (x y z : surreal.{u_1}),
    @eq.{u_1+2} surreal.{u_1}
      (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
         (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} x y)
         z)
      (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} x
         (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339    rintros ⟨x⟩ ⟨y⟩ ⟨z⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ ∀ (x y z : surreal.{u_1}),
    @eq.{u_1+2} surreal.{u_1}
      (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
         (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} x y)
         z)
      (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} x
         (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y z : @subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
⊢ @eq.{u_1+2} surreal.{u_1}
    (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
       (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             x)
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             y))
       (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
          (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             surreal.setoid.{u_1})
          z))
    (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
       (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
          (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             surreal.setoid.{u_1})
          x)
       (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             y)
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340    apply quot.sound,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='quot.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u_1+1)} {r : α → α → Prop} {a b : α}, r a b → @eq.{u_1+2} (@quot.{u_1+2} α r) (@quot.mk.{u_1+2} α r a) (@quot.mk.{u_1+2} α r b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y z : @subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
⊢ @eq.{u_1+2} surreal.{u_1}
    (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
       (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             x)
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             y))
       (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
          (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             surreal.setoid.{u_1})
          z))
    (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
       (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
          (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             surreal.setoid.{u_1})
          x)
       (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1}
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             y)
          (@quot.mk.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
             (@setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
                surreal.setoid.{u_1})
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y z : @subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
⊢ @setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
    surreal.setoid.{u_1}
    (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
       (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (surreal.lift._proof_1.{u_1} x)
                   (surreal.lift._proof_1.{u_1} y))))
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
       (@pgame.numeric_add.{u_1}
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (surreal.lift._proof_1.{u_1} x)
                   (surreal.lift._proof_1.{u_1} y))))
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
          (surreal.lift._proof_1.{u_1}
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (surreal.lift._proof_1.{u_1} x)
                   (surreal.lift._proof_1.{u_1} y))))
          (surreal.lift._proof_1.{u_1} z)))
    (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
       (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
                   (surreal.lift._proof_1.{u_1} y)
                   (surreal.lift._proof_1.{u_1} z)))))
       (@pgame.numeric_add.{u_1} (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
                   (surreal.lift._proof_1.{u_1} y)
                   (surreal.lift._proof_1.{u_1} z))))
          (surreal.lift._proof_1.{u_1} x)
          (surreal.lift._proof_1.{u_1}
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
                   (surreal.lift._proof_1.{u_1} y)
                   (surreal.lift._proof_1.{u_1} z))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341    exact add_assoc_equiv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pgame.add_assoc_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/pgame.lean&#x27;, &#x27;line&#x27;: 766, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y z : pgame.{u_1}}, pgame.equiv.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x y) z) (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} x (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1} y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y z : @subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
⊢ @setoid.r.{(max 1 (u_1+2))} (@subtype.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x))
    surreal.setoid.{u_1}
    (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
       (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (surreal.lift._proof_1.{u_1} x)
                   (surreal.lift._proof_1.{u_1} y))))
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
       (@pgame.numeric_add.{u_1}
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (surreal.lift._proof_1.{u_1} x)
                   (surreal.lift._proof_1.{u_1} y))))
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
          (surreal.lift._proof_1.{u_1}
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (surreal.lift._proof_1.{u_1} x)
                   (surreal.lift._proof_1.{u_1} y))))
          (surreal.lift._proof_1.{u_1} z)))
    (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
       (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
                   (surreal.lift._proof_1.{u_1} y)
                   (surreal.lift._proof_1.{u_1} z)))))
       (@pgame.numeric_add.{u_1} (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) x)
          (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
                   (surreal.lift._proof_1.{u_1} y)
                   (surreal.lift._proof_1.{u_1} z))))
          (surreal.lift._proof_1.{u_1} x)
          (surreal.lift._proof_1.{u_1}
             (@subtype.mk.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x)
                (@has_add.add.{u_1+1} pgame.{u_1} pgame.has_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z))
                (@pgame.numeric_add.{u_1}
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) y)
                   (@subtype.val.{u_1+2} pgame.{u_1} (λ (x : pgame.{u_1}), pgame.numeric.{u_1} x) z)
                   (surreal.lift._proof_1.{u_1} y)
                   (surreal.lift._proof_1.{u_1} z))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344  instance : add_semigroup surreal :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_semigroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345  { add_assoc := add_assoc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='surreal.add_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 337, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ (x y z : surreal.{u_1}), @eq.{u_1+2} surreal.{u_1} (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} x y) z) (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} x (@has_add.add.{u_1+1} surreal.{u_1} surreal.has_add.{u_1} y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346    ..(by apply_instance : has_add surreal) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='has_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='surreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The type of surreal numbers. These are the numeric pre-games quotiented
 by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient,
 the order becomes a total order.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='⊢ has_add.{?l_1+1} surreal.{?l_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348  -- We conclude with some ideas for further work on surreals; these would make fun projects.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350  -- TODO construct the remaining instances:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351  --   add_monoid, add_group, add_comm_semigroup, add_comm_group, ordered_comm_group,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352  -- as per the instances for `game`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  -- TODO define the inclusion of groups `surreal → game`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  -- TODO define the dyadic rationals, and show they map into the surreals via the formula</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  --   m / 2^n ↦ { (m-1) / 2^n | (m+1) / 2^n }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358  -- TODO show this is a group homomorphism, and injective</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  -- TODO map the reals into the surreals, using dyadic Dedekind cuts</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  -- TODO show this is a group homomorphism, and injective</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363  -- TODO define the field structure on the surreals</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364  -- TODO show the maps from the dyadic rationals and from the reals into the surreals are multiplicative</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366  end surreal</code></pre>
</body>