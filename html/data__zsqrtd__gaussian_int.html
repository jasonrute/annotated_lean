<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Chris Hughes. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Chris Hughes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import data.zsqrtd.basic data.complex.basic ring_theory.principal_ideal_domain</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/principal_ideal_domain.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.zmod.quadratic_reciprocity</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zmod/quadratic_reciprocity.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  # Gaussian integers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  The Gaussian integers are complex integer, complex numbers whose real and imaginary parts are both</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  integers.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  ## Main definitions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  The Euclidean domain structure on `ℤ[i]` is defined in this file.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  The homomorphism `to_complex` into the complex numbers is also defined in this file.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  ## Main statements</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  `prime_iff_mod_four_eq_three_of_nat_prime`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  ## Notations</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  This file uses the local notation `ℤ[i]` for `gaussian_int`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  ## Implementation notes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  Gaussian integers are implemented using the more general definition `zsqrtd`, the type of integers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  adjoined a square root of `d`, in this case `-1`. The definition is reducible, so that properties</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  and definitions about `zsqrtd` can easily be used.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  open zsqrtd complex</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  @[reducible] def gaussian_int : Type := zsqrtd (-1)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='zsqrtd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='int → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The ring of integers adjoined with a square root of `d`.
 These have the form `a + b √d` where `a b : ℤ`. The components
 are called `re` and `im` by analogy to the negative `d` case,
 but of course both parts are real here since `d` is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  local notation `ℤ[i]` := gaussian_int</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  namespace gaussian_int</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  instance : has_repr ℤ[i] := ⟨λ x, &quot;⟨&quot; ++ repr x.re ++ &quot;, &quot; ++ repr x.im ++ &quot;⟩&quot;⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='repr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/repr.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/repr.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/repr.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type} [c : has_append.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : has_repr.{u} α], α → string'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_append.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type} [c : has_append.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : has_repr.{u} α], α → string'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_append.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  instance : comm_ring ℤ[i] := zsqrtd.comm_ring</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='zsqrtd.comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {d : int}, comm_ring.{0} (zsqrtd d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  def to_complex (x : ℤ[i]) : ℂ := x.re + x.im * I</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  instance : has_coe (ℤ[i]) ℂ := ⟨to_complex⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int.to_complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort v → Sort (max 1 (imax u v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='gaussian_int → complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  lemma to_complex_def (x : ℤ[i]) : (x : ℂ) = x.re + x.im * I := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  lemma to_complex_def&#x27; (x y : ℤ) : ((⟨x, y⟩ : ℤ[i]) : ℂ) = x + y * I := by simp [to_complex_def]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  lemma to_complex_def₂ (x : ℤ[i]) : (x : ℂ) = ⟨x.re, x.im⟩ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  by apply complex.ext; simp [to_complex_def]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  instance to_complex.is_ring_hom : is_ring_hom to_complex:=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  by refine_struct {..}; intros; apply complex.ext; simp [to_complex]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 291, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 291, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`refine_struct { .. }` acts like `refine` but works only with structure instance
literals. It creates a goal for each missing field and tags it with the name of the
field so that `have_field` can be used to generically refer to the field currently
being refined.

As an example, we can use `refine_struct` to automate the construction semigroup
instances:
```lean
refine_struct ( { .. } : semigroup α ),
-- case semigroup, mul
-- α : Type u,
-- ⊢ α → α → α

-- case semigroup, mul_assoc
-- α : Type u,
-- ⊢ ∀ (a b c : α), a * b * c = a * (b * c)
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`refine_struct { .. }` acts like `refine` but works only with structure instance
literals. It creates a goal for each missing field and tags it with the name of the
field so that `have_field` can be used to generically refer to the field currently
being refined.

As an example, we can use `refine_struct` to automate the construction semigroup
instances:
```lean
refine_struct ( { .. } : semigroup α ),
-- case semigroup, mul
-- α : Type u,
-- ⊢ α → α → α

-- case semigroup, mul_assoc
-- α : Type u,
-- ⊢ ∀ (a b c : α), a * b * c = a * (b * c)
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine_struct'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine_struct'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  instance : is_ring_hom (coe : ℤ[i] → ℂ) := to_complex.is_ring_hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simp] lemma to_real_re (x : ℤ[i]) : ((x.re : ℤ) : ℝ) = (x : ℂ).re := by simp [to_complex_def]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  @[simp] lemma to_real_im (x : ℤ[i]) : ((x.im : ℤ) : ℝ) = (x : ℂ).im := by simp [to_complex_def]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  @[simp] lemma to_complex_re (x y : ℤ) : ((⟨x, y⟩ : ℤ[i]) : ℂ).re = x := by simp [to_complex_def]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simp] lemma to_complex_im (x y : ℤ) : ((⟨x, y⟩ : ℤ[i]) : ℂ).im = y := by simp [to_complex_def]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  @[simp] lemma to_complex_add (x y : ℤ[i]) : ((x + y : ℤ[i]) : ℂ) = x + y := is_ring_hom.map_add coe</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_ring_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type} [_inst_1 : ring.{0} α] [_inst_2 : ring.{0} β] (f : α → β) [c : @is_ring_hom.{0 0} α β _inst_1 _inst_2 f] {x y : α}, @eq.{1} β (f (@has_add.add.{0} α (@distrib.to_has_add.{0} α (@ring.to_distrib.{0} α _inst_1)) x y)) (@has_add.add.{0} β (@distrib.to_has_add.{0} β (@ring.to_distrib.{0} β _inst_2)) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  @[simp] lemma to_complex_mul (x y : ℤ[i]) : ((x * y : ℤ[i]) : ℂ) = x * y := is_ring_hom.map_mul coe</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_ring_hom.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (f : α → β) [c : @is_ring_hom.{u v} α β _inst_1 _inst_2 f] {x y : α}, @eq.{v+1} β (f (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) x y)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β _inst_2))) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  @[simp] lemma to_complex_one : ((1 : ℤ[i]) : ℂ) = 1 := is_ring_hom.map_one coe</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  @[simp] lemma to_complex_zero : ((0 : ℤ[i]) : ℂ) = 0 := is_ring_hom.map_zero coe</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  @[simp] lemma to_complex_neg (x : ℤ[i]) : ((-x : ℤ[i]) : ℂ) = -x := is_ring_hom.map_neg coe</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  @[simp] lemma to_complex_sub (x y : ℤ[i]) : ((x - y : ℤ[i]) : ℂ) = x - y := is_ring_hom.map_sub coe</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  @[simp] lemma to_complex_inj {x y : ℤ[i]} : (x : ℂ) = y ↔ x = y :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  by cases x; cases y; simp [to_complex_def₂]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  @[simp] lemma to_complex_eq_zero {x : ℤ[i]} : (x : ℂ) = 0 ↔ x = 0 :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  by rw [← to_complex_zero, to_complex_inj]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  @[simp] lemma nat_cast_real_norm (x : ℤ[i]) : (x.norm : ℝ) = (x : ℂ).norm_sq :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  by rw [norm, norm_sq]; simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  @[simp] lemma nat_cast_complex_norm (x : ℤ[i]) : (x.norm : ℂ) = (x : ℂ).norm_sq :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  by cases x; rw [norm, norm_sq]; simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  lemma norm_nonneg (x : ℤ[i]) : 0 ≤ norm x := norm_nonneg trivial _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='zsqrtd.norm_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='trivial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 262, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {d : int}, @has_le.le.{0} int int.has_le d (@has_zero.zero.{0} int int.has_zero) → ∀ (n : zsqrtd d), @has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) (@zsqrtd.norm d n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  @[simp] lemma norm_eq_zero {x : ℤ[i]} : norm x = 0 ↔ x = 0 :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  by rw [← @int.cast_inj ℝ _ _ _]; simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  lemma norm_pos {x : ℤ[i]} : 0 &lt; norm x ↔ x ≠ 0 :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  by rw [lt_iff_le_and_ne, ne.def, eq_comm, norm_eq_zero]; simp [norm_nonneg]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  @[simp] lemma coe_nat_abs_norm (x : ℤ[i]) : (x.norm.nat_abs : ℤ) = x.norm :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  int.nat_abs_of_nonneg (norm_nonneg _)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  @[simp] lemma nat_cast_nat_abs_norm {α : Type*} [ring α]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    (x : ℤ[i]) : (x.norm.nat_abs : α) = x.norm :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  by rw [← int.cast_coe_nat, coe_nat_abs_norm]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  lemma nat_abs_norm_eq (x : ℤ[i]) : x.norm.nat_abs =</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    x.re.nat_abs * x.re.nat_abs + x.im.nat_abs * x.im.nat_abs :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  int.coe_nat_inj $ begin simp, simp [norm] end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  protected def div (x y : ℤ[i]) : ℤ[i] :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  let n := (rat.of_int (norm y))⁻¹ in let c := y.conj in</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  ⟨round (rat.of_int (x * c).re * n : ℚ),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109   round (rat.of_int (x * c).im * n : ℚ)⟩</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  instance : has_div ℤ[i] := ⟨gaussian_int.div⟩</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  lemma div_def (x y : ℤ[i]) : x / y = ⟨round ((x * conj y).re / norm y : ℚ),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    round ((x * conj y).im / norm y : ℚ)⟩ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  show zsqrtd.mk _ _ = _, by simp [rat.of_int_eq_mk, rat.mk_eq_div, div_eq_mul_inv]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  lemma to_complex_div_re (x y : ℤ[i]) : ((x / y : ℤ[i]) : ℂ).re = round ((x / y : ℂ).re) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  by rw [div_def, ← @rat.cast_round ℝ _ _];</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    simp [-rat.cast_round, mul_assoc, div_eq_mul_inv, mul_add, add_mul]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  lemma to_complex_div_im (x y : ℤ[i]) : ((x / y : ℤ[i]) : ℂ).im = round ((x / y : ℂ).im) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  by rw [div_def, ← @rat.cast_round ℝ _ _, ← @rat.cast_round ℝ _ _];</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    simp [-rat.cast_round, mul_assoc, div_eq_mul_inv, mul_add, add_mul]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  local notation `abs&#x27;` := _root_.abs</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  lemma norm_sq_le_norm_sq_of_re_le_of_im_le {x y : ℂ} (hre : abs&#x27; x.re ≤ abs&#x27; y.re)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    (him : abs&#x27; x.im ≤ abs&#x27; y.im) : x.norm_sq ≤ y.norm_sq :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  by rw [norm_sq, norm_sq, ← _root_.abs_mul_self, _root_.abs_mul,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    ← _root_.abs_mul_self y.re, _root_.abs_mul y.re,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    ← _root_.abs_mul_self x.im, _root_.abs_mul x.im,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    ← _root_.abs_mul_self y.im, _root_.abs_mul y.im]; exact</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  (add_le_add (mul_self_le_mul_self (abs_nonneg _) hre)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    (mul_self_le_mul_self (abs_nonneg _) him))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='abs_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='him'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] (a : α), @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} α _inst_1)))) (@abs.{0} α _inst_1 a) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im)) (@abs.{0} real real.decidable_linear_ordered_comm_group (y.im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='x y : complex,
hre :
  @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.re))
    (@abs.{0} real real.decidable_linear_ordered_comm_group (y.re)),
him :
  @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im))
    (@abs.{0} real real.decidable_linear_ordered_comm_group (y.im))
⊢ @has_le.le.{0} real real.has_le (complex.norm_sq x) (complex.norm_sq y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : complex,
hre :
  @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.re))
    (@abs.{0} real real.decidable_linear_ordered_comm_group (y.re)),
him :
  @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im))
    (@abs.{0} real real.decidable_linear_ordered_comm_group (y.im))
⊢ @has_le.le.{0} real real.has_le (complex.norm_sq x) (complex.norm_sq y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  lemma norm_sq_div_sub_div_lt_one (x y : ℤ[i]) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    ((x / y : ℂ) - ((x / y : ℤ[i]) : ℂ)).norm_sq &lt; 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.norm_sq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  calc ((x / y : ℂ) - ((x / y : ℤ[i]) : ℂ)).norm_sq =</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139      ((x / y : ℂ).re - ((x / y : ℤ[i]) : ℂ).re +</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140      ((x / y : ℂ).im - ((x / y : ℤ[i]) : ℂ).im) * I : ℂ).norm_sq :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='complex.I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141        congr_arg _ $ by apply complex.ext; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), @eq.{u} α a₁ a₂ → @eq.{v} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    ... ≤ (1 / 2 + 1 / 2 * I).norm_sq :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='complex.I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    have abs&#x27; (2 / (2 * 2) : ℝ) = 1 / 2, by rw _root_.abs_of_nonneg; norm_num,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    norm_sq_le_norm_sq_of_re_le_of_im_le</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gaussian_int.norm_sq_le_norm_sq_of_re_le_of_im_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : complex}, @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.re)) (@abs.{0} real real.decidable_linear_ordered_comm_group (y.re)) → @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im)) (@abs.{0} real real.decidable_linear_ordered_comm_group (y.im)) → @has_le.le.{0} real real.has_le (complex.norm_sq x) (complex.norm_sq y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      (by rw [to_complex_div_re]; simp [norm_sq, this];</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146        simpa using abs_sub_round (x / y : ℂ).re)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='x y : gaussian_int,
this :
  @eq.{1} real
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
          (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_one.one.{0} real
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
          (@has_mul.mul.{0} real
             (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))))
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_le.le.{0} real real.has_le
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_sub.sub.{0} complex
              (@add_group_has_sub.{0} complex
                 (@add_comm_group.to_add_group.{0} complex
                    (@ring.to_add_comm_group.{0} complex
                       (@domain.to_ring.{0} complex
                          (@division_ring.to_domain.{0} complex
                             (@field.to_division_ring.{0} complex
                                (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@has_div.div.{0} complex
                     (@division_ring_has_div&#x27;.{0} complex
                        (@field.to_division_ring.{0} complex
                           (@discrete_field.to_field.{0} complex complex.discrete_field)))
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        x)
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        y)).re))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@coe.{1 1} gaussian_int complex
                     (@coe_to_lift.{1 1} gaussian_int complex
                        (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                     (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).re)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_sub.sub.{0} complex
                 (@add_group_has_sub.{0} complex
                    (@add_comm_group.to_add_group.{0} complex
                       (@ring.to_add_comm_group.{0} complex
                          (@domain.to_ring.{0} complex
                             (@division_ring.to_domain.{0} complex
                                (@field.to_division_ring.{0} complex
                                   (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@has_div.div.{0} complex
                        (@division_ring_has_div&#x27;.{0} complex
                           (@field.to_division_ring.{0} complex
                              (@discrete_field.to_field.{0} complex complex.discrete_field)))
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           x)
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           y)).im))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).im)))
              complex.I)).re))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_div.div.{0} complex
              (@division_ring_has_div&#x27;.{0} complex
                 (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
              (@has_one.one.{0} complex complex.has_one)
              (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_div.div.{0} complex
                 (@division_ring_has_div&#x27;.{0} complex
                    (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                 (@has_one.one.{0} complex complex.has_one)
                 (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
              complex.I)).re))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      (by rw [to_complex_div_im]; simp [norm_sq, this];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='gaussian_int.to_complex_div_im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='complex.norm_sq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x y : gaussian_int), @eq.{1} real ((@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).im) (@coe.{1 1} int real (@coe_to_lift.{1 1} int real (@coe_base.{1 1} int real (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)) (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))))) (@round.{0} real real.discrete_linear_ordered_field real.floor_ring ((@has_div.div.{0} complex (@division_ring_has_div&#x27;.{0} complex (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field))) (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) x) (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) y)).im)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real (@abs.{0} real real.decidable_linear_ordered_comm_group (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))) (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))))) (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='x y : gaussian_int,
this :
  @eq.{1} real
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
          (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_one.one.{0} real
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
          (@has_mul.mul.{0} real
             (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))))
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_le.le.{0} real real.has_le
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_sub.sub.{0} complex
              (@add_group_has_sub.{0} complex
                 (@add_comm_group.to_add_group.{0} complex
                    (@ring.to_add_comm_group.{0} complex
                       (@domain.to_ring.{0} complex
                          (@division_ring.to_domain.{0} complex
                             (@field.to_division_ring.{0} complex
                                (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@has_div.div.{0} complex
                     (@division_ring_has_div&#x27;.{0} complex
                        (@field.to_division_ring.{0} complex
                           (@discrete_field.to_field.{0} complex complex.discrete_field)))
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        x)
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        y)).re))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@coe.{1 1} gaussian_int complex
                     (@coe_to_lift.{1 1} gaussian_int complex
                        (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                     (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).re)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_sub.sub.{0} complex
                 (@add_group_has_sub.{0} complex
                    (@add_comm_group.to_add_group.{0} complex
                       (@ring.to_add_comm_group.{0} complex
                          (@domain.to_ring.{0} complex
                             (@division_ring.to_domain.{0} complex
                                (@field.to_division_ring.{0} complex
                                   (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@has_div.div.{0} complex
                        (@division_ring_has_div&#x27;.{0} complex
                           (@field.to_division_ring.{0} complex
                              (@discrete_field.to_field.{0} complex complex.discrete_field)))
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           x)
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           y)).im))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).im)))
              complex.I)).im))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_div.div.{0} complex
              (@division_ring_has_div&#x27;.{0} complex
                 (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
              (@has_one.one.{0} complex complex.has_one)
              (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_div.div.{0} complex
                 (@division_ring_has_div&#x27;.{0} complex
                    (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                 (@has_one.one.{0} complex complex.has_one)
                 (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
              complex.I)).im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
this :
  @eq.{1} real
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
          (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_one.one.{0} real
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
          (@has_mul.mul.{0} real
             (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))))
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_le.le.{0} real real.has_le
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_sub.sub.{0} complex
              (@add_group_has_sub.{0} complex
                 (@add_comm_group.to_add_group.{0} complex
                    (@ring.to_add_comm_group.{0} complex
                       (@domain.to_ring.{0} complex
                          (@division_ring.to_domain.{0} complex
                             (@field.to_division_ring.{0} complex
                                (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@has_div.div.{0} complex
                     (@division_ring_has_div&#x27;.{0} complex
                        (@field.to_division_ring.{0} complex
                           (@discrete_field.to_field.{0} complex complex.discrete_field)))
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        x)
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        y)).re))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@coe.{1 1} gaussian_int complex
                     (@coe_to_lift.{1 1} gaussian_int complex
                        (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                     (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).re)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_sub.sub.{0} complex
                 (@add_group_has_sub.{0} complex
                    (@add_comm_group.to_add_group.{0} complex
                       (@ring.to_add_comm_group.{0} complex
                          (@domain.to_ring.{0} complex
                             (@division_ring.to_domain.{0} complex
                                (@field.to_division_ring.{0} complex
                                   (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@has_div.div.{0} complex
                        (@division_ring_has_div&#x27;.{0} complex
                           (@field.to_division_ring.{0} complex
                              (@discrete_field.to_field.{0} complex complex.discrete_field)))
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           x)
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           y)).im))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    (@coe.{1 1} int real
                       (@coe_to_lift.{1 1} int real
                          (@coe_base.{1 1} int real
                             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))
                                (@zero_ne_one_class.to_has_one.{0} real
                                   (@domain.to_zero_ne_one_class.{0} real real.domain))
                                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
                       (@round.{0} real real.discrete_linear_ordered_field real.floor_ring
                          ((@has_div.div.{0} complex
                              (@division_ring_has_div&#x27;.{0} complex
                                 (@field.to_division_ring.{0} complex
                                    (@discrete_field.to_field.{0} complex complex.discrete_field)))
                              (@coe.{1 1} gaussian_int complex
                                 (@coe_to_lift.{1 1} gaussian_int complex
                                    (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                                 x)
                              (@coe.{1 1} gaussian_int complex
                                 (@coe_to_lift.{1 1} gaussian_int complex
                                    (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                                 y)).im)))))
              complex.I)).im))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_div.div.{0} complex
              (@division_ring_has_div&#x27;.{0} complex
                 (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
              (@has_one.one.{0} complex complex.has_one)
              (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_div.div.{0} complex
                 (@division_ring_has_div&#x27;.{0} complex
                    (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                 (@has_one.one.{0} complex complex.has_one)
                 (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
              complex.I)).im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
this :
  @eq.{1} real
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
          (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_one.one.{0} real
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
          (@has_mul.mul.{0} real
             (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))))
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_le.le.{0} real real.has_le
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_sub.sub.{0} complex
              (@add_group_has_sub.{0} complex
                 (@add_comm_group.to_add_group.{0} complex
                    (@ring.to_add_comm_group.{0} complex
                       (@domain.to_ring.{0} complex
                          (@division_ring.to_domain.{0} complex
                             (@field.to_division_ring.{0} complex
                                (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@has_div.div.{0} complex
                     (@division_ring_has_div&#x27;.{0} complex
                        (@field.to_division_ring.{0} complex
                           (@discrete_field.to_field.{0} complex complex.discrete_field)))
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        x)
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        y)).re))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@coe.{1 1} gaussian_int complex
                     (@coe_to_lift.{1 1} gaussian_int complex
                        (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                     (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).re)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_sub.sub.{0} complex
                 (@add_group_has_sub.{0} complex
                    (@add_comm_group.to_add_group.{0} complex
                       (@ring.to_add_comm_group.{0} complex
                          (@domain.to_ring.{0} complex
                             (@division_ring.to_domain.{0} complex
                                (@field.to_division_ring.{0} complex
                                   (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@has_div.div.{0} complex
                        (@division_ring_has_div&#x27;.{0} complex
                           (@field.to_division_ring.{0} complex
                              (@discrete_field.to_field.{0} complex complex.discrete_field)))
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           x)
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           y)).im))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).im)))
              complex.I)).im))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_div.div.{0} complex
              (@division_ring_has_div&#x27;.{0} complex
                 (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
              (@has_one.one.{0} complex complex.has_one)
              (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_div.div.{0} complex
                 (@division_ring_has_div&#x27;.{0} complex
                    (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                 (@has_one.one.{0} complex complex.has_one)
                 (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
              complex.I)).im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148        simpa using abs_sub_round (x / y : ℂ).im)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='abs_sub_round'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/archimedean.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] [_inst_2 : @floor_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))] (x : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))))) (@abs.{0} α (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_comm_group.{0} α (@discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring.{0} α _inst_1)) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@domain.to_ring.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))))))) x (@coe.{1 1} int α (@coe_to_lift.{1 1} int α (@coe_base.{1 1} int α (@int.cast_coe.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@domain.to_ring.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))))))) (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))))) (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))))) (@distrib.to_has_add.{0} α (@ring.to_distrib.{0} α (@domain.to_ring.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))))))))) (@round.{0} α _inst_1 _inst_2 x)))) (@has_div.div.{0} α (@division_ring_has_div&#x27;.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))) (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))) (@bit0.{0} α (@distrib.to_has_add.{0} α (@ring.to_distrib.{0} α (@domain.to_ring.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))) (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
this :
  @eq.{1} real
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
          (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_one.one.{0} real
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
          (@has_mul.mul.{0} real
             (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
             (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))))
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_le.le.{0} real real.has_le
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_sub.sub.{0} complex
              (@add_group_has_sub.{0} complex
                 (@add_comm_group.to_add_group.{0} complex
                    (@ring.to_add_comm_group.{0} complex
                       (@domain.to_ring.{0} complex
                          (@division_ring.to_domain.{0} complex
                             (@field.to_division_ring.{0} complex
                                (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@has_div.div.{0} complex
                     (@division_ring_has_div&#x27;.{0} complex
                        (@field.to_division_ring.{0} complex
                           (@discrete_field.to_field.{0} complex complex.discrete_field)))
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        x)
                     (@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        y)).re))
              (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                 ((@coe.{1 1} gaussian_int complex
                     (@coe_to_lift.{1 1} gaussian_int complex
                        (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                     (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).re)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_sub.sub.{0} complex
                 (@add_group_has_sub.{0} complex
                    (@add_comm_group.to_add_group.{0} complex
                       (@ring.to_add_comm_group.{0} complex
                          (@domain.to_ring.{0} complex
                             (@division_ring.to_domain.{0} complex
                                (@field.to_division_ring.{0} complex
                                   (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@has_div.div.{0} complex
                        (@division_ring_has_div&#x27;.{0} complex
                           (@field.to_division_ring.{0} complex
                              (@discrete_field.to_field.{0} complex complex.discrete_field)))
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           x)
                        (@coe.{1 1} gaussian_int complex
                           (@coe_to_lift.{1 1} gaussian_int complex
                              (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                           y)).im))
                 (@coe.{1 1} real complex
                    (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
                    ((@coe.{1 1} gaussian_int complex
                        (@coe_to_lift.{1 1} gaussian_int complex
                           (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                        (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)).im)))
              complex.I)).im))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       ((@has_add.add.{0} complex complex.has_add
           (@has_div.div.{0} complex
              (@division_ring_has_div&#x27;.{0} complex
                 (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
              (@has_one.one.{0} complex complex.has_one)
              (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
           (@has_mul.mul.{0} complex complex.has_mul
              (@has_div.div.{0} complex
                 (@division_ring_has_div&#x27;.{0} complex
                    (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                 (@has_one.one.{0} complex complex.has_one)
                 (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
              complex.I)).im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    ... &lt; 1 : by simp [norm_sq]; norm_num</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='complex.norm_sq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='x y : gaussian_int
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (complex.norm_sq
       (@has_add.add.{0} complex complex.has_add
          (@has_div.div.{0} complex
             (@division_ring_has_div&#x27;.{0} complex
                (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
             (@has_one.one.{0} complex complex.has_one)
             (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
          (@has_mul.mul.{0} complex complex.has_mul
             (@has_div.div.{0} complex
                (@division_ring_has_div&#x27;.{0} complex
                   (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                (@has_one.one.{0} complex complex.has_one)
                (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
             complex.I)))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (complex.norm_sq
       (@has_add.add.{0} complex complex.has_add
          (@has_div.div.{0} complex
             (@division_ring_has_div&#x27;.{0} complex
                (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
             (@has_one.one.{0} complex complex.has_one)
             (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
          (@has_mul.mul.{0} complex complex.has_mul
             (@has_div.div.{0} complex
                (@division_ring_has_div&#x27;.{0} complex
                   (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                (@has_one.one.{0} complex complex.has_one)
                (@bit0.{0} complex complex.has_add (@has_one.one.{0} complex complex.has_one)))
             complex.I)))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  protected def mod (x y : ℤ[i]) : ℤ[i] := x - y * (x / y)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  instance : has_mod ℤ[i] := ⟨gaussian_int.mod⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 151, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='gaussian_int → gaussian_int → gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  lemma mod_def (x y : ℤ[i]) : x % y = x - y * (x / y) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  lemma norm_mod_lt (x : ℤ[i]) {y : ℤ[i]} (hy : y ≠ 0) : (x % y).norm &lt; y.norm :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  have (y : ℂ) ≠ 0, by rwa [ne.def, ← to_complex_zero, to_complex_inj],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ne.def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='gaussian_int.to_complex_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gaussian_int.to_complex_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (a b : α), @eq.{1} Prop (@ne.{1} α a b) (not (@eq.{1} α a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} complex (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))) (@has_zero.zero.{0} complex complex.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : gaussian_int}, iff (@eq.{1} complex (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) x) (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) y)) (@eq.{1} gaussian_int x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ not
    (@eq.{1} complex
       (@coe.{1 1} gaussian_int complex
          (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
          y)
       (@has_zero.zero.{0} complex complex.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ not
    (@eq.{1} complex
       (@coe.{1 1} gaussian_int complex
          (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
          y)
       (@coe.{1 1} gaussian_int complex
          (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
          (@has_zero.zero.{0} gaussian_int
             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ not
    (@eq.{1} gaussian_int y
       (@has_zero.zero.{0} gaussian_int
          (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  (@int.cast_lt ℝ _ _ _).1 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.cast_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1167, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_ring.{0} α] {m n : int}, iff (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α _inst_1))))))) (@coe.{1 1} int α (@coe_to_lift.{1 1} int α (@coe_base.{1 1} int α (@int.cast_coe.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@domain.to_ring.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))))) (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))) (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))) (@distrib.to_has_add.{0} α (@ring.to_distrib.{0} α (@domain.to_ring.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))))))) m) (@coe.{1 1} int α (@coe_to_lift.{1 1} int α (@coe_base.{1 1} int α (@int.cast_coe.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@domain.to_ring.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))))) (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))) (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))) (@distrib.to_has_add.{0} α (@ring.to_distrib.{0} α (@domain.to_ring.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))))))) n)) (@has_lt.lt.{0} int int.has_lt m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    calc ↑(norm (x % y)) = (x - y * (x / y : ℤ[i]) : ℂ).norm_sq : by simp [mod_def]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.norm_sq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='gaussian_int.mod_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x y : gaussian_int), @eq.{1} gaussian_int (@has_mod.mod.{0} gaussian_int gaussian_int.has_mod x y) (@has_sub.sub.{0} gaussian_int (@add_group_has_sub.{0} gaussian_int (@add_comm_group.to_add_group.{0} gaussian_int (@ring.to_add_comm_group.{0} gaussian_int (@zsqrtd.ring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) x (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) y (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mod.mod.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             gaussian_int.has_mod
             x
             y)))
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             x)
          (@has_mul.mul.{0} complex complex.has_mul
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161    ... = (y : ℂ).norm_sq * (((x / y) - (x / y : ℤ[i])) : ℂ).norm_sq :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.norm_sq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.norm_sq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mod.mod.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             gaussian_int.has_mod
             x
             y)))
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             x)
          (@has_mul.mul.{0} complex complex.has_mul
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162      by rw [← norm_sq_mul, mul_sub, mul_div_cancel&#x27; _ this]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='complex.norm_sq_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_div_cancel&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 208, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (z w : complex), @eq.{1} real (complex.norm_sq (@has_mul.mul.{0} complex complex.has_mul z w)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (complex.norm_sq z) (complex.norm_sq w))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [s : ring.{0} α] (a b c : α), @eq.{1} α (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α s))) a (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α s))) b c)) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α s))) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α s))) a b) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α s))) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : field.{0} α] (a : α) {b : α}, @ne.{1} α b (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α (@field.to_division_ring.{0} α _inst_1)))) → @eq.{1} α (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α (@division_ring.to_ring.{0} α (@field.to_division_ring.{0} α _inst_1))))) b (@has_div.div.{0} α (@division_ring_has_div.{0} α (@field.to_division_ring.{0} α _inst_1) (@field.to_division_ring.{0} α _inst_1)) a b)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} complex (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) y) (@has_zero.zero.{0} complex complex.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             x)
          (@has_mul.mul.{0} complex complex.has_mul
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (complex.norm_sq
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             y))
       (complex.norm_sq
          (@has_sub.sub.{0} complex
             (@add_group_has_sub.{0} complex
                (@add_comm_group.to_add_group.{0} complex
                   (@ring.to_add_comm_group.{0} complex
                      (@domain.to_ring.{0} complex
                         (@division_ring.to_domain.{0} complex
                            (@field.to_division_ring.{0} complex
                               (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
             (@has_div.div.{0} complex
                (@division_ring_has_div&#x27;.{0} complex
                   (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   x)
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   y))
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             x)
          (@has_mul.mul.{0} complex complex.has_mul
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))
    (complex.norm_sq
       (@has_mul.mul.{0} complex complex.has_mul
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             y)
          (@has_sub.sub.{0} complex
             (@add_group_has_sub.{0} complex
                (@add_comm_group.to_add_group.{0} complex
                   (@ring.to_add_comm_group.{0} complex
                      (@domain.to_ring.{0} complex
                         (@division_ring.to_domain.{0} complex
                            (@field.to_division_ring.{0} complex
                               (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
             (@has_div.div.{0} complex
                (@division_ring_has_div&#x27;.{0} complex
                   (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   x)
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   y))
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             x)
          (@has_mul.mul.{0} complex complex.has_mul
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@has_mul.mul.{0} complex
             (@mul_zero_class.to_has_mul.{0} complex
                (@semiring.to_mul_zero_class.{0} complex
                   (@ring.to_semiring.{0} complex
                      (@domain.to_ring.{0} complex
                         (@division_ring.to_domain.{0} complex
                            (@field.to_division_ring.{0} complex
                               (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@has_div.div.{0} complex
                (@division_ring_has_div&#x27;.{0} complex
                   (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   x)
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   y)))
          (@has_mul.mul.{0} complex
             (@mul_zero_class.to_has_mul.{0} complex
                (@semiring.to_mul_zero_class.{0} complex
                   (@ring.to_semiring.{0} complex
                      (@domain.to_ring.{0} complex
                         (@division_ring.to_domain.{0} complex
                            (@field.to_division_ring.{0} complex
                               (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             x)
          (@has_mul.mul.{0} complex complex.has_mul
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (complex.norm_sq
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             y))
       (complex.norm_sq
          (@has_sub.sub.{0} complex
             (@add_group_has_sub.{0} complex
                (@add_comm_group.to_add_group.{0} complex
                   (@ring.to_add_comm_group.{0} complex
                      (@domain.to_ring.{0} complex
                         (@division_ring.to_domain.{0} complex
                            (@field.to_division_ring.{0} complex
                               (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
             (@has_div.div.{0} complex
                (@division_ring_has_div&#x27;.{0} complex
                   (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   x)
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   y))
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163    ... &lt; (y : ℂ).norm_sq * 1 : mul_lt_mul_of_pos_left (norm_sq_div_sub_div_lt_one _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.norm_sq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mul_lt_mul_of_pos_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gaussian_int.norm_sq_div_sub_div_lt_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_semiring.{0} α] {a b c : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1)))) c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))) c a) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x y : gaussian_int), @has_lt.lt.{0} real real.has_lt (complex.norm_sq (@has_sub.sub.{0} complex (@add_group_has_sub.{0} complex (@add_comm_group.to_add_group.{0} complex (@ring.to_add_comm_group.{0} complex (@domain.to_ring.{0} complex (@division_ring.to_domain.{0} complex (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field))))))) (@has_div.div.{0} complex (@division_ring_has_div&#x27;.{0} complex (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field))) (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) x) (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) y)) (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (complex.norm_sq
       (@has_sub.sub.{0} complex
          (@add_group_has_sub.{0} complex
             (@add_comm_group.to_add_group.{0} complex
                (@ring.to_add_comm_group.{0} complex
                   (@domain.to_ring.{0} complex
                      (@division_ring.to_domain.{0} complex
                         (@field.to_division_ring.{0} complex
                            (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             x)
          (@has_mul.mul.{0} complex complex.has_mul
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                y)
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (complex.norm_sq
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             y))
       (complex.norm_sq
          (@has_sub.sub.{0} complex
             (@add_group_has_sub.{0} complex
                (@add_comm_group.to_add_group.{0} complex
                   (@ring.to_add_comm_group.{0} complex
                      (@domain.to_ring.{0} complex
                         (@division_ring.to_domain.{0} complex
                            (@field.to_division_ring.{0} complex
                               (@discrete_field.to_field.{0} complex complex.discrete_field)))))))
             (@has_div.div.{0} complex
                (@division_ring_has_div&#x27;.{0} complex
                   (@field.to_division_ring.{0} complex (@discrete_field.to_field.{0} complex complex.discrete_field)))
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   x)
                (@coe.{1 1} gaussian_int complex
                   (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                   y))
             (@coe.{1 1} gaussian_int complex
                (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
                (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164      (norm_sq_pos.2 this)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='complex.norm_sq_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {z : complex}, iff (@has_lt.lt.{0} real real.has_lt (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (complex.norm_sq z)) (@ne.{1} complex z (@has_zero.zero.{0} complex complex.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ne.{1} complex (@coe.{1 1} gaussian_int complex (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe)) y) (@has_zero.zero.{0} complex complex.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165    ... = norm y : by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (complex.norm_sq
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             y))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
this :
  @ne.{1} complex
    (@coe.{1 1} gaussian_int complex
       (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
       y)
    (@has_zero.zero.{0} complex complex.has_zero)
⊢ @eq.{1} real
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (complex.norm_sq
          (@coe.{1 1} gaussian_int complex
             (@coe_to_lift.{1 1} gaussian_int complex (@coe_base.{1 1} gaussian_int complex gaussian_int.has_coe))
             y))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  lemma nat_abs_norm_mod_lt (x : ℤ[i]) {y : ℤ[i]} (hy : y ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    (x % y).norm.nat_abs &lt; y.norm.nat_abs :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  int.coe_nat_lt.1 (by simp [-int.coe_nat_lt, norm_mod_lt x hy])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='int.coe_nat_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='gaussian_int.norm_mod_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 157, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, iff (@has_lt.lt.{0} int int.has_lt (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) m) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)) (@has_lt.lt.{0} nat nat.has_lt m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : gaussian_int) {y : gaussian_int}, @ne.{1} gaussian_int y (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) → @has_lt.lt.{0} int int.has_lt (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_mod.mod.{0} gaussian_int gaussian_int.has_mod x y)) (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} gaussian_int y (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_lt.lt.{0} int int.has_lt
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@has_mod.mod.{0} gaussian_int gaussian_int.has_mod x y))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  lemma norm_le_norm_mul_left (x : ℤ[i]) {y : ℤ[i]} (hy : y ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    (norm x).nat_abs ≤ (norm (x * y)).nat_abs :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  by rw [norm_mul, int.nat_abs_mul];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='zsqrtd.norm_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {d : int} (n m : zsqrtd d), @eq.{1} int (@zsqrtd.norm d (@has_mul.mul.{0} (zsqrtd d) (@zsqrtd.has_mul d) n m)) (@has_mul.mul.{0} int int.has_mul (@zsqrtd.norm d n) (@zsqrtd.norm d m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : int), @eq.{1} nat (int.nat_abs (@has_mul.mul.{0} int int.has_mul a b)) (@has_mul.mul.{0} nat nat.has_mul (int.nat_abs a) (int.nat_abs b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (int.nat_abs
       (@has_mul.mul.{0} int int.has_mul
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (@has_mul.mul.{0} nat nat.has_mul
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    exact le_mul_of_one_le_right&#x27; (nat.zero_le _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_mul_of_one_le_right&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) b (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (n : nat), @has_le.le.{0} nat nat.has_le (@has_zero.zero.{0} nat nat.has_zero) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      (int.coe_nat_le.1 (by rw [coe_nat_abs_norm]; exact norm_pos.2 hy))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='int.coe_nat_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='gaussian_int.coe_nat_abs_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='gaussian_int.norm_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {m n : nat}, iff (@has_le.le.{0} int int.has_le (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) m) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)) (@has_le.le.{0} nat nat.has_le m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : gaussian_int), @eq.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))) (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : gaussian_int}, iff (@has_lt.lt.{0} int int.has_lt (@has_zero.zero.{0} int int.has_zero) (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)) (@ne.{1} gaussian_int x (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} gaussian_int y (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} int int.has_le
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_one.one.{0} nat
          (@monoid.to_has_one.{0} nat
             (@semiring.to_monoid.{0} nat
                (@ordered_semiring.to_semiring.{0} nat
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nat
                      (@decidable_linear_ordered_semiring.to_linear_ordered_semiring.{0} nat
                         nat.decidable_linear_ordered_semiring)))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} int int.has_le
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_one.one.{0} nat
          (@monoid.to_has_one.{0} nat
             (@semiring.to_monoid.{0} nat
                (@ordered_semiring.to_semiring.{0} nat
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nat
                      (@decidable_linear_ordered_semiring.to_linear_ordered_semiring.{0} nat
                         nat.decidable_linear_ordered_semiring)))))))
    (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} int int.has_le
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_one.one.{0} nat
          (@monoid.to_has_one.{0} nat
             (@semiring.to_monoid.{0} nat
                (@ordered_semiring.to_semiring.{0} nat
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nat
                      (@decidable_linear_ordered_semiring.to_linear_ordered_semiring.{0} nat
                         nat.decidable_linear_ordered_semiring)))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x y : gaussian_int,
hy :
  @ne.{1} gaussian_int y
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @has_le.le.{0} nat nat.has_le
    (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  instance : nonzero_comm_ring ℤ[i] :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nonzero_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 449, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Predicate for commutative rings in which zero does not equal one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  { zero_ne_one := dec_trivial, ..gaussian_int.comm_ring }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='of_as_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='gaussian_int.comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 986, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {c : Prop} [h₁ : decidable c], @as_true c h₁ → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='comm_ring.{0} gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  instance : euclidean_domain ℤ[i] :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='euclidean_domain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  { quotient := (/),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    remainder := (%),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183    quotient_zero := λ _, by simp [div_def]; refl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='gaussian_int.div_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x y : gaussian_int), @eq.{1} gaussian_int (@has_div.div.{0} gaussian_int gaussian_int.has_div x y) (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@round.{0} rat rat.discrete_linear_ordered_field rat.floor_ring (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) (@coe.{1 1} int rat (@coe_to_lift.{1 1} int rat (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add))) (@zsqrtd.re (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) x (@zsqrtd.conj (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))) (@coe.{1 1} int rat (@coe_to_lift.{1 1} int rat (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add))) (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))) (@round.{0} rat rat.discrete_linear_ordered_field rat.floor_ring (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) (@coe.{1 1} int rat (@coe_to_lift.{1 1} int rat (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add))) (@zsqrtd.im (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) x (@zsqrtd.conj (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))) (@coe.{1 1} int rat (@coe_to_lift.{1 1} int rat (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add))) (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='lime'><a title='_x : gaussian_int
⊢ @eq.{1} gaussian_int
    (@has_div.div.{0} gaussian_int gaussian_int.has_div _x
       (@has_zero.zero.{0} gaussian_int
          (@zero_ne_one_class.to_has_zero.{0} gaussian_int
             (@nonzero_comm_ring.to_zero_ne_one_class.{0} gaussian_int gaussian_int.nonzero_comm_ring))))
    (@has_zero.zero.{0} gaussian_int
       (@zero_ne_one_class.to_has_zero.{0} gaussian_int
          (@nonzero_comm_ring.to_zero_ne_one_class.{0} gaussian_int gaussian_int.nonzero_comm_ring)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    quotient_mul_add_remainder_eq := λ _ _, by simp [mod_def],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='gaussian_int.mod_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x y : gaussian_int), @eq.{1} gaussian_int (@has_mod.mod.{0} gaussian_int gaussian_int.has_mod x y) (@has_sub.sub.{0} gaussian_int (@add_group_has_sub.{0} gaussian_int (@add_comm_group.to_add_group.{0} gaussian_int (@ring.to_add_comm_group.{0} gaussian_int (@zsqrtd.ring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) x (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) y (@has_div.div.{0} gaussian_int gaussian_int.has_div x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='lime'><a title='_x _x : gaussian_int
⊢ @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@distrib.to_has_add.{0} gaussian_int
          (@ring.to_distrib.{0} gaussian_int
             (@comm_ring.to_ring.{0} gaussian_int
                (@nonzero_comm_ring.to_comm_ring.{0} gaussian_int gaussian_int.nonzero_comm_ring))))
       (@has_mul.mul.{0} gaussian_int
          (@mul_zero_class.to_has_mul.{0} gaussian_int
             (@semiring.to_mul_zero_class.{0} gaussian_int
                (@ring.to_semiring.{0} gaussian_int
                   (@comm_ring.to_ring.{0} gaussian_int
                      (@nonzero_comm_ring.to_comm_ring.{0} gaussian_int gaussian_int.nonzero_comm_ring)))))
          _x
          (@has_div.div.{0} gaussian_int gaussian_int.has_div _x _x))
       (@has_mod.mod.{0} gaussian_int gaussian_int.has_mod _x _x))
    _x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    r := _,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186    r_well_founded := measure_wf (int.nat_abs ∘ norm),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='measure_wf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/wf.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='∀ {α : Sort u} (f : α → nat), @well_founded.{u} α (@measure.{u} α f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    remainder_lt := nat_abs_norm_mod_lt,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='gaussian_int.nat_abs_norm_mod_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='∀ (x : gaussian_int) {y : gaussian_int}, @ne.{1} gaussian_int y (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) → @has_lt.lt.{0} nat nat.has_lt (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_mod.mod.{0} gaussian_int gaussian_int.has_mod x y))) (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    mul_left_not_lt := λ a b hb0, not_lt_of_ge $ norm_le_norm_mul_left a hb0 }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_lt_of_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int.norm_le_norm_mul_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} gaussian_int b (@has_zero.zero.{0} gaussian_int (@zero_ne_one_class.to_has_zero.{0} gaussian_int (@nonzero_comm_ring.to_zero_ne_one_class.{0} gaussian_int gaussian_int.nonzero_comm_ring)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b : α}, @ge.{u} α (@preorder.to_has_le.{u} α _inst_1) a b → not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : gaussian_int) {y : gaussian_int}, @ne.{1} gaussian_int y (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) → @has_le.le.{0} nat nat.has_le (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)) (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} gaussian_int b (@has_zero.zero.{0} gaussian_int (@zero_ne_one_class.to_has_zero.{0} gaussian_int (@nonzero_comm_ring.to_zero_ne_one_class.{0} gaussian_int gaussian_int.nonzero_comm_ring)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  open principal_ideal_domain</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  lemma mod_four_eq_three_of_nat_prime_of_prime {p : ℕ} (hp : p.prime) (hpi : prime (p : ℤ[i])) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@eq.{1} nat (@has_mul.mul.{0} nat nat.has_mul (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='prime element of a semiring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    p % 4 = 3 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  hp.eq_two_or_odd.elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.eq_two_or_odd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 280, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → or (@eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    (λ hp2, absurd hpi (mt irreducible_iff_prime.2 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hp2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='absurd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hpi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='principal_ideal_domain.irreducible_iff_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/principal_ideal_domain.lean&#x27;, &#x27;line&#x27;: 135, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, a → not a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : principal_ideal_domain.{0} α] {p : α}, iff (@irreducible.{0} α (@ring.to_monoid.{0} α (@domain.to_ring.{0} α (@integral_domain.to_domain.{0} α (@principal_ideal_domain.to_integral_domain.{0} α _inst_1)))) p) (@prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α (@principal_ideal_domain.to_integral_domain.{0} α _inst_1)))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196      λ ⟨hu, h⟩, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@irreducible.{0} gaussian_int (@ring.to_monoid.{0} gaussian_int (@domain.to_ring.{0} gaussian_int (@integral_domain.to_domain.{0} gaussian_int (@principal_ideal_domain.to_integral_domain.{0} gaussian_int (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain))))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197        have := h ⟨1, 1⟩ ⟨1, -1⟩ (hp2.symm ▸ rfl),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hp2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : gaussian_int), @eq.{1} gaussian_int (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) (@has_mul.mul.{0} gaussian_int (@semigroup.to_has_mul.{0} gaussian_int (@monoid.to_semigroup.{0} gaussian_int (@ring.to_monoid.{0} gaussian_int (@domain.to_ring.{0} gaussian_int (@integral_domain.to_domain.{0} gaussian_int (@principal_ideal_domain.to_integral_domain.{0} gaussian_int (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain))))))) a b) → or (@is_unit.{0} gaussian_int (@ring.to_monoid.{0} gaussian_int (@domain.to_ring.{0} gaussian_int (@integral_domain.to_domain.{0} gaussian_int (@principal_ideal_domain.to_integral_domain.{0} gaussian_int (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain))))) a) (@is_unit.{0} gaussian_int (@ring.to_monoid.{0} gaussian_int (@domain.to_ring.{0} gaussian_int (@integral_domain.to_domain.{0} gaussian_int (@principal_ideal_domain.to_integral_domain.{0} gaussian_int (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain))))) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_one.one.{0} int int.has_one)
          (@has_one.one.{0} int int.has_one)))
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_one.one.{0} int int.has_one)
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198        rw [← norm_eq_one_iff, ← norm_eq_one_iff] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='zsqrtd.norm_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='zsqrtd.norm_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {d : int} {x : zsqrtd d}, iff (@eq.{1} nat (int.nat_abs (@zsqrtd.norm d x)) (@has_one.one.{0} nat nat.has_one)) (@is_unit.{0} (zsqrtd d) (@zsqrtd.monoid d) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {d : int} {x : zsqrtd d}, iff (@eq.{1} nat (int.nat_abs (@zsqrtd.norm d x)) (@has_one.one.{0} nat nat.has_one)) (@is_unit.{0} (zsqrtd d) (@zsqrtd.monoid d) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_one.one.{0} int int.has_one)
          (@has_one.one.{0} int int.has_one)))
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_one.one.{0} int int.has_one)
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_one.one.{0} int int.has_one))))
       (@has_one.one.{0} nat nat.has_one))
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_one.one.{0} int int.has_one)
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_one.one.{0} int int.has_one))))
       (@has_one.one.{0} nat nat.has_one))
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
       (@has_one.one.{0} nat nat.has_one))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_one.one.{0} int int.has_one)
          (@has_one.one.{0} int int.has_one)))
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_one.one.{0} int int.has_one)
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_one.one.{0} int int.has_one))))
       (@has_one.one.{0} nat nat.has_one))
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
       (@has_one.one.{0} nat nat.has_one))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199        exact absurd this dec_trivial</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='absurd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → not a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@eq.{1} nat (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_one.one.{0} int int.has_one) (@has_one.one.{0} int int.has_one)))) (@has_one.one.{0} nat nat.has_one)) (@eq.{1} nat (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_one.one.{0} int int.has_one) (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_one.one.{0} int int.has_one))))
       (@has_one.one.{0} nat nat.has_one))
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
       (@has_one.one.{0} nat nat.has_one))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200      end))</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp2 : @eq.{1} nat p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)),
_x :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
_fun_match :
  @irreducible.{0} gaussian_int
    (@ring.to_monoid.{0} gaussian_int
       (@domain.to_ring.{0} gaussian_int
          (@integral_domain.to_domain.{0} gaussian_int
             (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p) →
  false,
hu :
  not
    (@is_unit.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
h :
  ∀ (a b : gaussian_int),
    @eq.{1} gaussian_int
      (@coe.{1 1} nat gaussian_int
         (@coe_to_lift.{1 1} nat gaussian_int
            (@coe_base.{1 1} nat gaussian_int
               (@nat.cast_coe.{0} gaussian_int
                  (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                  (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
         p)
      (@has_mul.mul.{0} gaussian_int
         (@semigroup.to_has_mul.{0} gaussian_int
            (@monoid.to_semigroup.{0} gaussian_int
               (@ring.to_monoid.{0} gaussian_int
                  (@domain.to_ring.{0} gaussian_int
                     (@integral_domain.to_domain.{0} gaussian_int
                        (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                           (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int
                              gaussian_int.euclidean_domain)))))))
         a
         b) →
    or
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         a)
      (@is_unit.{0} gaussian_int
         (@ring.to_monoid.{0} gaussian_int
            (@domain.to_ring.{0} gaussian_int
               (@integral_domain.to_domain.{0} gaussian_int
                  (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                     (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
         b),
this :
  or
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_one.one.{0} int int.has_one))))
       (@has_one.one.{0} nat nat.has_one))
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
                (@has_one.one.{0} int int.has_one)
                (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
       (@has_one.one.{0} nat nat.has_one))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    (λ hp1, by_contradiction $ λ hp3 : p % 4 ≠ 3,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hp1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {p : Prop} [_inst_1 : decidable p], (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202      have hp41 : p % 4 = 1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203        begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204          rw [← nat.mod_mul_left_mod p 2 2, show 2 * 2 = 4, from rfl] at hp1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='nat.mod_mul_left_mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/modeq.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b c : nat), @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod (@has_mod.mod.{0} nat nat.has_mod a (@has_mul.mul.{0} nat nat.has_mul b c)) c) (@has_mod.mod.{0} nat nat.has_mod a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp1 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@has_mul.mul.{0} nat nat.has_mul (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))
             (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one)
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp1 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one)
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp1 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one)
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205          have := nat.mod_lt p (show 0 &lt; 4, from dec_trivial),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='nat.mod_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 693, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : nat) {y : nat}, @gt.{0} nat nat.has_lt y (@has_zero.zero.{0} nat nat.has_zero) → @has_lt.lt.{0} nat nat.has_lt (@has_mod.mod.{0} nat nat.has_mod x y) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp1 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one)
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp1 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
this :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206          revert this hp3 hp1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`revert h₁ ... hₙ` applies to any goal with hypotheses `h₁` ... `hₙ`. It moves the hypotheses and their dependencies to the target of the goal. This tactic is the inverse of `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='revert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp1 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
this :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
⊢ @has_lt.lt.{0} nat nat.has_lt
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) →
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)) →
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one) →
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207          generalize hm : p % 4 = m, clear hm, revert m,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 461, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 461, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 461, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 461, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse unit (λ (a : unit), punit.reflect a) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) → @interactive.parse (prod.{0 0} pexpr name) (λ (a : prod.{0 0} pexpr name), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) name (λ (a : name), name.reflect a) `(pexpr) `(name) a) generalize_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse unit (λ (a : unit), punit.reflect a) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) → @interactive.parse (prod.{0 0} pexpr name) (λ (a : prod.{0 0} pexpr name), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) name (λ (a : name), name.reflect a) `(pexpr) `(name) a) generalize_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse unit (λ (a : unit), punit.reflect a) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) → @interactive.parse (prod.{0 0} pexpr name) (λ (a : prod.{0 0} pexpr name), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) name (λ (a : name), name.reflect a) `(pexpr) `(name) a) generalize_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse unit (λ (a : unit), punit.reflect a) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) → @interactive.parse (prod.{0 0} pexpr name) (λ (a : prod.{0 0} pexpr name), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) name (λ (a : name), name.reflect a) `(pexpr) `(name) a) generalize_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`generalize : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of the same type.

`generalize h : e = x` in addition registers the hypothesis `h : e = x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`generalize : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of the same type.

`generalize h : e = x` in addition registers the hypothesis `h : e = x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`generalize : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of the same type.

`generalize h : e = x` in addition registers the hypothesis `h : e = x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`generalize : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of the same type.

`generalize h : e = x` in addition registers the hypothesis `h : e = x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`revert h₁ ... hₙ` applies to any goal with hypotheses `h₁` ... `hₙ`. It moves the hypotheses and their dependencies to the target of the goal. This tactic is the inverse of `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='generalize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='generalize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='generalize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='generalize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='revert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;:&#x27;, &#x27;expr = id&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;:&#x27;, &#x27;expr = id&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;:&#x27;, &#x27;expr = id&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;:&#x27;, &#x27;expr = id&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
⊢ @has_lt.lt.{0} nat nat.has_lt
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) →
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)) →
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod
       (@has_mod.mod.{0} nat nat.has_mod p
          (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one) →
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
m : nat,
hm :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    m
⊢ @has_lt.lt.{0} nat nat.has_lt m
    (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) →
  @ne.{1} nat m (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)) →
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod m (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one) →
  @eq.{1} nat m (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
m : nat
⊢ @has_lt.lt.{0} nat nat.has_lt m
    (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) →
  @ne.{1} nat m (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)) →
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod m (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one) →
  @eq.{1} nat m (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
⊢ ∀ (m : nat),
    @has_lt.lt.{0} nat nat.has_lt m
      (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) →
    @ne.{1} nat m (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)) →
    @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod m (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
      (@has_one.one.{0} nat nat.has_one) →
    @eq.{1} nat m (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208          exact dec_trivial,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
⊢ ∀ (m : nat),
    @has_lt.lt.{0} nat nat.has_lt m
      (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) →
    @ne.{1} nat m (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)) →
    @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod m (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
      (@has_one.one.{0} nat nat.has_one) →
    @eq.{1} nat m (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209        end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210      let ⟨k, hk⟩ := (zmodp.exists_pow_two_eq_neg_one_iff_mod_four_ne_three hp).2 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='zmodp.exists_pow_two_eq_neg_one_iff_mod_four_ne_three'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zmod/quadratic_reciprocity.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@Exists.{1} (zmodp p hp) (λ (y : zmodp p hp), @eq.{1} (zmodp p hp) (@has_pow.pow.{0 0} (zmodp p hp) nat (@monoid.has_pow.{0} (zmodp p hp) (@ring.to_monoid.{0} (zmodp p hp) (@domain.to_ring.{0} (zmodp p hp) (@division_ring.to_domain.{0} (zmodp p hp) (@field.to_division_ring.{0} (zmodp p hp) (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))) y (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_neg.neg.{0} (zmodp p hp) (@add_group.to_has_neg.{0} (zmodp p hp) (@add_comm_group.to_add_group.{0} (zmodp p hp) (@ring.to_add_comm_group.{0} (zmodp p hp) (@domain.to_ring.{0} (zmodp p hp) (@division_ring.to_domain.{0} (zmodp p hp) (@field.to_division_ring.{0} (zmodp p hp) (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))) (@has_one.one.{0} (zmodp p hp) (@zero_ne_one_class.to_has_one.{0} (zmodp p hp) (@domain.to_zero_ne_one_class.{0} (zmodp p hp) (@division_ring.to_domain.{0} (zmodp p hp) (@field.to_division_ring.{0} (zmodp p hp) (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='zmodp p hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {p : nat} (hp : nat.prime p), iff (@Exists.{1} (zmodp p hp) (λ (y : zmodp p hp), @eq.{1} (zmodp p hp) (@has_pow.pow.{0 0} (zmodp p hp) nat (@monoid.has_pow.{0} (zmodp p hp) (@ring.to_monoid.{0} (zmodp p hp) (@domain.to_ring.{0} (zmodp p hp) (@division_ring.to_domain.{0} (zmodp p hp) (@field.to_division_ring.{0} (zmodp p hp) (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))) y (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_neg.neg.{0} (zmodp p hp) (@add_group.to_has_neg.{0} (zmodp p hp) (@add_comm_group.to_add_group.{0} (zmodp p hp) (@ring.to_add_comm_group.{0} (zmodp p hp) (@domain.to_ring.{0} (zmodp p hp) (@division_ring.to_domain.{0} (zmodp p hp) (@field.to_division_ring.{0} (zmodp p hp) (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))) (@has_one.one.{0} (zmodp p hp) (@zero_ne_one_class.to_has_one.{0} (zmodp p hp) (@domain.to_zero_ne_one_class.{0} (zmodp p hp) (@division_ring.to_domain.{0} (zmodp p hp) (@field.to_division_ring.{0} (zmodp p hp) (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))))) (@ne.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211        by rw hp41; exact dec_trivial in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hp41'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one)
⊢ @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212      have hpk : p ∣ k.val ^ 2 + 1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213        by rw [← zmodp.eq_zero_iff_dvd_nat hp]; simp *,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='zmodp.eq_zero_iff_dvd_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zmod/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat} (hp : nat.prime p) (a : nat), iff (@eq.{1} (zmodp p hp) (@coe.{1 1} nat (zmodp p hp) (@coe_to_lift.{1 1} nat (zmodp p hp) (@coe_base.{1 1} nat (zmodp p hp) (@nat.cast_coe.{0} (zmodp p hp) (@mul_zero_class.to_has_zero.{0} (zmodp p hp) (@semiring.to_mul_zero_class.{0} (zmodp p hp) (@ring.to_semiring.{0} (zmodp p hp) (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp))))) (@monoid.to_has_one.{0} (zmodp p hp) (@ring.to_monoid.{0} (zmodp p hp) (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp)))) (@distrib.to_has_add.{0} (zmodp p hp) (@ring.to_distrib.{0} (zmodp p hp) (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp))))))) a) (@has_zero.zero.{0} (zmodp p hp) (@mul_zero_class.to_has_zero.{0} (zmodp p hp) (@semiring.to_mul_zero_class.{0} (zmodp p hp) (@ring.to_semiring.{0} (zmodp p hp) (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp))))))) (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
⊢ @eq.{1} (zmodp p hp)
    (@coe.{1 1} nat (zmodp p hp)
       (@coe_to_lift.{1 1} nat (zmodp p hp)
          (@coe_base.{1 1} nat (zmodp p hp)
             (@nat.cast_coe.{0} (zmodp p hp)
                (@mul_zero_class.to_has_zero.{0} (zmodp p hp)
                   (@semiring.to_mul_zero_class.{0} (zmodp p hp)
                      (@ring.to_semiring.{0} (zmodp p hp)
                         (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp)))))
                (@monoid.to_has_one.{0} (zmodp p hp)
                   (@ring.to_monoid.{0} (zmodp p hp) (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp))))
                (@distrib.to_has_add.{0} (zmodp p hp)
                   (@ring.to_distrib.{0} (zmodp p hp) (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp)))))))
       (@has_add.add.{0} nat nat.has_add
          (@has_pow.pow.{0 0} nat nat nat.has_pow
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k)
             (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@has_one.one.{0} nat nat.has_one)))
    (@has_zero.zero.{0} (zmodp p hp)
       (@mul_zero_class.to_has_zero.{0} (zmodp p hp)
          (@semiring.to_mul_zero_class.{0} (zmodp p hp)
             (@ring.to_semiring.{0} (zmodp p hp) (@comm_ring.to_ring.{0} (zmodp p hp) (@zmodp.comm_ring p hp))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214      have hkmul : (k.val ^ 2 + 1 : ℤ[i]) = ⟨k.val, 1⟩ * ⟨k.val, -1⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215        by simp [_root_.pow_two, zsqrtd.ext],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pow_two'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zsqrtd.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α] (a : α), @eq.{?l_1+1} α (@has_pow.pow.{?l_1 0} α nat (@monoid.has_pow.{?l_1} α _inst_1) a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {d : int} {z w : zsqrtd d}, iff (@eq.{1} (zsqrtd d) z w) (and (@eq.{1} int (@zsqrtd.re d z) (@zsqrtd.re d w)) (@eq.{1} int (@zsqrtd.im d z) (@zsqrtd.im d w)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216      have hpne1 : p ≠ 1, from (ne_of_lt (hp.one_lt)).symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ne_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.one_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @ne.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → @has_lt.lt.{0} nat nat.has_lt (@has_one.one.{0} nat nat.has_one) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {a b : α}, @ne.{1} α a b → @ne.{1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217      have hkltp : 1 + k.val * k.val &lt; p * p,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218        from calc 1 + k.val * k.val ≤ k.val + k.val * k.val :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219          add_le_add_right (nat.pos_of_ne_zero</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='add_le_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.pos_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_cancel_comm_monoid.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α _inst_1))) a b → ∀ (c : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) a c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat}, @ne.{1} nat n (@has_zero.zero.{0} nat nat.has_zero) → @gt.{0} nat nat.has_lt n (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220            (λ hk0, by clear_aux_decl; simp [*, nat.pow_succ] at *)) _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hk0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='nat.pow_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 638, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 207, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@eq.{1} nat (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (b n : nat), @eq.{1} nat (@has_pow.pow.{0 0} nat nat nat.has_pow b (nat.succ n)) (@has_mul.mul.{0} nat nat.has_mul (@has_pow.pow.{0 0} nat nat nat.has_pow b n) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`clear_aux_decl` clears every `aux_decl` in the local context for the current goal.
This includes the induction hypothesis when using the equation compiler and
`_let_match` and `_fun_match`.

It is useful when using a tactic such as `finish`, `simp *` or `subst` that may use these
auxiliary declarations, and produce an error saying the recursion is not well founded.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='clear_aux_decl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hk0 :
  @eq.{1} nat
    (@fin.val
       (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
          (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p
             (@nat.prime.pos p hp)))
       k)
    (@has_zero.zero.{0} nat nat.has_zero)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221        ... = k.val * (k.val + 1) : by simp [mul_add]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : distrib.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) a (@has_add.add.{?l_1} α (@distrib.to_has_add.{?l_1} α _inst_1) b c)) (@has_add.add.{?l_1} α (@distrib.to_has_add.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) a b) (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one)
⊢ @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@fin.val
          (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
             (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                p
                (@nat.prime.pos p hp)))
          k)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul
       (@fin.val
          (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
             (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                p
                (@nat.prime.pos p hp)))
          k)
       (@has_add.add.{0} nat nat.has_add
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222        ... &lt; p * p : mul_lt_mul k.2 k.2 (nat.succ_pos _) (nat.zero_le _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_lt_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.is_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.is_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.succ_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_semiring.{0} α] {a b c d : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) a c → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) b d → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1)))) b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1)))) c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))) a b) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))) c d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} (c : fin n), @has_lt.lt.{0} nat nat.has_lt (@fin.val n c) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {n : nat} (c : fin n), @has_lt.lt.{0} nat nat.has_lt (@fin.val n c) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (n : nat), @has_le.le.{0} nat nat.has_le (@has_zero.zero.{0} nat nat.has_zero) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one)
⊢ @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@fin.val
          (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
             (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                p
                (@nat.prime.pos p hp)))
          k)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul
       (@fin.val
          (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
             (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                p
                (@nat.prime.pos p hp)))
          k)
       (@has_add.add.{0} nat nat.has_add
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223      have hpk₁ : ¬ (p : ℤ[i]) ∣ ⟨k.val, -1⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224        λ ⟨x, hx⟩, lt_irrefl (p * x : ℤ[i]).norm.nat_abs $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_dvd.dvd.{0} gaussian_int (@comm_semiring_has_dvd.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225          calc (norm (p * x : ℤ[i])).nat_abs = (norm ⟨k.val, -1⟩).nat_abs : by rw hx</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@has_mul.mul.{0} gaussian_int (@mul_zero_class.to_has_mul.{0} gaussian_int (@semiring.to_mul_zero_class.{0} gaussian_int (@comm_semiring.to_semiring.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                            </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @eq.{1} nat
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} gaussian_int
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)
             x)))
    (int.nat_abs
       (@zsqrtd.norm ?m_1
          (@zsqrtd.mk ?m_1
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226          ... &lt; (norm (p : ℤ[i])).nat_abs : by simpa [norm] using hkltp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hkltp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one) (@has_mul.mul.{0} nat nat.has_mul (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k))) (@has_mul.mul.{0} nat nat.has_mul p p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @eq.{1} nat
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} gaussian_int
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)
             x)))
    (int.nat_abs
       (@zsqrtd.norm ?m_1
          (@zsqrtd.mk ?m_1
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @has_lt.lt.{0} nat nat.has_lt
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227          ... ≤ (norm (p * x : ℤ[i])).nat_abs : norm_le_norm_mul_left _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='gaussian_int.norm_le_norm_mul_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (x : gaussian_int) {y : gaussian_int}, @ne.{1} gaussian_int y (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) → @has_le.le.{0} nat nat.has_le (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)) (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @has_lt.lt.{0} nat nat.has_lt
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228            (λ hx0, (show (-1 : ℤ) ≠ 0, from dec_trivial) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hx0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='of_as_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 986, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@eq.{1} gaussian_int x (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {c : Prop} [h₁ : decidable c], @as_true c h₁ → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229              by simpa [hx0] using congr_arg zsqrtd.im hx),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='hx0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int x (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} {a₁ a₂ : α} (f : α → β), @eq.{1} α a₁ a₂ → @eq.{1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@has_mul.mul.{0} gaussian_int (@mul_zero_class.to_has_mul.{0} gaussian_int (@semiring.to_mul_zero_class.{0} gaussian_int (@comm_semiring.to_semiring.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x),
hx0 :
  @eq.{1} gaussian_int x
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @eq.{1} int (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230      have hpk₂ : ¬ (p : ℤ[i]) ∣ ⟨k.val, 1⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231        λ ⟨x, hx⟩, lt_irrefl (p * x : ℤ[i]).norm.nat_abs $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_dvd.dvd.{0} gaussian_int (@comm_semiring_has_dvd.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_one.one.{0} int int.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232          calc (norm (p * x : ℤ[i])).nat_abs = (norm ⟨k.val, 1⟩).nat_abs : by rw hx</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_one.one.{0} int int.has_one)) (@has_mul.mul.{0} gaussian_int (@mul_zero_class.to_has_mul.{0} gaussian_int (@semiring.to_mul_zero_class.{0} gaussian_int (@comm_semiring.to_semiring.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @eq.{1} nat
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} gaussian_int
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)
             x)))
    (int.nat_abs
       (@zsqrtd.norm ?m_1
          (@zsqrtd.mk ?m_1
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233          ... &lt; (norm (p : ℤ[i])).nat_abs : by simpa [norm] using hkltp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hkltp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one) (@has_mul.mul.{0} nat nat.has_mul (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k))) (@has_mul.mul.{0} nat nat.has_mul p p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @eq.{1} nat
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@has_mul.mul.{0} gaussian_int
             (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)
             x)))
    (int.nat_abs
       (@zsqrtd.norm ?m_1
          (@zsqrtd.mk ?m_1
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @has_lt.lt.{0} nat nat.has_lt
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_one.one.{0} int int.has_one))))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234          ... ≤ (norm (p * x : ℤ[i])).nat_abs : norm_le_norm_mul_left _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='gaussian_int.norm_le_norm_mul_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (x : gaussian_int) {y : gaussian_int}, @ne.{1} gaussian_int y (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) → @has_le.le.{0} nat nat.has_le (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)) (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@has_mul.mul.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x)
⊢ @has_lt.lt.{0} nat nat.has_lt
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                (@fin.val
                   (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                      (@subtype.mk.{1} nat
                         (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                         p
                         (@nat.prime.pos p hp)))
                   k))
             (@has_one.one.{0} int int.has_one))))
    (int.nat_abs
       (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235            (λ hx0, (show (1 : ℤ) ≠ 0, from dec_trivial) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hx0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='of_as_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 986, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@eq.{1} gaussian_int x (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {c : Prop} [h₁ : decidable c], @as_true c h₁ → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236                by simpa [hx0] using congr_arg zsqrtd.im hx),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='hx0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int x (@has_zero.zero.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} {a₁ a₂ : α} (f : α → β), @eq.{1} α a₁ a₂ → @eq.{1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_one.one.{0} int int.has_one)) (@has_mul.mul.{0} gaussian_int (@mul_zero_class.to_has_mul.{0} gaussian_int (@semiring.to_mul_zero_class.{0} gaussian_int (@comm_semiring.to_semiring.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
_x :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)),
_fun_match :
  @has_dvd.dvd.{0} gaussian_int
    (@comm_semiring_has_dvd.{0} gaussian_int
       (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one)) →
  false,
x : gaussian_int,
hx :
  @eq.{1} gaussian_int
    (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k))
       (@has_one.one.{0} int int.has_one))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       x),
hx0 :
  @eq.{1} gaussian_int x
    (@has_zero.zero.{0} gaussian_int
       (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237      have hpu : ¬ is_unit (p : ℤ[i]), from mt norm_eq_one_iff.2 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : monoid.{0} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {d : int} {x : zsqrtd d}, iff (@eq.{1} nat (int.nat_abs (@zsqrtd.norm d x)) (@has_one.one.{0} nat nat.has_one)) (@is_unit.{0} (zsqrtd d) (@zsqrtd.monoid d) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='is unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238        by rw [norm_nat_cast, int.nat_abs_mul, nat.mul_eq_one_iff];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='zsqrtd.norm_nat_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.mul_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 613, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {d : int} (n : nat), @eq.{1} int (@zsqrtd.norm d (@coe.{1 1} nat (zsqrtd d) (@coe_to_lift.{1 1} nat (zsqrtd d) (@coe_base.{1 1} nat (zsqrtd d) (@nat.cast_coe.{0} (zsqrtd d) (@zsqrtd.has_zero d) (@zsqrtd.has_one d) (@zsqrtd.has_add d)))) n)) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : int), @eq.{1} nat (int.nat_abs (@has_mul.mul.{0} int int.has_mul a b)) (@has_mul.mul.{0} nat nat.has_mul (int.nat_abs a) (int.nat_abs b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : nat}, iff (@eq.{1} nat (@has_mul.mul.{0} nat nat.has_mul a b) (@has_one.one.{0} nat nat.has_one)) (and (@eq.{1} nat a (@has_one.one.{0} nat nat.has_one)) (@eq.{1} nat b (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one)))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one)))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one)))
⊢ not
    (@eq.{1} nat
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one)))
⊢ not
    (and
       (@eq.{1} nat
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
          (@has_one.one.{0} nat nat.has_one))
       (@eq.{1} nat
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
          (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one)))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239        exact λ h, (ne_of_lt hp.one_lt).symm h.1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='ne_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @ne.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one)))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240      let ⟨y, hy⟩ := hpk in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hpk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (@has_add.add.{0} nat nat.has_add (@has_pow.pow.{0 0} nat nat nat.has_pow (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k) (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} nat nat.has_one)) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (@has_add.add.{0} nat nat.has_add (@has_pow.pow.{0 0} nat nat nat.has_pow (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k) (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241      by have := hpi.2.2 ⟨k.val, 1⟩ ⟨k.val, -1⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hpi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='zmodp p hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242        ⟨y, by rw [← hkmul, ← nat.cast_mul p, ← hy]; simp⟩;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hkmul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.cast_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int (@has_add.add.{0} gaussian_int (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@has_pow.pow.{0 0} gaussian_int nat (@monoid.has_pow.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} gaussian_int (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))) (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_one.one.{0} int int.has_one)) (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k)) (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : semiring.{0} α] (m n : nat), @eq.{1} α (@coe.{1 1} nat α (@coe_to_lift.{1 1} nat α (@coe_base.{1 1} nat α (@nat.cast_coe.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α _inst_1)) (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α _inst_1)) (@distrib.to_has_add.{0} α (@semiring.to_distrib.{0} α _inst_1))))) (@has_mul.mul.{0} nat nat.has_mul m n)) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α _inst_1)) (@coe.{1 1} nat α (@coe_to_lift.{1 1} nat α (@coe_base.{1 1} nat α (@nat.cast_coe.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α _inst_1)) (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α _inst_1)) (@distrib.to_has_add.{0} α (@semiring.to_distrib.{0} α _inst_1))))) m) (@coe.{1 1} nat α (@coe_to_lift.{1 1} nat α (@coe_base.{1 1} nat α (@nat.cast_coe.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α _inst_1)) (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α _inst_1)) (@distrib.to_has_add.{0} α (@semiring.to_distrib.{0} α _inst_1))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_pow.pow.{0 0} nat nat nat.has_pow (@fin.val (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) (@subtype.mk.{1} nat (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n) p (@nat.prime.pos p hp))) k) (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} nat nat.has_one)) (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring))) p y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ @eq.{1} gaussian_int
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@mul_zero_class.to_has_zero.{0} gaussian_int
                   (@semiring.to_mul_zero_class.{0} gaussian_int
                      (@zsqrtd.semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
                (@monoid.to_has_one.{0} gaussian_int
                   (@semiring.to_monoid.{0} gaussian_int
                      (@zsqrtd.semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
                (@distrib.to_has_add.{0} gaussian_int
                   (@semiring.to_distrib.{0} gaussian_int
                      (@zsqrtd.semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))))
       (@has_mul.mul.{0} nat nat.has_mul p y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@mul_zero_class.to_has_zero.{0} gaussian_int
                   (@semiring.to_mul_zero_class.{0} gaussian_int
                      (@zsqrtd.semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
                (@monoid.to_has_one.{0} gaussian_int
                   (@semiring.to_monoid.{0} gaussian_int
                      (@zsqrtd.semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
                (@distrib.to_has_add.{0} gaussian_int
                   (@semiring.to_distrib.{0} gaussian_int
                      (@zsqrtd.semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))))
       (@has_add.add.{0} nat nat.has_add
          (@has_pow.pow.{0 0} nat nat nat.has_pow
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k)
             (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ @eq.{1} gaussian_int
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
    (@has_mul.mul.{0} gaussian_int
       (@mul_zero_class.to_has_mul.{0} gaussian_int
          (@semiring.to_mul_zero_class.{0} gaussian_int
             (@comm_semiring.to_semiring.{0} gaussian_int
                (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243          clear_aux_decl; tauto)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 638, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`clear_aux_decl` clears every `aux_decl` in the local context for the current goal.
This includes the induction hypothesis when using the equation compiler and
`_let_match` and `_fun_match`.

It is useful when using a tactic such as `finish`, `simp *` or `subst` that may use these
auxiliary declarations, and produce an error saying the recursion is not well founded.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`
and splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged
using `reflexivity` or `solve_by_elim`.
This is a finishing tactic: it either closes the goal of raises an error.
The variant `tauto!` uses the law of excluded middle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='clear_aux_decl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='tauto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p),
hp1 :
  @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_one.one.{0} nat nat.has_one),
hp3 :
  @ne.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hp41 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@has_one.one.{0} nat nat.has_one),
_let_match :
  @Exists.{1} (zmodp p hp)
    (λ (y : zmodp p hp),
       @eq.{1} (zmodp p hp)
         (@has_pow.pow.{0 0} (zmodp p hp) nat
            (@monoid.has_pow.{0} (zmodp p hp)
               (@ring.to_monoid.{0} (zmodp p hp)
                  (@domain.to_ring.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
            y
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_neg.neg.{0} (zmodp p hp)
            (@add_group.to_has_neg.{0} (zmodp p hp)
               (@add_comm_group.to_add_group.{0} (zmodp p hp)
                  (@ring.to_add_comm_group.{0} (zmodp p hp)
                     (@domain.to_ring.{0} (zmodp p hp)
                        (@division_ring.to_domain.{0} (zmodp p hp)
                           (@field.to_division_ring.{0} (zmodp p hp)
                              (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
            (@has_one.one.{0} (zmodp p hp)
               (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
                  (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                     (@division_ring.to_domain.{0} (zmodp p hp)
                        (@field.to_division_ring.{0} (zmodp p hp)
                           (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))) →
  false,
k : zmodp p hp,
hk :
  @eq.{1} (zmodp p hp)
    (@has_pow.pow.{0 0} (zmodp p hp) nat
       (@monoid.has_pow.{0} (zmodp p hp)
          (@ring.to_monoid.{0} (zmodp p hp)
             (@domain.to_ring.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))
       k
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@has_neg.neg.{0} (zmodp p hp)
       (@add_group.to_has_neg.{0} (zmodp p hp)
          (@add_comm_group.to_add_group.{0} (zmodp p hp)
             (@ring.to_add_comm_group.{0} (zmodp p hp)
                (@domain.to_ring.{0} (zmodp p hp)
                   (@division_ring.to_domain.{0} (zmodp p hp)
                      (@field.to_division_ring.{0} (zmodp p hp)
                         (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp))))))))
       (@has_one.one.{0} (zmodp p hp)
          (@zero_ne_one_class.to_has_one.{0} (zmodp p hp)
             (@domain.to_zero_ne_one_class.{0} (zmodp p hp)
                (@division_ring.to_domain.{0} (zmodp p hp)
                   (@field.to_division_ring.{0} (zmodp p hp)
                      (@discrete_field.to_field.{0} (zmodp p hp) (@zmodp.discrete_field p hp)))))))),
hpk :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)),
hkmul :
  @eq.{1} gaussian_int
    (@has_add.add.{0} gaussian_int
       (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@has_pow.pow.{0 0} gaussian_int nat
          (@monoid.has_pow.{0} gaussian_int
             (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
          (@coe.{1 1} nat gaussian_int
             (@coe_to_lift.{1 1} nat gaussian_int
                (@coe_base.{1 1} nat gaussian_int
                   (@nat.cast_coe.{0} gaussian_int
                      (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                      (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} gaussian_int
          (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpne1 : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hkltp :
  @has_lt.lt.{0} nat nat.has_lt
    (@has_add.add.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)
       (@has_mul.mul.{0} nat nat.has_mul
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)))
    (@has_mul.mul.{0} nat nat.has_mul p p),
hpk₁ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))),
hpk₂ :
  not
    (@has_dvd.dvd.{0} gaussian_int
       (@comm_semiring_has_dvd.{0} gaussian_int
          (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)
       (@zsqrtd.mk (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@fin.val
                (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                   (@subtype.mk.{1} nat
                      (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                      p
                      (@nat.prime.pos p hp)))
                k))
          (@has_one.one.{0} int int.has_one))),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one)) →
  false,
y : nat,
hy :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (@fin.val
             (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
                (@subtype.mk.{1} nat
                   (λ (n : nat), @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n)
                   p
                   (@nat.prime.pos p hp)))
             k)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_one.one.{0} nat nat.has_one))
    (@has_mul.mul.{0} nat
       (@mul_zero_class.to_has_mul.{0} nat
          (@semiring.to_mul_zero_class.{0} nat (@comm_semiring.to_semiring.{0} nat nat.comm_semiring)))
       p
       y)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  lemma sum_two_squares_of_nat_prime_of_not_irreducible {p : ℕ} (hp : p.prime)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246    (hpi : ¬irreducible (p : ℤ[i])) : ∃ a b, a^2 + b^2 = p :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='irreducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : monoid.{u_1} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (@eq.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@eq.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' `irreducible p` states that `p` is non-unit and only factors into units.

We explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a
monoid allows us to reuse irreducible for associated elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  have hpu : ¬ is_unit (p : ℤ[i]), from mt norm_eq_one_iff.2 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : monoid.{0} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {d : int} {x : zsqrtd d}, iff (@eq.{1} nat (int.nat_abs (@zsqrtd.norm d x)) (@has_one.one.{0} nat nat.has_one)) (@is_unit.{0} (zsqrtd d) (@zsqrtd.monoid d) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='is unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    by rw [norm_nat_cast, int.nat_abs_mul, nat.mul_eq_one_iff];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='zsqrtd.norm_nat_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.nat_abs_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.mul_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 613, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {d : int} (n : nat), @eq.{1} int (@zsqrtd.norm d (@coe.{1 1} nat (zsqrtd d) (@coe_to_lift.{1 1} nat (zsqrtd d) (@coe_base.{1 1} nat (zsqrtd d) (@nat.cast_coe.{0} (zsqrtd d) (@zsqrtd.has_zero d) (@zsqrtd.has_one d) (@zsqrtd.has_add d)))) n)) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : int), @eq.{1} nat (int.nat_abs (@has_mul.mul.{0} int int.has_mul a b)) (@has_mul.mul.{0} nat nat.has_mul (int.nat_abs a) (int.nat_abs b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : nat}, iff (@eq.{1} nat (@has_mul.mul.{0} nat nat.has_mul a b) (@has_one.one.{0} nat nat.has_one)) (and (@eq.{1} nat a (@has_one.one.{0} nat nat.has_one)) (@eq.{1} nat b (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))
⊢ not
    (@eq.{1} nat
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))
⊢ not
    (and
       (@eq.{1} nat
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
          (@has_one.one.{0} nat nat.has_one))
       (@eq.{1} nat
          (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
          (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249      exact λ h, (ne_of_lt hp.one_lt).symm h.1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='ne_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @ne.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))
⊢ not
    (@eq.{1} nat
       (int.nat_abs
          (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
             (@coe.{1 1} nat gaussian_int
                (@coe_to_lift.{1 1} nat gaussian_int
                   (@coe_base.{1 1} nat gaussian_int
                      (@nat.cast_coe.{0} gaussian_int
                         (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                         (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                p)))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  have hab : ∃ a b, (p : ℤ[i]) = a * b ∧ ¬ is_unit a ∧ ¬ is_unit b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : monoid.{0} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : monoid.{0} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='is unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='is unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    by simpa [irreducible, hpu, classical.not_forall, not_or_distrib] using hpi,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='irreducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hpu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_or_distrib'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hpi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 576, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 366, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop}, iff (not (∀ (x : α), p x)) (@Exists.{?l_1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff (not (or a b)) (and (not a) (not b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@irreducible.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `irreducible p` states that `p` is non-unit and only factors into units.

We explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a
monoid allows us to reuse irreducible for associated elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))
⊢ @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  let ⟨a, b, hpab, hau, hbu⟩ := hab in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hau'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hbu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} gaussian_int (λ (a : gaussian_int), @Exists.{1} gaussian_int (λ (b : gaussian_int), and (@eq.{1} gaussian_int (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) a b)) (and (not (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) a)) (not (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b))))) → @Exists.{1} nat (λ (a : nat), @Exists.{1} nat (λ (b : nat), @eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='not (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='not (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@Exists.{1} gaussian_int (λ (a : gaussian_int), @Exists.{1} gaussian_int (λ (b : gaussian_int), and (@eq.{1} gaussian_int (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) a b)) (and (not (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) a)) (not (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  have hnap : (norm a).nat_abs = p, from ((hp.mul_eq_prime_pow_two_iff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='zsqrtd.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.mul_eq_prime_pow_two_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 243, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 339, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y p : nat}, nat.prime p → @ne.{1} nat x (@has_one.one.{0} nat nat.has_one) → @ne.{1} nat y (@has_one.one.{0} nat nat.has_one) → iff (@eq.{1} nat (@has_mul.mul.{0} nat nat.has_mul x y) (@has_pow.pow.{0 0} nat nat nat.has_pow p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (and (@eq.{1} nat x p) (@eq.{1} nat y p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254      (mt norm_eq_one_iff.1 hau) (mt norm_eq_one_iff.1 hbu)).1 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zsqrtd.norm_eq_one_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {d : int} {x : zsqrtd d}, iff (@eq.{1} nat (int.nat_abs (@zsqrtd.norm d x)) (@has_one.one.{0} nat nat.has_one)) (@is_unit.{0} (zsqrtd d) (@zsqrtd.monoid d) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {d : int} {x : zsqrtd d}, iff (@eq.{1} nat (int.nat_abs (@zsqrtd.norm d x)) (@has_one.one.{0} nat nat.has_one)) (@is_unit.{0} (zsqrtd d) (@zsqrtd.monoid d) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255    by rw [← int.coe_nat_inj&#x27;, int.coe_nat_pow, _root_.pow_two,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='int.coe_nat_inj&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.coe_nat_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pow_two'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 434, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, iff (@eq.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) m) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)) (@eq.{1} nat m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n m : nat), @eq.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@has_pow.pow.{0 0} nat nat nat.has_pow n m)) (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a : α), @eq.{1} α (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α _inst_1) a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat nat.has_mul
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b)))
    (@has_pow.pow.{0 0} nat nat nat.has_pow p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} int
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} int
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b))))
    (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} int
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b))))
    (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int (@monoid.to_semigroup.{0} int int.monoid))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256      ← @norm_nat_cast (-1), hpab];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='zsqrtd.norm_nat_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hpab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {d : int} (n : nat), @eq.{1} int (@zsqrtd.norm d (@coe.{1 1} nat (zsqrtd d) (@coe_to_lift.{1 1} nat (zsqrtd d) (@coe_base.{1 1} nat (zsqrtd d) (@nat.cast_coe.{0} (zsqrtd d) (@zsqrtd.has_zero d) (@zsqrtd.has_one d) (@zsqrtd.has_add d)))) n)) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} gaussian_int (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) (@has_mul.mul.{0} gaussian_int (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} int
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b))))
    (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int (@monoid.to_semigroup.{0} int int.monoid))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} int
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b))))
    (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@coe.{1 1} nat (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
          (@coe_to_lift.{1 1} nat (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
             (@coe_base.{1 1} nat (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@nat.cast_coe.{0} (zsqrtd (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} int
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_mul.mul.{0} nat nat.has_mul
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b))))
    (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))
       (@has_mul.mul.{0} gaussian_int
          (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
          a
          b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat nat.has_mul
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b)))
    (@has_pow.pow.{0 0} nat nat nat.has_pow p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257      simp).1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) b)
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat nat.has_mul
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
       (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) b)))
    (@has_pow.pow.{0 0} nat nat nat.has_pow p (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  ⟨a.re.nat_abs, a.im.nat_abs, by simpa [nat_abs_norm_eq, nat.pow_two] using hnap⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zsqrtd.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='zsqrtd.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='int.nat_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='gaussian_int.nat_abs_norm_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.pow_two'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hnap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zsqrtd/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 773, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {d : int}, zsqrtd d → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : gaussian_int), @eq.{1} nat (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)) (@has_add.add.{0} nat nat.has_add (@has_mul.mul.{0} nat nat.has_mul (int.nat_abs (@zsqrtd.re (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)) (int.nat_abs (@zsqrtd.re (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))) (@has_mul.mul.{0} nat nat.has_mul (int.nat_abs (@zsqrtd.im (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x)) (int.nat_abs (@zsqrtd.im (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : nat), @eq.{1} nat (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{0} nat nat.has_mul a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a)) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hpu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
hab :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))),
_let_match :
  @Exists.{1} gaussian_int
    (λ (a : gaussian_int),
       @Exists.{1} gaussian_int
         (λ (b : gaussian_int),
            and
              (@eq.{1} gaussian_int
                 (@coe.{1 1} nat gaussian_int
                    (@coe_to_lift.{1 1} nat gaussian_int
                       (@coe_base.{1 1} nat gaussian_int
                          (@nat.cast_coe.{0} gaussian_int
                             (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                             (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
                    p)
                 (@has_mul.mul.{0} gaussian_int
                    (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                    a
                    b))
              (and
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       a))
                 (not
                    (@is_unit.{0} gaussian_int
                       (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                       b))))) →
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)),
a b : gaussian_int,
hpab :
  @eq.{1} gaussian_int
    (@coe.{1 1} nat gaussian_int
       (@coe_to_lift.{1 1} nat gaussian_int
          (@coe_base.{1 1} nat gaussian_int
             (@nat.cast_coe.{0} gaussian_int
                (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
       p)
    (@has_mul.mul.{0} gaussian_int
       (@zsqrtd.has_mul (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a
       b),
hau :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       a),
hbu :
  not
    (@is_unit.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
       b),
hnap :
  @eq.{1} nat (int.nat_abs (@zsqrtd.norm (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a)) p
⊢ @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (int.nat_abs (@zsqrtd.re (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_pow.pow.{0 0} nat nat nat.has_pow
          (int.nat_abs (@zsqrtd.im (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)) a))
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  lemma prime_of_nat_prime_of_mod_four_eq_three {p : ℕ} (hp : p.prime) (hp3 : p % 4 = 3) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261    prime (p : ℤ[i]) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='prime element of a semiring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  irreducible_iff_prime.1 $ classical.by_contradiction $ λ hpi,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='principal_ideal_domain.irreducible_iff_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='classical.by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hpi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/principal_ideal_domain.lean&#x27;, &#x27;line&#x27;: 135, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : principal_ideal_domain.{0} α] {p : α}, iff (@irreducible.{0} α (@ring.to_monoid.{0} α (@domain.to_ring.{0} α (@integral_domain.to_domain.{0} α (@principal_ideal_domain.to_integral_domain.{0} α _inst_1)))) p) (@prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α (@principal_ideal_domain.to_integral_domain.{0} α _inst_1)))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {p : Prop}, (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@irreducible.{0} gaussian_int (@ring.to_monoid.{0} gaussian_int (@domain.to_ring.{0} gaussian_int (@integral_domain.to_domain.{0} gaussian_int (@principal_ideal_domain.to_integral_domain.{0} gaussian_int (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain))))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    let ⟨a, b, hab⟩ := sum_two_squares_of_nat_prime_of_not_irreducible hp hpi in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='gaussian_int.sum_two_squares_of_nat_prime_of_not_irreducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hpi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 245, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{1} nat (λ (a : nat), @Exists.{1} nat (λ (b : nat), @eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) p)) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {p : nat}, nat.prime p → not (@irreducible.{0} gaussian_int (@zsqrtd.monoid (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p)) → @Exists.{1} nat (λ (a : nat), @Exists.{1} nat (λ (b : nat), @eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@irreducible.{0} gaussian_int (@ring.to_monoid.{0} gaussian_int (@domain.to_ring.{0} gaussian_int (@integral_domain.to_domain.{0} gaussian_int (@principal_ideal_domain.to_integral_domain.{0} gaussian_int (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain))))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  have ∀ a b : zmod 4, a^2 + b^2 ≠ p, by erw [← zmod.cast_mod_nat 4 p, hp3]; exact dec_trivial,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='zmod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='zmod.cast_mod_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hp3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='of_as_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zmod/basic.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/zmod/basic.lean&#x27;, &#x27;line&#x27;: 156, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 986, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='pnat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : pnat) (a : nat), @eq.{1} (zmod n) (@coe.{1 1} nat (zmod n) (@coe_to_lift.{1 1} nat (zmod n) (@coe_base.{1 1} nat (zmod n) (@nat.cast_coe.{0} (zmod n) (zmod.has_zero n) (zmod.has_one n) (@distrib.to_has_add.{0} (zmod n) (@ring.to_distrib.{0} (zmod n) (@comm_ring.to_ring.{0} (zmod n) (zmod.comm_ring n))))))) (@has_mod.mod.{0} nat nat.has_mod a (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat)) n))) (@coe.{1 1} nat (zmod n) (@coe_to_lift.{1 1} nat (zmod n) (@coe_base.{1 1} nat (zmod n) (@nat.cast_coe.{0} (zmod n) (zmod.has_zero n) (zmod.has_one n) (@distrib.to_has_add.{0} (zmod n) (@ring.to_distrib.{0} (zmod n) (@comm_ring.to_ring.{0} (zmod n) (zmod.comm_ring n))))))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h₁ : decidable c], @as_true c h₁ → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Auxiliary definition used to implement begin ... end blocks'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hp3 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)) →
  false,
a b : nat,
hab :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    p
⊢ ∀
  (a b :
    zmod
      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))),
    @ne.{1}
      (zmod
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@has_one.one.{0} pnat
                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
      (@has_add.add.{0}
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@distrib.to_has_add.{0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@ring.to_distrib.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@comm_ring.to_ring.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.comm_ring
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            a
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            b
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      (@coe.{1 1} nat
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@coe_to_lift.{1 1} nat
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@coe_base.{1 1} nat
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@nat.cast_coe.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_zero
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_one
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@distrib.to_has_add.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (@ring.to_distrib.{0}
                        (zmod
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@has_one.one.{0} pnat
                                    (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                        (@comm_ring.to_ring.{0}
                           (zmod
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                           (zmod.comm_ring
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
         p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hp3 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)) →
  false,
a b : nat,
hab :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    p
⊢ ∀
  (a b :
    zmod
      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))),
    @ne.{1}
      (zmod
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@has_one.one.{0} pnat
                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
      (@has_add.add.{0}
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@distrib.to_has_add.{0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@ring.to_distrib.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@comm_ring.to_ring.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.comm_ring
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            a
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            b
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      (@coe.{1 1} nat
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@coe_to_lift.{1 1} nat
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@coe_base.{1 1} nat
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@nat.cast_coe.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_zero
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_one
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@distrib.to_has_add.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (@ring.to_distrib.{0}
                        (zmod
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@has_one.one.{0} pnat
                                    (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                        (@comm_ring.to_ring.{0}
                           (zmod
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                           (zmod.comm_ring
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
         (@has_mod.mod.{0} nat nat.has_mod p
            (@coe.{1 1} pnat nat (@coe_to_lift.{1 1} pnat nat (@coe_base.{1 1} pnat nat coe_pnat_nat))
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hp3 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)) →
  false,
a b : nat,
hab :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    p
⊢ ∀
  (a b :
    zmod
      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))),
    @ne.{1}
      (zmod
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@has_one.one.{0} pnat
                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
      (@has_add.add.{0}
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@distrib.to_has_add.{0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@ring.to_distrib.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@comm_ring.to_ring.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.comm_ring
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            a
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            b
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      (@coe.{1 1} nat
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@coe_to_lift.{1 1} nat
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@coe_base.{1 1} nat
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@nat.cast_coe.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_zero
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_one
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@distrib.to_has_add.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (@ring.to_distrib.{0}
                        (zmod
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@has_one.one.{0} pnat
                                    (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                        (@comm_ring.to_ring.{0}
                           (zmod
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                           (zmod.comm_ring
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
         (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hp3 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)) →
  false,
a b : nat,
hab :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    p
⊢ ∀
  (a b :
    zmod
      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))),
    @ne.{1}
      (zmod
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@has_one.one.{0} pnat
                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
      (@has_add.add.{0}
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@distrib.to_has_add.{0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@ring.to_distrib.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@comm_ring.to_ring.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.comm_ring
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            a
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            b
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      (@coe.{1 1} nat
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@coe_to_lift.{1 1} nat
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@coe_base.{1 1} nat
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@nat.cast_coe.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_zero
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_one
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@distrib.to_has_add.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (@ring.to_distrib.{0}
                        (zmod
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@has_one.one.{0} pnat
                                    (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                        (@comm_ring.to_ring.{0}
                           (zmod
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                           (zmod.comm_ring
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
         p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  this a b (hab ▸ by simp)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))), @ne.{1} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@has_add.add.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@distrib.to_has_add.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@ring.to_distrib.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@comm_ring.to_ring.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (zmod.comm_ring (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))) (@has_pow.pow.{0 0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) nat (@monoid.has_pow.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@ring.to_monoid.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@comm_ring.to_ring.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (zmod.comm_ring (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))) a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_pow.pow.{0 0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) nat (@monoid.has_pow.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@ring.to_monoid.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@comm_ring.to_ring.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (zmod.comm_ring (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))) b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (@coe.{1 1} nat (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@coe_to_lift.{1 1} nat (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@coe_base.{1 1} nat (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@nat.cast_coe.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (zmod.has_zero (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (zmod.has_one (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@distrib.to_has_add.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@ring.to_distrib.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (@comm_ring.to_ring.{0} (zmod (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))) (zmod.comm_ring (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib) (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
hp3 :
  @eq.{1} nat
    (@has_mod.mod.{0} nat nat.has_mod p
       (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)),
hpi :
  not
    (@irreducible.{0} gaussian_int
       (@ring.to_monoid.{0} gaussian_int
          (@domain.to_ring.{0} gaussian_int
             (@integral_domain.to_domain.{0} gaussian_int
                (@principal_ideal_domain.to_integral_domain.{0} gaussian_int
                   (@euclidean_domain.to_principal_ideal_domain.{0} gaussian_int gaussian_int.euclidean_domain)))))
       (@coe.{1 1} nat gaussian_int
          (@coe_to_lift.{1 1} nat gaussian_int
             (@coe_base.{1 1} nat gaussian_int
                (@nat.cast_coe.{0} gaussian_int
                   (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))
                   (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))))))
          p)),
_let_match :
  @Exists.{1} nat
    (λ (a : nat),
       @Exists.{1} nat
         (λ (b : nat),
            @eq.{1} nat
              (@has_add.add.{0} nat nat.has_add
                 (@has_pow.pow.{0 0} nat nat nat.has_pow a
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                 (@has_pow.pow.{0 0} nat nat nat.has_pow b
                    (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
              p)) →
  false,
a b : nat,
hab :
  @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    p,
this :
  ∀
  (a b :
    zmod
      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))),
    @ne.{1}
      (zmod
         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@has_one.one.{0} pnat
                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
      (@has_add.add.{0}
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@distrib.to_has_add.{0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@ring.to_distrib.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@comm_ring.to_ring.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.comm_ring
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            a
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         (@has_pow.pow.{0 0}
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            nat
            (@monoid.has_pow.{0}
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@ring.to_monoid.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@comm_ring.to_ring.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (zmod.comm_ring
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
            b
            (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      (@coe.{1 1} nat
         (zmod
            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@has_one.one.{0} pnat
                     (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
         (@coe_to_lift.{1 1} nat
            (zmod
               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@has_one.one.{0} pnat
                        (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
            (@coe_base.{1 1} nat
               (zmod
                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@has_one.one.{0} pnat
                           (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
               (@nat.cast_coe.{0}
                  (zmod
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_zero
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (zmod.has_one
                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@has_one.one.{0} pnat
                              (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                  (@distrib.to_has_add.{0}
                     (zmod
                        (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@has_one.one.{0} pnat
                                 (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                     (@ring.to_distrib.{0}
                        (zmod
                           (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@has_one.one.{0} pnat
                                    (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                        (@comm_ring.to_ring.{0}
                           (zmod
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                           (zmod.comm_ring
                              (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                 (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                    (@has_one.one.{0} pnat
                                       (@monoid.to_has_one.{0} pnat
                                          (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
         p)
⊢ @eq.{1}
    (zmod
       (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
          (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
             (@has_one.one.{0} pnat (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
    (@has_add.add.{0}
       (zmod
          (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
             (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                (@has_one.one.{0} pnat
                   (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
       (@distrib.to_has_add.{0}
          (zmod
             (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@has_one.one.{0} pnat
                      (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
          (@ring.to_distrib.{0}
             (zmod
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@has_one.one.{0} pnat
                         (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
             (@comm_ring.to_ring.{0}
                (zmod
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (zmod.comm_ring
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
       (@has_pow.pow.{0 0}
          (zmod
             (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@has_one.one.{0} pnat
                      (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
          nat
          (@monoid.has_pow.{0}
             (zmod
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@has_one.one.{0} pnat
                         (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
             (@ring.to_monoid.{0}
                (zmod
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (@comm_ring.to_ring.{0}
                   (zmod
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@has_one.one.{0} pnat
                               (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                   (zmod.comm_ring
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@has_one.one.{0} pnat
                               (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
          (@coe.{1 1} nat
             (zmod
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@has_one.one.{0} pnat
                         (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
             (@coe_to_lift.{1 1} nat
                (zmod
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (@coe_base.{1 1} nat
                   (zmod
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@has_one.one.{0} pnat
                               (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                   (@nat.cast_coe.{0}
                      (zmod
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@has_one.one.{0} pnat
                                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                      (zmod.has_zero
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@has_one.one.{0} pnat
                                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                      (zmod.has_one
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@has_one.one.{0} pnat
                                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                      (@distrib.to_has_add.{0}
                         (zmod
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                  (@has_one.one.{0} pnat
                                     (@monoid.to_has_one.{0} pnat
                                        (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                         (@ring.to_distrib.{0}
                            (zmod
                               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                     (@has_one.one.{0} pnat
                                        (@monoid.to_has_one.{0} pnat
                                           (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                            (@comm_ring.to_ring.{0}
                               (zmod
                                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                        (@has_one.one.{0} pnat
                                           (@monoid.to_has_one.{0} pnat
                                              (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                               (zmod.comm_ring
                                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                        (@has_one.one.{0} pnat
                                           (@monoid.to_has_one.{0} pnat
                                              (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
             a)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@has_pow.pow.{0 0}
          (zmod
             (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@has_one.one.{0} pnat
                      (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
          nat
          (@monoid.has_pow.{0}
             (zmod
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@has_one.one.{0} pnat
                         (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
             (@ring.to_monoid.{0}
                (zmod
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (@comm_ring.to_ring.{0}
                   (zmod
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@has_one.one.{0} pnat
                               (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                   (zmod.comm_ring
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@has_one.one.{0} pnat
                               (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid)))))))))
          (@coe.{1 1} nat
             (zmod
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@has_one.one.{0} pnat
                         (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
             (@coe_to_lift.{1 1} nat
                (zmod
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (@coe_base.{1 1} nat
                   (zmod
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@has_one.one.{0} pnat
                               (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                   (@nat.cast_coe.{0}
                      (zmod
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@has_one.one.{0} pnat
                                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                      (zmod.has_zero
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@has_one.one.{0} pnat
                                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                      (zmod.has_one
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@has_one.one.{0} pnat
                                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                      (@distrib.to_has_add.{0}
                         (zmod
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                  (@has_one.one.{0} pnat
                                     (@monoid.to_has_one.{0} pnat
                                        (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                         (@ring.to_distrib.{0}
                            (zmod
                               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                     (@has_one.one.{0} pnat
                                        (@monoid.to_has_one.{0} pnat
                                           (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                            (@comm_ring.to_ring.{0}
                               (zmod
                                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                        (@has_one.one.{0} pnat
                                           (@monoid.to_has_one.{0} pnat
                                              (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                               (zmod.comm_ring
                                  (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                     (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                        (@has_one.one.{0} pnat
                                           (@monoid.to_has_one.{0} pnat
                                              (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
             b)
          (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@coe.{1 1} nat
       (zmod
          (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
             (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                (@has_one.one.{0} pnat
                   (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
       (@coe_to_lift.{1 1} nat
          (zmod
             (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@has_one.one.{0} pnat
                      (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
          (@coe_base.{1 1} nat
             (zmod
                (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@has_one.one.{0} pnat
                         (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
             (@nat.cast_coe.{0}
                (zmod
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (zmod.has_zero
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (zmod.has_one
                   (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@has_one.one.{0} pnat
                            (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                (@distrib.to_has_add.{0}
                   (zmod
                      (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@has_one.one.{0} pnat
                               (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                   (@ring.to_distrib.{0}
                      (zmod
                         (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@has_one.one.{0} pnat
                                  (@monoid.to_has_one.{0} pnat (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                      (@comm_ring.to_ring.{0}
                         (zmod
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                  (@has_one.one.{0} pnat
                                     (@monoid.to_has_one.{0} pnat
                                        (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))
                         (zmod.comm_ring
                            (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                               (@bit0.{0} pnat (@distrib.to_has_add.{0} pnat pnat.distrib)
                                  (@has_one.one.{0} pnat
                                     (@monoid.to_has_one.{0} pnat
                                        (@comm_monoid.to_monoid.{0} pnat pnat.comm_monoid))))))))))))
       (@has_add.add.{0} nat nat.has_add
          (@has_pow.pow.{0 0} nat nat nat.has_pow a (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@has_pow.pow.{0 0} nat nat nat.has_pow b (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  /-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  lemma prime_iff_mod_four_eq_three_of_nat_prime {p : ℕ} (hp : p.prime) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269    prime (p : ℤ[i]) ↔ p % 4 = 3 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gaussian_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mod.mod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 38, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mod.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='prime element of a semiring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  ⟨mod_four_eq_three_of_nat_prime_of_prime hp, prime_of_nat_prime_of_mod_four_eq_three hp⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gaussian_int.mod_four_eq_three_of_nat_prime_of_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gaussian_int.prime_of_nat_prime_of_mod_four_eq_three'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 192, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 260, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nat}, nat.prime p → @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p) → @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {p : nat}, nat.prime p → @eq.{1} nat (@has_mod.mod.{0} nat nat.has_mod p (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)) → @prime.{0} gaussian_int (@zsqrtd.comm_semiring (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@coe.{1 1} nat gaussian_int (@coe_to_lift.{1 1} nat gaussian_int (@coe_base.{1 1} nat gaussian_int (@nat.cast_coe.{0} gaussian_int (@zsqrtd.has_zero (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_one (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one))) (@zsqrtd.has_add (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  end gaussian_int</code></pre>
</body>