<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Chris Hughes. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Chris Hughes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  Mostly based on Jeremy Avigad&#x27;s choose file in lean 2</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.nat.basic data.nat.prime</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import algebra.big_operators algebra.commute</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/commute.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open nat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  lemma nat.prime.dvd_choose {p k : ℕ} (hk : 0 &lt; k) (hkp : k &lt; p) (hp : prime p) : p ∣ choose p k :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1062, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' `choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial
coefficients.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  have h₁ : p ∣ fact p, from hp.dvd_fact.2 (le_refl _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.fact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.dvd_fact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 984, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 356, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n p : nat}, nat.prime p → iff (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact n)) (@has_le.le.{0} nat nat.has_le p n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`fact n` is the factorial of `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  have h₂ : ¬p ∣ fact k, from mt hp.dvd_fact.1 (not_le_of_gt hkp),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.fact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.dvd_fact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='not_le_of_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hkp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 984, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 356, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n p : nat}, nat.prime p → iff (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact n)) (@has_le.le.{0} nat nat.has_le p n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @gt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → not (@has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt k p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`fact n` is the factorial of `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  have h₃ : ¬p ∣ fact (p - k), from mt hp.dvd_fact.1 (not_le_of_gt (nat.sub_lt_self hp.pos hk)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.fact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.dvd_fact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='not_le_of_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.sub_lt_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 984, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 356, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n p : nat}, nat.prime p → iff (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact n)) (@has_le.le.{0} nat nat.has_le p n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @gt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → not (@has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {m n : nat}, @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) m → @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n → @has_lt.lt.{0} nat nat.has_lt (@has_sub.sub.{0} nat nat.has_sub m n) m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`fact n` is the factorial of `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  by rw [← choose_mul_fact_mul_fact (le_of_lt hkp), mul_assoc, hp.dvd_mul, hp.dvd_mul] at h₁;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.choose_mul_fact_mul_fact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hkp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1108, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n k : nat}, @has_le.le.{0} nat nat.has_le k n → @eq.{1} nat (@has_mul.mul.{0} nat nat.has_mul (@has_mul.mul.{0} nat nat.has_mul (nat.choose n k) (nat.fact k)) (nat.fact (@has_sub.sub.{0} nat nat.has_sub n k))) (nat.fact n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt k p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : semigroup.{0} α] (a b c : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) a b) c) (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) a (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (@has_mul.mul.{0} nat nat.has_mul (nat.choose p k) (@has_mul.mul.{0} nat (@semigroup.to_has_mul.{0} nat nat.semigroup) (nat.fact k) (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))))) (or (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)) (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (@has_mul.mul.{0} nat (@semigroup.to_has_mul.{0} nat nat.semigroup) (nat.fact k) (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (@has_mul.mul.{0} nat nat.has_mul (nat.fact k) (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))) (or (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)) (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₁ : @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact p),
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))),
h₁ :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_mul.mul.{0} nat nat.has_mul (@has_mul.mul.{0} nat nat.has_mul (nat.choose p k) (nat.fact k))
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))),
h₁ :
  @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
    (@has_mul.mul.{0} nat (@semigroup.to_has_mul.{0} nat nat.semigroup) (nat.choose p k)
       (@has_mul.mul.{0} nat (@semigroup.to_has_mul.{0} nat nat.semigroup) (nat.fact k)
          (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))),
h₁ :
  or (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k))
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (@has_mul.mul.{0} nat (@semigroup.to_has_mul.{0} nat nat.semigroup) (nat.fact k)
          (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))),
h₁ :
  or (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k))
    (or (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k))
       (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
          (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₁ : @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact p),
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17    exact h₁.resolve_right (not_or_distrib.2 ⟨h₂, h₃⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_or_distrib'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 484, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 366, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)) (or (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)) (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff (not (or a b)) (and (not a) (not b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₁ : @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact p),
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p k : nat,
hk : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) k,
hkp : @has_lt.lt.{0} nat nat.has_lt k p,
hp : nat.prime p,
h₁ : @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact p),
h₂ : not (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.fact k)),
h₃ :
  not
    (@has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p
       (nat.fact (@has_sub.sub.{0} nat nat.has_sub p k)))
⊢ @has_dvd.dvd.{0} nat (@comm_semiring_has_dvd.{0} nat nat.comm_semiring) p (nat.choose p k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  section binomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  open finset</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  variables {α : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  /-- A version of the binomial theorem for noncommutative semirings. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  theorem commute.add_pow [semiring α] {x y : α} (h : commute x y) (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='semiring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='commute'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/commute.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {S : Type u_1} [_inst_1 : has_mul.{u_1} S], S → S → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='Two elements commute iff `a * b = b * a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26    (x + y) ^ n = (range (succ n)).sum (λ m, x ^ m * y ^ (n - m) * choose n m) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1062, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_add.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type} [c : has_pow.{u_1 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β], finset.{0} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type} [c : has_pow.{u_1 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type} [c : has_pow.{u_1 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title=' `choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial
coefficients.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    let t : ℕ → ℕ → α := λ n i, x ^ i * (y ^ (n - i)) * (choose n i),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1062, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type} [c : has_pow.{u_1 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial
coefficients.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
       (λ (m : nat),
          @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
            (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x m)
               (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                  (@has_sub.sub.{0} nat nat.has_sub n m)))
            (@coe.{1 u_1+1} nat α
               (@coe_to_lift.{1 u_1+1} nat α
                  (@coe_base.{1 u_1+1} nat α
                     (@nat.cast_coe.{u_1} α
                        (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                        (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                        (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
               (nat.choose n m))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
       (λ (m : nat),
          @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
            (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x m)
               (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                  (@has_sub.sub.{0} nat nat.has_sub n m)))
            (@coe.{1 u_1+1} nat α
               (@coe_to_lift.{1 u_1+1} nat α
                  (@coe_base.{1 u_1+1} nat α
                     (@nat.cast_coe.{u_1} α
                        (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                        (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                        (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
               (nat.choose n m))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    change (x + y) ^ n = (range n.succ).sum (t n),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [c : has_add.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
       (λ (m : nat),
          @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
            (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x m)
               (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                  (@has_sub.sub.{0} nat nat.has_sub n m)))
            (@coe.{1 u_1+1} nat α
               (@coe_to_lift.{1 u_1+1} nat α
                  (@coe_base.{1 u_1+1} nat α
                     (@nat.cast_coe.{u_1} α
                        (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                        (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                        (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
               (nat.choose n m))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    have h_first : ∀ n, t n 0 = y ^ n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      λ n, by { dsimp [t], rw[choose_zero_right, nat.cast_one, mul_one, one_mul] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nat.choose_zero_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.cast_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1067, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{1} nat (nat.choose n (@has_zero.zero.{0} nat nat.has_zero)) (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_monoid.{u_1} α] [_inst_2 : has_one.{u_1} α], @eq.{u_1+1} α (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α (@add_monoid.to_has_zero.{u_1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1))))) (@has_one.one.{0} nat nat.has_one)) (@has_one.one.{u_1} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
n : nat
⊢ @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (@has_zero.zero.{0} nat nat.has_zero))))
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (@has_one.one.{0} nat nat.has_one)))
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n))
       (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))))
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n))
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (@has_zero.zero.{0} nat nat.has_zero))))
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    have h_last : ∀ n, t n n.succ = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33      λ n, by { dsimp [t], rw [choose_succ_self, nat.cast_zero, mul_zero] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.choose_succ_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.cast_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1084, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{1} nat (nat.choose n (nat.succ n)) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : has_zero.{u_1} α] [_inst_2 : has_one.{u_1} α] [_inst_3 : has_add.{u_1} α], @eq.{u_1+1} α (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α _inst_1 _inst_2 _inst_3))) (@has_zero.zero.{0} nat nat.has_zero)) (@has_zero.zero.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : mul_zero_class.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α _inst_1) a (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))) (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
n : nat
⊢ @eq.{u_1+1} α (t n (nat.succ n))
    (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ n))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ n))))
    (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ n))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (@has_zero.zero.{0} nat nat.has_zero)))
    (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ n))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))))
    (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
n : nat
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ n))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ n))))
    (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    have h_middle : ∀ (n i : ℕ), (i ∈ finset.range n.succ) →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35     ((t n.succ) ∘ nat.succ) i = x * (t n i) + y * (t n i.succ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type} {φ : Type u_1}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    begin</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
⊢ ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      intros n i h_mem,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
⊢ ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n))
⊢ @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (t n i))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (t n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      have h_le : i ≤ n := nat.le_of_lt_succ (finset.mem_range.mp h_mem),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.le_of_lt_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 329, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, @has_lt.lt.{0} nat nat.has_lt m (nat.succ n) → @has_le.le.{0} nat nat.has_le m n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n m : nat}, iff (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) m (finset.range n)) (@has_lt.lt.{0} nat nat.has_lt m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n))
⊢ @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (t n i))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (t n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (t n i))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (t n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      dsimp [t],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (t n i))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (t n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose (nat.succ n) (nat.succ i))))
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n i))))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                   (nat.succ i))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n (nat.succ i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      rw [choose_succ_succ, nat.cast_add, mul_add],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.choose_succ_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.cast_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1071, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n k : nat), @eq.{1} nat (nat.choose (nat.succ n) (nat.succ k)) (@has_add.add.{0} nat nat.has_add (nat.choose n k) (nat.choose n (nat.succ k)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_monoid.{u_1} α] [_inst_2 : has_one.{u_1} α] (m n : nat), @eq.{u_1+1} α (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α (@add_monoid.to_has_zero.{u_1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1))))) (@has_add.add.{0} nat nat.has_add m n)) (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1)) (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α (@add_monoid.to_has_zero.{u_1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1))))) m) (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α (@add_monoid.to_has_zero.{u_1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : distrib.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) b c)) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a b) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose (nat.succ n) (nat.succ i))))
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n i))))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                   (nat.succ i))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n (nat.succ i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (@has_add.add.{0} nat nat.has_add (nat.choose n i) (nat.choose n (nat.succ i)))))
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n i))))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                   (nat.succ i))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n (nat.succ i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n i))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n (nat.succ i)))))
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n i))))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                   (nat.succ i))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n (nat.succ i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n i)))
       (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n (nat.succ i)))))
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n i))))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                   (nat.succ i))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n (nat.succ i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41      congr&#x27; 1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n i)))
       (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n (nat.succ i)))))
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n i))))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                   (nat.succ i))
                (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                   (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
                (nat.choose n (nat.succ i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n i)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))

α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n (nat.succ i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42      { rw[pow_succ x, succ_sub_succ, mul_assoc, mul_assoc, mul_assoc] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pow_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.succ_sub_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 494, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α) (n : nat), @eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n m : nat), @eq.{1} nat (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ m)) (@has_sub.sub.{0} nat nat.has_sub n m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n i)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))

α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n (nat.succ i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n i)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             x
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n i)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             x
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n i)))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n i)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          x
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n i))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n i))))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       x
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@add_monoid.to_has_zero.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@add_semigroup.to_has_add.{u_1} α
                            (@add_monoid.to_add_semigroup.{u_1} α
                               (@add_comm_monoid.to_add_monoid.{u_1} α
                                  (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
                (nat.choose n i)))))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n i)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n (nat.succ i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43      { rw[← mul_assoc y, ← mul_assoc y, (h.symm.pow_right i.succ).eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/commute.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='If `a` commutes with `b`, then `b` commutes with `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n (nat.succ i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          y
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             y
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44        by_cases h_eq : i = n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))

α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45        { rw [h_eq, choose_succ_self, nat.cast_zero, mul_zero, mul_zero] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.choose_succ_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.cast_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1084, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat i n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{1} nat (nat.choose n (nat.succ n)) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : has_zero.{u_1} α] [_inst_2 : has_one.{u_1} α] [_inst_3 : has_add.{u_1} α], @eq.{u_1+1} α (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α _inst_1 _inst_2 _inst_3))) (@has_zero.zero.{0} nat nat.has_zero)) (@has_zero.zero.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : mul_zero_class.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α _inst_1) a (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))) (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : mul_zero_class.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α _inst_1) a (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))) (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))

α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ n))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ n))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ n))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ n))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ n))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ n))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (@has_zero.zero.{0} nat nat.has_zero)))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ n))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (@has_zero.zero.{0} nat nat.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ n))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ n))))
       (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ n))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ n))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ n))))
       (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : @eq.{1} nat i n
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46        { rw[succ_sub (lt_of_le_of_ne h_le h_eq)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nat.succ_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_of_le_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 974, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, @ge.{0} nat nat.has_le m n → @eq.{1} nat (@has_sub.sub.{0} nat nat.has_sub (nat.succ m) n) (nat.succ (@has_sub.sub.{0} nat nat.has_sub m n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @ne.{1} α a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} nat nat.has_le i n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} nat i n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47          rw[pow_succ y, mul_assoc, mul_assoc, mul_assoc, mul_assoc] } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='pow_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α) (n : nat), @eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             y
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             y
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@add_monoid.to_has_zero.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@add_semigroup.to_has_add.{u_1} α
                         (@add_monoid.to_add_semigroup.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α
                               (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
             (nat.choose n (nat.succ i)))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          y
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@add_monoid.to_has_zero.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@add_semigroup.to_has_add.{u_1} α
                            (@add_monoid.to_add_semigroup.{u_1} α
                               (@add_comm_monoid.to_add_monoid.{u_1} α
                                  (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
                (nat.choose n (nat.succ i))))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          y
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
                (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))
             (@coe.{1 u_1+1} nat α
                (@coe_to_lift.{1 u_1+1} nat α
                   (@coe_base.{1 u_1+1} nat α
                      (@nat.cast_coe.{u_1} α
                         (@add_monoid.to_has_zero.{u_1} α
                            (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                         (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                         (@add_semigroup.to_has_add.{u_1} α
                            (@add_monoid.to_add_semigroup.{u_1} α
                               (@add_comm_monoid.to_add_monoid.{u_1} α
                                  (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
                (nat.choose n (nat.succ i))))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          y)
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))
          (@coe.{1 u_1+1} nat α
             (@coe_to_lift.{1 u_1+1} nat α
                (@coe_base.{1 u_1+1} nat α
                   (@nat.cast_coe.{u_1} α
                      (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                      (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                      (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
             (nat.choose n (nat.succ i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
n i : nat,
h_mem : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)),
h_le : @has_le.le.{0} nat nat.has_le i n,
h_eq : not (@eq.{1} nat i n)
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x (nat.succ i))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i)))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@add_monoid.to_has_zero.{u_1} α
                      (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@add_semigroup.to_has_add.{u_1} α
                      (@add_monoid.to_add_semigroup.{u_1} α
                         (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))))
          (nat.choose n (nat.succ i))))
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_mul.mul.{u_1} α
          (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_mul.mul.{u_1} α
             (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
             (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x
                (nat.succ i))
             y)
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (@has_sub.sub.{0} nat nat.has_sub n (nat.succ i))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    induction n with n ih,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
n : nat,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case nat.zero
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       nat.zero)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ nat.zero))
       (t nat.zero))

case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ (nat.succ n)))
       (t (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    { rw [_root_.pow_zero, sum_range_succ, range_zero, sum_empty, add_zero],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pow_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_range_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.range_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 853, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a (@has_zero.zero.{0} nat nat.has_zero)) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β] (f : nat → β) (n : nat), @eq.{u_1+1} β (@finset.sum.{0 u_1} nat β _inst_1 (finset.range (nat.succ n)) f) (@has_add.add.{u_1} β (@add_semigroup.to_has_add.{u_1} β (@add_monoid.to_add_semigroup.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1))) (f n) (@finset.sum.{0 u_1} nat β _inst_1 (finset.range n) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (finset.{0} nat) (finset.range (@has_zero.zero.{0} nat nat.has_zero)) (@has_emptyc.emptyc.{0} (finset.{0} nat) (@finset.has_emptyc.{0} nat))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β] {α : Type} {f : α → β}, @eq.{u_1+1} β (@finset.sum.{0 u_1} α β _inst_1 (@has_emptyc.emptyc.{0} (finset.{0} α) (@finset.has_emptyc.{0} α)) f) (@has_zero.zero.{u_1} β (@add_monoid.to_has_zero.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1)) a (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case nat.zero
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       nat.zero)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ nat.zero))
       (t nat.zero))

case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ (nat.succ n)))
       (t (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.zero
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       nat.zero)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ nat.zero))
       (t nat.zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ nat.zero))
       (t nat.zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (t nat.zero nat.zero)
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range nat.zero)
          (t nat.zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (t nat.zero nat.zero)
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)
          (@has_emptyc.emptyc.{0} (finset.{0} nat) (@finset.has_emptyc.{0} nat))
          (t nat.zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (t nat.zero nat.zero)
       (@has_zero.zero.{u_1} α
          (@add_monoid.to_has_zero.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (t nat.zero nat.zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.zero
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (t nat.zero nat.zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      dsimp [t], rw [choose_self, nat.cast_one, mul_one, mul_one] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.choose_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.cast_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1081, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{1} nat (nat.choose n n) (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_monoid.{u_1} α] [_inst_2 : has_one.{u_1} α], @eq.{u_1+1} α (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α (@add_monoid.to_has_zero.{u_1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1))))) (@has_one.one.{0} nat nat.has_one)) (@has_one.one.{u_1} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.zero
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (t nat.zero nat.zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose (@has_zero.zero.{0} nat nat.has_zero) (@has_zero.zero.{0} nat nat.has_zero))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))))
       (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i))))
⊢ @eq.{u_1+1} α (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
    (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
          (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))))
       (@coe.{1 u_1+1} nat α
          (@coe_to_lift.{1 u_1+1} nat α
             (@coe_base.{1 u_1+1} nat α
                (@nat.cast_coe.{u_1} α
                   (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                   (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                   (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
          (nat.choose (@has_zero.zero.{0} nat nat.has_zero) (@has_zero.zero.{0} nat nat.has_zero))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ (nat.succ n)))
       (t (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    { rw[sum_range_succ&#x27;, h_first],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finset.sum_range_succ&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_first'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 529, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β] (f : nat → β) (n : nat), @eq.{u_1+1} β (@finset.sum.{0 u_1} nat β _inst_1 (finset.range (nat.succ n)) f) (@has_add.add.{u_1} β (@add_semigroup.to_has_add.{u_1} β (@add_monoid.to_add_semigroup.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1))) (@finset.sum.{0 u_1} nat β _inst_1 (finset.range n) (@function.comp.{1 1 u_1+1} nat nat β f nat.succ)) (f (@has_zero.zero.{0} nat nat.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero)) (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ (nat.succ n)))
       (t (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ))
       (t (nat.succ n) (@has_zero.zero.{0} nat nat.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53      rw[finset.sum_congr rfl (h_middle n), finset.sum_add_distrib, add_assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finset.sum_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_middle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.sum_add_distrib'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} {s₁ s₂ : finset.{0} α} {f g : α → β} [_inst_1 : add_comm_monoid.{u_1} β], @eq.{1} (finset.{0} α) s₁ s₂ → (∀ (x : α), @has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) x s₂ → @eq.{u_1+1} β (f x) (g x)) → @eq.{u_1+1} β (@finset.sum.{0 u_1} α β _inst_1 s₁ f) (@finset.sum.{0 u_1} α β _inst_1 s₂ g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (n i : nat), @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) → @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x (t n i)) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y (t n (nat.succ i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} {s : finset.{0} α} {f g : α → β} [_inst_1 : add_comm_monoid.{u_1} β], @eq.{u_1+1} β (@finset.sum.{0 u_1} α β _inst_1 s (λ (x : α), @has_add.add.{u_1} β (@add_semigroup.to_has_add.{u_1} β (@add_monoid.to_add_semigroup.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1))) (f x) (g x))) (@has_add.add.{u_1} β (@add_semigroup.to_has_add.{u_1} β (@add_monoid.to_add_semigroup.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1))) (@finset.sum.{0 u_1} α β _inst_1 s f) (@finset.sum.{0 u_1} α β _inst_1 s g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α _inst_1) (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α _inst_1) a b) c) (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α _inst_1) a (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (i : nat),
             @has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
               (@has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  x
                  (t n i))
               (@has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ i)))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x_1 : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  x
                  (t n x_1)))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x)))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54      rw[pow_succ (x + y), ih, add_mul, finset.mul_sum, finset.mul_sum],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pow_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mul_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mul_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 626, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 626, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α) (n : nat), @eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y) n) (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : distrib.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) a b) c) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a c) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} {s : finset.{0} α} {f : α → β} {b : β} [_inst_1 : semiring.{u_1} β], @eq.{u_1+1} β (@has_mul.mul.{u_1} β (@mul_zero_class.to_has_mul.{u_1} β (@semiring.to_mul_zero_class.{u_1} β _inst_1)) b (@finset.sum.{0 u_1} α β (@semiring.to_add_comm_monoid.{u_1} β _inst_1) s f)) (@finset.sum.{0 u_1} α β (@semiring.to_add_comm_monoid.{u_1} β _inst_1) s (λ (x : α), @has_mul.mul.{u_1} β (@mul_zero_class.to_has_mul.{u_1} β (@semiring.to_mul_zero_class.{u_1} β _inst_1)) b (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} {s : finset.{0} α} {f : α → β} {b : β} [_inst_1 : semiring.{u_1} β], @eq.{u_1+1} β (@has_mul.mul.{u_1} β (@mul_zero_class.to_has_mul.{u_1} β (@semiring.to_mul_zero_class.{u_1} β _inst_1)) b (@finset.sum.{0 u_1} α β (@semiring.to_add_comm_monoid.{u_1} β _inst_1) s f)) (@finset.sum.{0 u_1} α β (@semiring.to_add_comm_monoid.{u_1} β _inst_1) s (λ (x : α), @has_mul.mul.{u_1} β (@mul_zero_class.to_has_mul.{u_1} β (@semiring.to_mul_zero_class.{u_1} β _inst_1)) b (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (nat.succ n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
          (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
          n))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (t n)))
       (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) y
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (t n))))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) y
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (t n))))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n x))))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n x))))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55      congr&#x27; 1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n x))))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x_1 : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               x
               (t n x_1)))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x))))
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
             (nat.succ n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
       (λ (x : nat),
          @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n x)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n (nat.succ x))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56      rw[finset.sum_range_succ&#x27;, finset.sum_range_succ, h_first, h_last,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finset.sum_range_succ&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_range_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_first'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_last'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 529, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 318, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β] (f : nat → β) (n : nat), @eq.{u_1+1} β (@finset.sum.{0 u_1} nat β _inst_1 (finset.range (nat.succ n)) f) (@has_add.add.{u_1} β (@add_semigroup.to_has_add.{u_1} β (@add_monoid.to_add_semigroup.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1))) (@finset.sum.{0 u_1} nat β _inst_1 (finset.range n) (@function.comp.{1 1 u_1+1} nat nat β f nat.succ)) (f (@has_zero.zero.{0} nat nat.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β] (f : nat → β) (n : nat), @eq.{u_1+1} β (@finset.sum.{0 u_1} nat β _inst_1 (finset.range (nat.succ n)) f) (@has_add.add.{u_1} β (@add_semigroup.to_has_add.{u_1} β (@add_monoid.to_add_semigroup.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1))) (f n) (@finset.sum.{0 u_1} nat β _inst_1 (finset.range n) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero)) (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{u_1+1} α (t n (nat.succ n)) (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
       (λ (x : nat),
          @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n x)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n (nat.succ x))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (@function.comp.{1 1 u_1+1} nat nat α
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n x))
             nat.succ))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (t n (@has_zero.zero.{0} nat nat.has_zero))))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n (nat.succ x))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (@function.comp.{1 1 u_1+1} nat nat α
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n x))
             nat.succ))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (t n (@has_zero.zero.{0} nat nat.has_zero))))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
             (t n (nat.succ n)))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x)))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (@function.comp.{1 1 u_1+1} nat nat α
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n x))
             nat.succ))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
             (t n (nat.succ n)))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x)))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (@function.comp.{1 1 u_1+1} nat nat α
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n x))
             nat.succ))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
             (@has_zero.zero.{u_1} α
                (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x)))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57         mul_zero, zero_add, _root_.pow_succ] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pow_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : mul_zero_class.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α _inst_1) a (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))) (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α _inst_1)) (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α) (n : nat), @eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α _inst_1) a n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (@function.comp.{1 1 u_1+1} nat nat α
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n x))
             nat.succ))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
             (@has_zero.zero.{u_1} α
                (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x)))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (@function.comp.{1 1 u_1+1} nat nat α
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n x))
             nat.succ))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@has_add.add.{u_1} α
          (@add_semigroup.to_has_add.{u_1} α
             (@add_monoid.to_add_semigroup.{u_1} α
                (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
          (@has_zero.zero.{u_1} α
             (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)))
          (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n (nat.succ x)))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (@function.comp.{1 1 u_1+1} nat nat α
             (λ (x : nat),
                @has_mul.mul.{u_1} α
                  (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  y
                  (t n x))
             nat.succ))
       (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
          (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range n)
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n (nat.succ x))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : semiring.{u_1} α,
x y : α,
h : @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y,
t : nat → nat → α :=
  λ (n i : nat),
    @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
      (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x i)
         (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y
            (@has_sub.sub.{0} nat nat.has_sub n i)))
      (@coe.{1 u_1+1} nat α
         (@coe_to_lift.{1 u_1+1} nat α
            (@coe_base.{1 u_1+1} nat α
               (@nat.cast_coe.{u_1} α
                  (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
                  (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
                  (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)))))
         (nat.choose n i)),
h_first :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (@has_zero.zero.{0} nat nat.has_zero))
      (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y n),
h_last :
  ∀ (n : nat),
    @eq.{u_1+1} α (t n (nat.succ n))
      (@has_zero.zero.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))),
h_middle :
  ∀ (n i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i (finset.range (nat.succ n)) →
    @eq.{u_1+1} α (@function.comp.{1 1 u_1+1} nat nat α (t (nat.succ n)) nat.succ i)
      (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x
            (t n i))
         (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n (nat.succ i)))),
n : nat,
ih :
  @eq.{u_1+1} α
    (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1))
       (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y)
       n)
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (t n))
⊢ @eq.{u_1+1} α
    (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
       (λ (x : nat),
          @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) y
            (t n x)))
    (@has_add.add.{u_1} α
       (@add_semigroup.to_has_add.{u_1} α
          (@add_monoid.to_add_semigroup.{u_1} α
             (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1))))
       (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n))
          (λ (x : nat),
             @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1))
               y
               (t n (nat.succ x))))
       (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (nat.succ n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  /-- The binomial theorem-/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  theorem add_pow [comm_semiring α] (x y : α) (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='comm_semiring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    (x + y) ^ n = (range (succ n)).sum (λ m, x ^ m * y ^ (n - m) * choose n m) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1062, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_add.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type} [c : has_pow.{u_1 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β], finset.{0} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type} [c : has_pow.{u_1 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type} [c : has_pow.{u_1 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title=' `choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial
coefficients.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  (commute.all x y).add_pow n</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='commute.all'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='commute.add_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/commute.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {S : Type u_1} [_inst_1 : comm_semigroup.{u_1} S] (a b : S), @commute.{u_1} S (@semigroup.to_has_mul.{u_1} S (@comm_semigroup.to_semigroup.{u_1} S _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semiring.{u_1} α] {x y : α}, @commute.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) x y → ∀ (n : nat), @eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1)) x y) n) (@finset.sum.{0 u_1} nat α (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (finset.range (nat.succ n)) (λ (m : nat), @has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) x m) (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) y (@has_sub.sub.{0} nat nat.has_sub n m))) (@coe.{1 u_1+1} nat α (@coe_to_lift.{1 u_1+1} nat α (@coe_base.{1 u_1+1} nat α (@nat.cast_coe.{u_1} α (@mul_zero_class.to_has_zero.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α _inst_1)) (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α _inst_1))))) (nat.choose n m))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A version of the binomial theorem for noncommutative semirings.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  end binomial</code></pre>
</body>